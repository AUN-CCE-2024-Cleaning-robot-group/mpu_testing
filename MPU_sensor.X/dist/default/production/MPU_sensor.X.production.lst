CCS PCH C Compiler, Version 5.015, 5967               18-Dec-23 07:22

               Filename:   C:\Users\hp\Desktop\MPU_sensor.X\dist\default\production\MPU_sensor.X.production.lst

               ROM used:   11188 bytes (34%)
                           Largest free fragment is 21576
               RAM used:   109 (5%) at main() level
                           209 (10%) worst case
               Stack used: 13 locations (6 in main + 7 for interrupts)
               Stack size: 31

*
0000:  GOTO   2884
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.1
004A:  GOTO   0054
004E:  BTFSC  F9E.1
0050:  GOTO   1676
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #import(file="build/default/production/main.o") 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
01A6:  MOVF   xC0,W
01A8:  BTFSC  FD8.2
01AA:  BRA    02F6
01AC:  MOVWF  xCC
01AE:  MOVF   xC4,W
01B0:  BTFSC  FD8.2
01B2:  BRA    02F6
01B4:  SUBWF  xCC,F
01B6:  BNC   01C2
01B8:  MOVLW  7F
01BA:  ADDWF  xCC,F
01BC:  BTFSC  FD8.0
01BE:  BRA    02F6
01C0:  BRA    01CE
01C2:  MOVLW  81
01C4:  SUBWF  xCC,F
01C6:  BTFSS  FD8.0
01C8:  BRA    02F6
01CA:  BTFSC  FD8.2
01CC:  BRA    02F6
01CE:  MOVFF  CC,00
01D2:  CLRF   01
01D4:  CLRF   02
01D6:  CLRF   03
01D8:  CLRF   xCB
01DA:  MOVFF  C1,CA
01DE:  BSF    xCA.7
01E0:  MOVFF  C2,C9
01E4:  MOVFF  C3,C8
01E8:  MOVLW  19
01EA:  MOVWF  xCC
01EC:  MOVF   xC7,W
01EE:  SUBWF  xC8,F
01F0:  BC    020C
01F2:  MOVLW  01
01F4:  SUBWF  xC9,F
01F6:  BC    020C
01F8:  SUBWF  xCA,F
01FA:  BC    020C
01FC:  SUBWF  xCB,F
01FE:  BC    020C
0200:  INCF   xCB,F
0202:  INCF   xCA,F
0204:  INCF   xC9,F
0206:  MOVF   xC7,W
0208:  ADDWF  xC8,F
020A:  BRA    025C
020C:  MOVF   xC6,W
020E:  SUBWF  xC9,F
0210:  BC    0236
0212:  MOVLW  01
0214:  SUBWF  xCA,F
0216:  BC    0236
0218:  SUBWF  xCB,F
021A:  BC    0236
021C:  INCF   xCB,F
021E:  INCF   xCA,F
0220:  MOVF   xC6,W
0222:  ADDWF  xC9,F
0224:  MOVF   xC7,W
0226:  ADDWF  xC8,F
0228:  BNC   025C
022A:  INCF   xC9,F
022C:  BNZ   025C
022E:  INCF   xCA,F
0230:  BNZ   025C
0232:  INCF   xCB,F
0234:  BRA    025C
0236:  MOVF   xC5,W
0238:  IORLW  80
023A:  SUBWF  xCA,F
023C:  BC    025A
023E:  MOVLW  01
0240:  SUBWF  xCB,F
0242:  BC    025A
0244:  INCF   xCB,F
0246:  MOVF   xC5,W
0248:  IORLW  80
024A:  ADDWF  xCA,F
024C:  MOVF   xC6,W
024E:  ADDWF  xC9,F
0250:  BNC   0224
0252:  INCF   xCA,F
0254:  BNZ   0224
0256:  INCF   xCB,F
0258:  BRA    0224
025A:  BSF    03.0
025C:  DECFSZ xCC,F
025E:  BRA    0262
0260:  BRA    0278
0262:  BCF    FD8.0
0264:  RLCF   xC8,F
0266:  RLCF   xC9,F
0268:  RLCF   xCA,F
026A:  RLCF   xCB,F
026C:  BCF    FD8.0
026E:  RLCF   03,F
0270:  RLCF   02,F
0272:  RLCF   01,F
0274:  RLCF   xCD,F
0276:  BRA    01EC
0278:  BTFSS  xCD.0
027A:  BRA    0288
027C:  BCF    FD8.0
027E:  RRCF   01,F
0280:  RRCF   02,F
0282:  RRCF   03,F
0284:  RRCF   xCD,F
0286:  BRA    028C
0288:  DECF   00,F
028A:  BZ    02F6
028C:  BTFSC  xCD.7
028E:  BRA    02CC
0290:  BCF    FD8.0
0292:  RLCF   xC8,F
0294:  RLCF   xC9,F
0296:  RLCF   xCA,F
0298:  RLCF   xCB,F
029A:  MOVF   xC7,W
029C:  SUBWF  xC8,F
029E:  BC    02AE
02A0:  MOVLW  01
02A2:  SUBWF  xC9,F
02A4:  BC    02AE
02A6:  SUBWF  xCA,F
02A8:  BC    02AE
02AA:  SUBWF  xCB,F
02AC:  BNC   02E2
02AE:  MOVF   xC6,W
02B0:  SUBWF  xC9,F
02B2:  BC    02BE
02B4:  MOVLW  01
02B6:  SUBWF  xCA,F
02B8:  BC    02BE
02BA:  SUBWF  xCB,F
02BC:  BNC   02E2
02BE:  MOVF   xC5,W
02C0:  IORLW  80
02C2:  SUBWF  xCA,F
02C4:  BC    02CC
02C6:  MOVLW  01
02C8:  SUBWF  xCB,F
02CA:  BNC   02E2
02CC:  INCF   03,F
02CE:  BNZ   02E2
02D0:  INCF   02,F
02D2:  BNZ   02E2
02D4:  INCF   01,F
02D6:  BNZ   02E2
02D8:  INCF   00,F
02DA:  BZ    02F6
02DC:  RRCF   01,F
02DE:  RRCF   02,F
02E0:  RRCF   03,F
02E2:  MOVFF  C1,CC
02E6:  MOVF   xC5,W
02E8:  XORWF  xCC,F
02EA:  BTFSS  xCC.7
02EC:  BRA    02F2
02EE:  BSF    01.7
02F0:  BRA    02FE
02F2:  BCF    01.7
02F4:  BRA    02FE
02F6:  CLRF   00
02F8:  CLRF   01
02FA:  CLRF   02
02FC:  CLRF   03
02FE:  RETURN 0
*
0416:  MOVLW  80
0418:  BTFSC  FD8.1
041A:  XORWF  xC6,F
041C:  CLRF   xCB
041E:  CLRF   xCC
0420:  MOVFF  C2,CA
0424:  MOVF   xC6,W
0426:  XORWF  xCA,F
0428:  MOVF   xC1,W
042A:  BTFSC  FD8.2
042C:  BRA    05E6
042E:  MOVWF  xC9
0430:  MOVWF  00
0432:  MOVF   xC5,W
0434:  BTFSC  FD8.2
0436:  BRA    05F8
0438:  SUBWF  xC9,F
043A:  BTFSC  FD8.2
043C:  BRA    0540
043E:  BNC   04BA
0440:  MOVFF  C6,CF
0444:  BSF    xCF.7
0446:  MOVFF  C7,CE
044A:  MOVFF  C8,CD
044E:  CLRF   xCC
0450:  BCF    FD8.0
0452:  RRCF   xCF,F
0454:  RRCF   xCE,F
0456:  RRCF   xCD,F
0458:  RRCF   xCC,F
045A:  DECFSZ xC9,F
045C:  BRA    044E
045E:  BTFSS  xCA.7
0460:  BRA    0468
0462:  BSF    xCB.0
0464:  BRA    0620
0466:  BCF    xCB.0
0468:  BCF    xC9.0
046A:  BSF    xCB.4
046C:  CLRF   FEA
046E:  MOVLW  C4
0470:  MOVWF  FE9
0472:  BRA    0646
0474:  BCF    xCB.4
0476:  BTFSC  xCA.7
0478:  BRA    048E
047A:  BTFSS  xC9.0
047C:  BRA    04A4
047E:  RRCF   xCF,F
0480:  RRCF   xCE,F
0482:  RRCF   xCD,F
0484:  RRCF   xCC,F
0486:  INCF   00,F
0488:  BTFSC  FD8.2
048A:  BRA    0616
048C:  BRA    04A4
048E:  BTFSC  xCF.7
0490:  BRA    04AA
0492:  BCF    FD8.0
0494:  RLCF   xCC,F
0496:  RLCF   xCD,F
0498:  RLCF   xCE,F
049A:  RLCF   xCF,F
049C:  DECF   00,F
049E:  BTFSC  FD8.2
04A0:  BRA    0616
04A2:  BRA    048E
04A4:  BSF    xCB.6
04A6:  BRA    057E
04A8:  BCF    xCB.6
04AA:  MOVFF  C2,CA
04AE:  BTFSS  xC2.7
04B0:  BRA    04B6
04B2:  BSF    xCF.7
04B4:  BRA    0608
04B6:  BCF    xCF.7
04B8:  BRA    0608
04BA:  MOVFF  C5,C9
04BE:  MOVFF  C5,00
04C2:  MOVF   xC1,W
04C4:  SUBWF  xC9,F
04C6:  MOVFF  C2,CF
04CA:  BSF    xCF.7
04CC:  MOVFF  C3,CE
04D0:  MOVFF  C4,CD
04D4:  CLRF   xCC
04D6:  BCF    FD8.0
04D8:  RRCF   xCF,F
04DA:  RRCF   xCE,F
04DC:  RRCF   xCD,F
04DE:  RRCF   xCC,F
04E0:  DECFSZ xC9,F
04E2:  BRA    04D4
04E4:  BTFSS  xCA.7
04E6:  BRA    04EE
04E8:  BSF    xCB.1
04EA:  BRA    0620
04EC:  BCF    xCB.1
04EE:  BCF    xC9.0
04F0:  BSF    xCB.5
04F2:  CLRF   FEA
04F4:  MOVLW  C8
04F6:  MOVWF  FE9
04F8:  BRA    0646
04FA:  BCF    xCB.5
04FC:  BTFSC  xCA.7
04FE:  BRA    0514
0500:  BTFSS  xC9.0
0502:  BRA    052A
0504:  RRCF   xCF,F
0506:  RRCF   xCE,F
0508:  RRCF   xCD,F
050A:  RRCF   xCC,F
050C:  INCF   00,F
050E:  BTFSC  FD8.2
0510:  BRA    0616
0512:  BRA    052A
0514:  BTFSC  xCF.7
0516:  BRA    0530
0518:  BCF    FD8.0
051A:  RLCF   xCC,F
051C:  RLCF   xCD,F
051E:  RLCF   xCE,F
0520:  RLCF   xCF,F
0522:  DECF   00,F
0524:  BTFSC  FD8.2
0526:  BRA    0616
0528:  BRA    0514
052A:  BSF    xCB.7
052C:  BRA    057E
052E:  BCF    xCB.7
0530:  MOVFF  C6,CA
0534:  BTFSS  xC6.7
0536:  BRA    053C
0538:  BSF    xCF.7
053A:  BRA    0608
053C:  BCF    xCF.7
053E:  BRA    0608
0540:  MOVFF  C6,CF
0544:  BSF    xCF.7
0546:  MOVFF  C7,CE
054A:  MOVFF  C8,CD
054E:  BTFSS  xCA.7
0550:  BRA    055A
0552:  BCF    xCF.7
0554:  BSF    xCB.2
0556:  BRA    0620
0558:  BCF    xCB.2
055A:  CLRF   xCC
055C:  BCF    xC9.0
055E:  CLRF   FEA
0560:  MOVLW  C4
0562:  MOVWF  FE9
0564:  BRA    0646
0566:  BTFSC  xCA.7
0568:  BRA    05A2
056A:  MOVFF  C2,CA
056E:  BTFSS  xC9.0
0570:  BRA    057E
0572:  RRCF   xCF,F
0574:  RRCF   xCE,F
0576:  RRCF   xCD,F
0578:  RRCF   xCC,F
057A:  INCF   00,F
057C:  BZ    0616
057E:  BTFSS  xCC.7
0580:  BRA    0598
0582:  INCF   xCD,F
0584:  BNZ   0598
0586:  INCF   xCE,F
0588:  BNZ   0598
058A:  INCF   xCF,F
058C:  BNZ   0598
058E:  RRCF   xCF,F
0590:  RRCF   xCE,F
0592:  RRCF   xCD,F
0594:  INCF   00,F
0596:  BZ    0616
0598:  BTFSC  xCB.6
059A:  BRA    04A8
059C:  BTFSC  xCB.7
059E:  BRA    052E
05A0:  BRA    05DA
05A2:  MOVLW  80
05A4:  XORWF  xCF,F
05A6:  BTFSS  xCF.7
05A8:  BRA    05B2
05AA:  BRA    0620
05AC:  MOVFF  C6,CA
05B0:  BRA    05C6
05B2:  MOVFF  C2,CA
05B6:  MOVF   xCF,F
05B8:  BNZ   05C6
05BA:  MOVF   xCE,F
05BC:  BNZ   05C6
05BE:  MOVF   xCD,F
05C0:  BNZ   05C6
05C2:  CLRF   00
05C4:  BRA    0608
05C6:  BTFSC  xCF.7
05C8:  BRA    05DA
05CA:  BCF    FD8.0
05CC:  RLCF   xCC,F
05CE:  RLCF   xCD,F
05D0:  RLCF   xCE,F
05D2:  RLCF   xCF,F
05D4:  DECFSZ 00,F
05D6:  BRA    05C6
05D8:  BRA    0616
05DA:  BTFSS  xCA.7
05DC:  BRA    05E2
05DE:  BSF    xCF.7
05E0:  BRA    0608
05E2:  BCF    xCF.7
05E4:  BRA    0608
05E6:  MOVFF  C5,00
05EA:  MOVFF  C6,CF
05EE:  MOVFF  C7,CE
05F2:  MOVFF  C8,CD
05F6:  BRA    0608
05F8:  MOVFF  C1,00
05FC:  MOVFF  C2,CF
0600:  MOVFF  C3,CE
0604:  MOVFF  C4,CD
0608:  MOVFF  CF,01
060C:  MOVFF  CE,02
0610:  MOVFF  CD,03
0614:  BRA    067E
0616:  CLRF   00
0618:  CLRF   01
061A:  CLRF   02
061C:  CLRF   03
061E:  BRA    067E
0620:  CLRF   xCC
0622:  COMF   xCD,F
0624:  COMF   xCE,F
0626:  COMF   xCF,F
0628:  COMF   xCC,F
062A:  INCF   xCC,F
062C:  BNZ   0638
062E:  INCF   xCD,F
0630:  BNZ   0638
0632:  INCF   xCE,F
0634:  BNZ   0638
0636:  INCF   xCF,F
0638:  BTFSC  xCB.0
063A:  BRA    0466
063C:  BTFSC  xCB.1
063E:  BRA    04EC
0640:  BTFSC  xCB.2
0642:  BRA    0558
0644:  BRA    05AC
0646:  MOVF   FEF,W
0648:  ADDWF  xCD,F
064A:  BNC   0656
064C:  INCF   xCE,F
064E:  BNZ   0656
0650:  INCF   xCF,F
0652:  BTFSC  FD8.2
0654:  BSF    xC9.0
0656:  MOVF   FED,F
0658:  MOVF   FEF,W
065A:  ADDWF  xCE,F
065C:  BNC   0664
065E:  INCF   xCF,F
0660:  BTFSC  FD8.2
0662:  BSF    xC9.0
0664:  MOVF   FED,F
0666:  MOVF   FEF,W
0668:  BTFSC  FEF.7
066A:  BRA    066E
066C:  XORLW  80
066E:  ADDWF  xCF,F
0670:  BTFSC  FD8.0
0672:  BSF    xC9.0
0674:  BTFSC  xCB.4
0676:  BRA    0474
0678:  BTFSC  xCB.5
067A:  BRA    04FA
067C:  BRA    0566
067E:  RETURN 0
*
0846:  MOVF   xC0,W
0848:  BTFSC  FD8.2
084A:  BRA    092E
084C:  MOVWF  00
084E:  MOVF   xC4,W
0850:  BTFSC  FD8.2
0852:  BRA    092E
0854:  ADDWF  00,F
0856:  BNC   0860
0858:  MOVLW  81
085A:  ADDWF  00,F
085C:  BC    092E
085E:  BRA    0868
0860:  MOVLW  7F
0862:  SUBWF  00,F
0864:  BNC   092E
0866:  BZ    092E
0868:  MOVFF  C1,C8
086C:  MOVF   xC5,W
086E:  XORWF  xC8,F
0870:  BSF    xC1.7
0872:  BSF    xC5.7
0874:  MOVF   xC3,W
0876:  MULWF  xC7
0878:  MOVFF  FF4,CA
087C:  MOVF   xC2,W
087E:  MULWF  xC6
0880:  MOVFF  FF4,03
0884:  MOVFF  FF3,C9
0888:  MULWF  xC7
088A:  MOVF   FF3,W
088C:  ADDWF  xCA,F
088E:  MOVF   FF4,W
0890:  ADDWFC xC9,F
0892:  MOVLW  00
0894:  ADDWFC 03,F
0896:  MOVF   xC3,W
0898:  MULWF  xC6
089A:  MOVF   FF3,W
089C:  ADDWF  xCA,F
089E:  MOVF   FF4,W
08A0:  ADDWFC xC9,F
08A2:  MOVLW  00
08A4:  CLRF   02
08A6:  ADDWFC 03,F
08A8:  ADDWFC 02,F
08AA:  MOVF   xC1,W
08AC:  MULWF  xC7
08AE:  MOVF   FF3,W
08B0:  ADDWF  xC9,F
08B2:  MOVF   FF4,W
08B4:  ADDWFC 03,F
08B6:  MOVLW  00
08B8:  ADDWFC 02,F
08BA:  MOVF   xC1,W
08BC:  MULWF  xC6
08BE:  MOVF   FF3,W
08C0:  ADDWF  03,F
08C2:  MOVF   FF4,W
08C4:  ADDWFC 02,F
08C6:  MOVLW  00
08C8:  CLRF   01
08CA:  ADDWFC 01,F
08CC:  MOVF   xC3,W
08CE:  MULWF  xC5
08D0:  MOVF   FF3,W
08D2:  ADDWF  xC9,F
08D4:  MOVF   FF4,W
08D6:  ADDWFC 03,F
08D8:  MOVLW  00
08DA:  ADDWFC 02,F
08DC:  ADDWFC 01,F
08DE:  MOVF   xC2,W
08E0:  MULWF  xC5
08E2:  MOVF   FF3,W
08E4:  ADDWF  03,F
08E6:  MOVF   FF4,W
08E8:  ADDWFC 02,F
08EA:  MOVLW  00
08EC:  ADDWFC 01,F
08EE:  MOVF   xC1,W
08F0:  MULWF  xC5
08F2:  MOVF   FF3,W
08F4:  ADDWF  02,F
08F6:  MOVF   FF4,W
08F8:  ADDWFC 01,F
08FA:  INCF   00,F
08FC:  BTFSC  01.7
08FE:  BRA    090A
0900:  RLCF   xC9,F
0902:  RLCF   03,F
0904:  RLCF   02,F
0906:  RLCF   01,F
0908:  DECF   00,F
090A:  MOVLW  00
090C:  BTFSS  xC9.7
090E:  BRA    0924
0910:  INCF   03,F
0912:  ADDWFC 02,F
0914:  ADDWFC 01,F
0916:  MOVF   01,W
0918:  BNZ   0924
091A:  MOVF   02,W
091C:  BNZ   0924
091E:  MOVF   03,W
0920:  BNZ   0924
0922:  INCF   00,F
0924:  BTFSC  xC8.7
0926:  BSF    01.7
0928:  BTFSS  xC8.7
092A:  BCF    01.7
092C:  BRA    0936
092E:  CLRF   00
0930:  CLRF   01
0932:  CLRF   02
0934:  CLRF   03
0936:  RETURN 0
*
13AC:  MOVLW  8E
13AE:  MOVWF  00
13B0:  MOVFF  9C,01
13B4:  MOVFF  9B,02
13B8:  CLRF   03
13BA:  MOVF   01,F
13BC:  BNZ   13D0
13BE:  MOVFF  02,01
13C2:  CLRF   02
13C4:  MOVLW  08
13C6:  SUBWF  00,F
13C8:  MOVF   01,F
13CA:  BNZ   13D0
13CC:  CLRF   00
13CE:  BRA    13E0
13D0:  BCF    FD8.0
13D2:  BTFSC  01.7
13D4:  BRA    13DE
13D6:  RLCF   02,F
13D8:  RLCF   01,F
13DA:  DECF   00,F
13DC:  BRA    13D0
13DE:  BCF    01.7
13E0:  RETURN 0
*
163E:  MOVLW  8E
1640:  MOVWF  00
1642:  MOVF   x9B,W
1644:  SUBWF  00,F
1646:  MOVFF  9C,02
164A:  MOVFF  9D,01
164E:  BSF    02.7
1650:  MOVF   00,F
1652:  BZ    1666
1654:  BCF    FD8.0
1656:  MOVF   02,F
1658:  BNZ   165E
165A:  MOVF   01,F
165C:  BZ    1666
165E:  RRCF   02,F
1660:  RRCF   01,F
1662:  DECFSZ 00,F
1664:  BRA    1654
1666:  BTFSS  x9C.7
1668:  BRA    1674
166A:  COMF   01,F
166C:  COMF   02,F
166E:  INCF   01,F
1670:  BTFSC  FD8.2
1672:  INCF   02,F
1674:  RETURN 0
*
1812:  DATA 1B,5B
1814:  DATA 33,33
1816:  DATA 6D,73
1818:  DATA 74,61
181A:  DATA 72,74
181C:  DATA 20,6F
181E:  DATA 66,20
1820:  DATA 69,6E
1822:  DATA 69,74
1824:  DATA 20,20
1826:  DATA 0A,0D
1828:  DATA 1B,5B
182A:  DATA 30,6D
182C:  DATA 00,00
182E:  DATA 43,61
1830:  DATA 6C,69
1832:  DATA 62,72
1834:  DATA 61,74
1836:  DATA 69,6F
1838:  DATA 6E,20
183A:  DATA 6F,66
183C:  DATA 20,47
183E:  DATA 79,72
1840:  DATA 6F,20
1842:  DATA 69,73
1844:  DATA 20,73
1846:  DATA 74,61
1848:  DATA 72,74
184A:  DATA 65,64
184C:  DATA 20,64
184E:  DATA 6F,6E
1850:  DATA 27,74
1852:  DATA 20,6D
1854:  DATA 6F,76
1856:  DATA 65,20
1858:  DATA 74,68
185A:  DATA 65,20
185C:  DATA 73,65
185E:  DATA 6E,73
1860:  DATA 6F,72
1862:  DATA 0A,0D
1864:  DATA 00,00
1866:  DATA 43,61
1868:  DATA 6C,69
186A:  DATA 62,72
186C:  DATA 61,74
186E:  DATA 69,6F
1870:  DATA 6E,20
1872:  DATA 6F,66
1874:  DATA 20,47
1876:  DATA 79,72
1878:  DATA 6F,20
187A:  DATA 69,73
187C:  DATA 20,66
187E:  DATA 69,6E
1880:  DATA 69,73
1882:  DATA 68,65
1884:  DATA 64,0A
1886:  DATA 0D,00
1888:  DATA 52,61
188A:  DATA 74,65
188C:  DATA 43,61
188E:  DATA 6C,69
1890:  DATA 62,72
1892:  DATA 61,74
1894:  DATA 69,6F
1896:  DATA 6E,50
1898:  DATA 69,74
189A:  DATA 63,68
189C:  DATA 20,3D
189E:  DATA 20,25
18A0:  DATA 2E,35
18A2:  DATA 66,20
18A4:  DATA 2C,20
18A6:  DATA 52,61
18A8:  DATA 74,65
18AA:  DATA 43,61
18AC:  DATA 6C,69
18AE:  DATA 62,72
18B0:  DATA 61,74
18B2:  DATA 69,6F
18B4:  DATA 6E,52
18B6:  DATA 6F,6C
18B8:  DATA 6C,20
18BA:  DATA 3D,20
18BC:  DATA 25,2E
18BE:  DATA 35,66
18C0:  DATA 20,2C
18C2:  DATA 20,52
18C4:  DATA 61,74
18C6:  DATA 65,43
18C8:  DATA 61,6C
18CA:  DATA 69,62
18CC:  DATA 72,61
18CE:  DATA 74,69
18D0:  DATA 6F,6E
18D2:  DATA 59,61
18D4:  DATA 77,20
18D6:  DATA 3D,20
18D8:  DATA 25,2E
18DA:  DATA 35,66
18DC:  DATA 20,0A
18DE:  DATA 0D,00
18E0:  DATA 52,6F
18E2:  DATA 6C,6C
18E4:  DATA 20,3D
18E6:  DATA 20,25
18E8:  DATA 64,20
18EA:  DATA 20,50
18EC:  DATA 69,74
18EE:  DATA 63,68
18F0:  DATA 20,3D
18F2:  DATA 20,25
18F4:  DATA 64,20
18F6:  DATA 20,0A
18F8:  DATA 0D,00
18FA:  DATA 52,6F
18FC:  DATA 6C,6C
18FE:  DATA 61,63
1900:  DATA 63,20
1902:  DATA 3D,20
1904:  DATA 25,64
1906:  DATA 20,20
1908:  DATA 50,69
190A:  DATA 74,63
190C:  DATA 68,61
190E:  DATA 63,63
1910:  DATA 20,3D
1912:  DATA 20,25
1914:  DATA 64,20
1916:  DATA 20,0A
1918:  DATA 0D,00
*
1AF2:  TBLRD*+
1AF4:  MOVF   FF5,F
1AF6:  BZ    1B12
1AF8:  MOVFF  FF6,78
1AFC:  MOVFF  FF7,79
1B00:  MOVF   FF5,W
1B02:  BTFSS  F9E.4
1B04:  BRA    1B02
1B06:  MOVWF  FAD
1B08:  MOVFF  78,FF6
1B0C:  MOVFF  79,FF7
1B10:  BRA    1AF2
1B12:  RETURN 0
*
1C5C:  TBLRD*+
1C5E:  MOVFF  FF6,7A
1C62:  MOVFF  FF7,7B
1C66:  MOVF   FF5,W
1C68:  BTFSS  F9E.4
1C6A:  BRA    1C68
1C6C:  MOVWF  FAD
1C6E:  MOVFF  7A,FF6
1C72:  MOVFF  7B,FF7
1C76:  DECFSZ x79,F
1C78:  BRA    1C5C
1C7A:  RETURN 0
*
20A0:  MOVF   x84,W
20A2:  SUBLW  B6
20A4:  MOVWF  x84
20A6:  CLRF   03
20A8:  MOVFF  85,88
20AC:  BSF    x85.7
20AE:  BCF    FD8.0
20B0:  RRCF   x85,F
20B2:  RRCF   x86,F
20B4:  RRCF   x87,F
20B6:  RRCF   03,F
20B8:  RRCF   02,F
20BA:  RRCF   01,F
20BC:  RRCF   00,F
20BE:  DECFSZ x84,F
20C0:  BRA    20AE
20C2:  BTFSS  x88.7
20C4:  BRA    20DC
20C6:  COMF   00,F
20C8:  COMF   01,F
20CA:  COMF   02,F
20CC:  COMF   03,F
20CE:  INCF   00,F
20D0:  BTFSC  FD8.2
20D2:  INCF   01,F
20D4:  BTFSC  FD8.2
20D6:  INCF   02,F
20D8:  BTFSC  FD8.2
20DA:  INCF   03,F
20DC:  GOTO   21CA (RETURN)
20E0:  BTFSC  FD8.1
20E2:  BRA    20EA
20E4:  CLRF   FEA
20E6:  MOVLW  8C
20E8:  MOVWF  FE9
20EA:  CLRF   00
20EC:  CLRF   01
20EE:  CLRF   02
20F0:  CLRF   03
20F2:  CLRF   x8C
20F4:  CLRF   x8D
20F6:  CLRF   x8E
20F8:  CLRF   x8F
20FA:  MOVF   x8B,W
20FC:  IORWF  x8A,W
20FE:  IORWF  x89,W
2100:  IORWF  x88,W
2102:  BZ    215C
2104:  MOVLW  20
2106:  MOVWF  x90
2108:  BCF    FD8.0
210A:  RLCF   x84,F
210C:  RLCF   x85,F
210E:  RLCF   x86,F
2110:  RLCF   x87,F
2112:  RLCF   x8C,F
2114:  RLCF   x8D,F
2116:  RLCF   x8E,F
2118:  RLCF   x8F,F
211A:  MOVF   x8B,W
211C:  SUBWF  x8F,W
211E:  BNZ   2130
2120:  MOVF   x8A,W
2122:  SUBWF  x8E,W
2124:  BNZ   2130
2126:  MOVF   x89,W
2128:  SUBWF  x8D,W
212A:  BNZ   2130
212C:  MOVF   x88,W
212E:  SUBWF  x8C,W
2130:  BNC   2150
2132:  MOVF   x88,W
2134:  SUBWF  x8C,F
2136:  MOVF   x89,W
2138:  BTFSS  FD8.0
213A:  INCFSZ x89,W
213C:  SUBWF  x8D,F
213E:  MOVF   x8A,W
2140:  BTFSS  FD8.0
2142:  INCFSZ x8A,W
2144:  SUBWF  x8E,F
2146:  MOVF   x8B,W
2148:  BTFSS  FD8.0
214A:  INCFSZ x8B,W
214C:  SUBWF  x8F,F
214E:  BSF    FD8.0
2150:  RLCF   00,F
2152:  RLCF   01,F
2154:  RLCF   02,F
2156:  RLCF   03,F
2158:  DECFSZ x90,F
215A:  BRA    2108
215C:  MOVFF  8C,FEF
2160:  MOVFF  8D,FEC
2164:  MOVFF  8E,FEC
2168:  MOVFF  8F,FEC
216C:  RETURN 0
216E:  MOVF   FE9,W
2170:  MOVWF  x7C
2172:  MOVF   x7B,W
2174:  MOVWF  x7E
2176:  BZ    21B8
2178:  CLRF   16
217A:  BTFSC  FF2.7
217C:  BSF    16.7
217E:  BCF    FF2.7
2180:  MOVFF  7A,C3
2184:  MOVFF  79,C2
2188:  MOVFF  78,C1
218C:  MOVFF  77,C0
2190:  CLRF   xC7
2192:  CLRF   xC6
2194:  MOVLW  20
2196:  MOVWF  xC5
2198:  MOVLW  82
219A:  MOVWF  xC4
219C:  CALL   0846
21A0:  BTFSC  16.7
21A2:  BSF    FF2.7
21A4:  MOVFF  03,7A
21A8:  MOVFF  02,79
21AC:  MOVFF  01,78
21B0:  MOVFF  00,77
21B4:  DECFSZ x7E,F
21B6:  BRA    2178
21B8:  MOVFF  7A,87
21BC:  MOVFF  79,86
21C0:  MOVFF  78,85
21C4:  MOVFF  77,84
21C8:  BRA    20A0
21CA:  MOVFF  03,7A
21CE:  MOVFF  02,79
21D2:  MOVFF  01,78
21D6:  MOVFF  00,77
21DA:  BTFSS  x7A.7
21DC:  BRA    21F8
21DE:  DECF   x7C,F
21E0:  BSF    x7C.5
21E2:  COMF   x77,F
21E4:  COMF   x78,F
21E6:  COMF   x79,F
21E8:  COMF   x7A,F
21EA:  INCF   x77,F
21EC:  BTFSC  FD8.2
21EE:  INCF   x78,F
21F0:  BTFSC  FD8.2
21F2:  INCF   x79,F
21F4:  BTFSC  FD8.2
21F6:  INCF   x7A,F
21F8:  MOVLW  3B
21FA:  MOVWF  x83
21FC:  MOVLW  9A
21FE:  MOVWF  x82
2200:  MOVLW  CA
2202:  MOVWF  x81
2204:  CLRF   x80
2206:  MOVLW  0A
2208:  MOVWF  x7E
220A:  MOVF   x7B,W
220C:  BTFSC  FD8.2
220E:  INCF   x7C,F
2210:  BSF    FD8.1
2212:  CLRF   FEA
2214:  MOVLW  77
2216:  MOVWF  FE9
2218:  MOVFF  7A,87
221C:  MOVFF  79,86
2220:  MOVFF  78,85
2224:  MOVFF  77,84
2228:  MOVFF  83,8B
222C:  MOVFF  82,8A
2230:  MOVFF  81,89
2234:  MOVFF  80,88
2238:  RCALL  20E0
223A:  MOVF   01,W
223C:  MOVF   00,F
223E:  BNZ   225E
2240:  INCF   x7B,W
2242:  SUBWF  x7E,W
2244:  BZ    225E
2246:  MOVF   x7C,W
2248:  BZ    2262
224A:  ANDLW  0F
224C:  SUBWF  x7E,W
224E:  BZ    2252
2250:  BC    22C8
2252:  BTFSC  x7C.7
2254:  BRA    22C8
2256:  BTFSC  x7C.6
2258:  BRA    2262
225A:  MOVLW  20
225C:  BRA    22BE
225E:  MOVLW  20
2260:  ANDWF  x7C,F
2262:  BTFSS  x7C.5
2264:  BRA    2280
2266:  BCF    x7C.5
2268:  MOVF   x7B,W
226A:  BTFSS  FD8.2
226C:  DECF   x7C,F
226E:  MOVF   00,W
2270:  MOVWF  x7C
2272:  MOVLW  2D
2274:  BTFSS  F9E.4
2276:  BRA    2274
2278:  MOVWF  FAD
227A:  MOVF   x7C,W
227C:  MOVWF  00
227E:  CLRF   x7C
2280:  MOVF   x7B,W
2282:  SUBWF  x7E,W
2284:  BNZ   229C
2286:  MOVF   00,W
2288:  MOVWF  x7C
228A:  MOVLW  2E
228C:  BTFSS  F9E.4
228E:  BRA    228C
2290:  MOVWF  FAD
2292:  MOVF   x7C,W
2294:  MOVWF  00
2296:  MOVLW  20
2298:  ANDWF  x7C,F
229A:  MOVLW  00
229C:  MOVLW  30
229E:  BTFSS  x7C.5
22A0:  BRA    22BE
22A2:  BCF    x7C.5
22A4:  MOVF   x7B,W
22A6:  BTFSS  FD8.2
22A8:  DECF   x7C,F
22AA:  MOVF   00,W
22AC:  MOVWF  x7C
22AE:  MOVLW  2D
22B0:  BTFSS  F9E.4
22B2:  BRA    22B0
22B4:  MOVWF  FAD
22B6:  MOVF   x7C,W
22B8:  MOVWF  00
22BA:  CLRF   x7C
22BC:  MOVLW  30
22BE:  ADDWF  00,F
22C0:  MOVF   00,W
22C2:  BTFSS  F9E.4
22C4:  BRA    22C2
22C6:  MOVWF  FAD
22C8:  BCF    FD8.1
22CA:  MOVFF  83,87
22CE:  MOVFF  82,86
22D2:  MOVFF  81,85
22D6:  MOVFF  80,84
22DA:  CLRF   x8B
22DC:  CLRF   x8A
22DE:  CLRF   x89
22E0:  MOVLW  0A
22E2:  MOVWF  x88
22E4:  RCALL  20E0
22E6:  MOVFF  03,83
22EA:  MOVFF  02,82
22EE:  MOVFF  01,81
22F2:  MOVFF  00,80
22F6:  DECFSZ x7E,F
22F8:  BRA    2210
22FA:  RETURN 0
*
27AA:  MOVF   x80,W
27AC:  CLRF   01
27AE:  SUBWF  x7F,W
27B0:  BC    27B8
27B2:  MOVFF  7F,00
27B6:  BRA    27D0
27B8:  CLRF   00
27BA:  MOVLW  08
27BC:  MOVWF  x81
27BE:  RLCF   x7F,F
27C0:  RLCF   00,F
27C2:  MOVF   x80,W
27C4:  SUBWF  00,W
27C6:  BTFSC  FD8.0
27C8:  MOVWF  00
27CA:  RLCF   01,F
27CC:  DECFSZ x81,F
27CE:  BRA    27BE
27D0:  RETURN 0
27D2:  MOVLW  20
27D4:  BTFSS  x7A.4
27D6:  MOVLW  30
27D8:  MOVWF  x7B
27DA:  MOVFF  79,00
27DE:  BTFSS  x79.7
27E0:  BRA    27F2
27E2:  COMF   00,F
27E4:  INCF   00,F
27E6:  MOVFF  00,79
27EA:  MOVLW  2D
27EC:  MOVWF  x7B
27EE:  BSF    x7A.7
27F0:  BSF    x7A.0
27F2:  MOVF   01,W
27F4:  MOVFF  79,7F
27F8:  MOVLW  64
27FA:  MOVWF  x80
27FC:  RCALL  27AA
27FE:  MOVFF  00,79
2802:  MOVLW  30
2804:  ADDWF  01,W
2806:  MOVWF  x7C
2808:  MOVFF  79,7F
280C:  MOVLW  0A
280E:  MOVWF  x80
2810:  RCALL  27AA
2812:  MOVLW  30
2814:  ADDWF  00,W
2816:  MOVWF  x7E
2818:  MOVLW  30
281A:  ADDWF  01,W
281C:  MOVWF  x7D
281E:  MOVFF  7B,00
2822:  MOVLW  30
2824:  SUBWF  x7C,W
2826:  BZ    2830
2828:  BSF    x7A.1
282A:  BTFSC  x7A.7
282C:  BSF    x7A.2
282E:  BRA    2854
2830:  MOVFF  7B,7C
2834:  MOVLW  20
2836:  MOVWF  x7B
2838:  MOVLW  30
283A:  SUBWF  x7D,W
283C:  BZ    2846
283E:  BSF    x7A.0
2840:  BTFSC  x7A.7
2842:  BSF    x7A.1
2844:  BRA    2854
2846:  BTFSS  FD8.2
2848:  BSF    x7A.0
284A:  BNZ   2854
284C:  MOVFF  7C,7D
2850:  MOVLW  20
2852:  MOVWF  x7C
2854:  BTFSC  x7A.2
2856:  BRA    2862
2858:  BTFSC  x7A.1
285A:  BRA    286A
285C:  BTFSC  x7A.0
285E:  BRA    2872
2860:  BRA    287A
2862:  MOVF   x7B,W
2864:  BTFSS  F9E.4
2866:  BRA    2864
2868:  MOVWF  FAD
286A:  MOVF   x7C,W
286C:  BTFSS  F9E.4
286E:  BRA    286C
2870:  MOVWF  FAD
2872:  MOVF   x7D,W
2874:  BTFSS  F9E.4
2876:  BRA    2874
2878:  MOVWF  FAD
287A:  MOVF   x7E,W
287C:  BTFSS  F9E.4
287E:  BRA    287C
2880:  MOVWF  FAD
2882:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #fuses NOMCLR HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
*
1ACC:  CLRF   FEA
1ACE:  MOVLW  7B
1AD0:  MOVWF  FE9
1AD2:  MOVF   FEF,W
1AD4:  BZ    1AF0
1AD6:  MOVLW  02
1AD8:  MOVWF  01
1ADA:  CLRF   00
1ADC:  DECFSZ 00,F
1ADE:  BRA    1ADC
1AE0:  DECFSZ 01,F
1AE2:  BRA    1ADA
1AE4:  MOVLW  97
1AE6:  MOVWF  00
1AE8:  DECFSZ 00,F
1AEA:  BRA    1AE8
1AEC:  DECFSZ FEF,F
1AEE:  BRA    1AD6
1AF0:  RETURN 0
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 9600)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
*
0096:  BCF    FC6.7
0098:  BCF    F9E.3
009A:  MOVFF  B8,FC9
009E:  MOVLW  02
00A0:  BTFSC  FC6.7
00A2:  BRA    00AE
00A4:  BTFSS  F9E.3
00A6:  BRA    00A4
00A8:  MOVLW  00
00AA:  BTFSC  FC5.6
00AC:  MOVLW  01
00AE:  MOVWF  01
00B0:  RETURN 0
00B2:  BCF    FC6.6
00B4:  BSF    FC5.3
00B6:  BTFSC  FC5.3
00B8:  BRA    00B6
00BA:  BTFSC  00.0
00BC:  BCF    FC5.5
00BE:  BTFSS  00.0
00C0:  BSF    FC5.5
00C2:  BSF    FC5.4
00C4:  BTFSC  FC5.4
00C6:  BRA    00C4
00C8:  MOVFF  FC9,01
00CC:  RETURN 0
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
.................... #include "MPU9250/mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses NOMCLR HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 9600)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
.................... #include "mpu9250_config.h" 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_CONFIG_H 
.................... #define	MPU9250_CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses NOMCLR HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 9600)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_CONFIG_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // 2 g 
.................... #define AFS_4G          0x08 // 4 g 
.................... #define AFS_8G          0x10 // 8 g 
.................... #define AFS_16G         0x18 // 16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // 250 dps 
.................... #define GFS_500         0x08 // 500 dps 
.................... #define GFS_1000        0x10 // 1000 dps 
.................... #define GFS_2000        0x18 // 2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
.................... #include "mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... #include "mpu9250_config.h" 
.................... #include "mpu9250_private.h" 
.................... #include "mpu9250_interface.h" 
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]) ; 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]) ; 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // 2 g 
.................... #define AFS_4G          0x08 // 4 g 
.................... #define AFS_8G          0x10 // 8 g 
.................... #define AFS_16G         0x18 // 16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // 250 dps 
.................... #define GFS_500         0x08 // 500 dps 
.................... #define GFS_1000        0x10 // 1000 dps 
.................... #define GFS_2000        0x18 // 2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
....................  
....................  
.................... static void imu_update(void); 
.................... // Declare variables to store the sensor values 
.................... float gyro[3] = {0.0, 0.0, 0.0} ; 
.................... float mag[3] = {0.0, 0.0, 0.0}   ; 
.................... float accel[3] = {0.0, 0.0, 0.0}    ; 
....................  
.................... RateCalibration_t RateCalibration = {0.0, 0.0, 0.0} ; 
.................... Angle_t Angle = {0.0, 0.0, 0.0} ; 
....................  
.................... float KalmanAngleRoll=0 ; 
.................... int KalmanUncertaintyAngleRoll=2*2; 
.................... float KalmanAnglePitch=0  ; 
.................... int KalmanUncertaintyAnglePitch=2*2; 
.................... float Kalman1DOutput[]={0,0};       //angle predict, angle uncertainty predict 
....................  
.................... #INT_TIMER2 
.................... static void imu_update(void) 
.................... { 
....................        output_toggle(PIN_E2); 
*
1676:  BCF    F96.2
1678:  BTG    F8D.2
....................        mpu9250_read_gyro(gyro); 
167A:  CLRF   x9C
167C:  MOVLW  1D
167E:  MOVWF  x9B
1680:  CALL   0300
....................        mpu9250_calculate_angles(&Angle,accel); 
1684:  CLRF   x9C
1686:  MOVLW  4D
1688:  MOVWF  x9B
168A:  CLRF   x9E
168C:  MOVLW  35
168E:  MOVWF  x9D
1690:  BRA    0F90
....................  
....................        kalman_1d(KalmanAngleRoll,KalmanUncertaintyAngleRoll,gyro[0] - RateCalibration.roll,Angle.roll,Kalman1DOutput); 
1692:  CLRF   x9C
1694:  MOVFF  5D,9B
1698:  RCALL  13AC
169A:  MOVFF  03,9E
169E:  MOVFF  02,9D
16A2:  MOVFF  01,9C
16A6:  MOVFF  00,9B
16AA:  BSF    FD8.1
16AC:  MOVFF  20,C4
16B0:  MOVFF  1F,C3
16B4:  MOVFF  1E,C2
16B8:  MOVFF  1D,C1
16BC:  MOVFF  48,C8
16C0:  MOVFF  47,C7
16C4:  MOVFF  46,C6
16C8:  MOVFF  45,C5
16CC:  CALL   0416
16D0:  MOVFF  03,A2
16D4:  MOVFF  02,A1
16D8:  MOVFF  01,A0
16DC:  MOVFF  00,9F
16E0:  MOVFF  5C,A6
16E4:  MOVFF  5B,A5
16E8:  MOVFF  5A,A4
16EC:  MOVFF  59,A3
16F0:  MOVFF  9E,AA
16F4:  MOVFF  9D,A9
16F8:  MOVFF  9C,A8
16FC:  MOVFF  9B,A7
1700:  MOVFF  03,AE
1704:  MOVFF  02,AD
1708:  MOVFF  01,AC
170C:  MOVFF  00,AB
1710:  MOVFF  54,B2
1714:  MOVFF  53,B1
1718:  MOVFF  52,B0
171C:  MOVFF  51,AF
1720:  CLRF   xB4
1722:  MOVLW  63
1724:  MOVWF  xB3
1726:  RCALL  13E2
....................  
....................        KalmanAngleRoll=Kalman1DOutput[0]; 
1728:  MOVFF  66,5C
172C:  MOVFF  65,5B
1730:  MOVFF  64,5A
1734:  MOVFF  63,59
....................        KalmanUncertaintyAngleRoll=Kalman1DOutput[1] ; 
1738:  MOVFF  6A,9E
173C:  MOVFF  69,9D
1740:  MOVFF  68,9C
1744:  MOVFF  67,9B
1748:  RCALL  163E
174A:  MOVFF  01,5D
....................        kalman_1d(KalmanAnglePitch,KalmanUncertaintyAnglePitch,gyro[1] - RateCalibration.pitch ,Angle.pitch,Kalman1DOutput); 
174E:  CLRF   x9C
1750:  MOVFF  62,9B
1754:  RCALL  13AC
1756:  MOVFF  03,9E
175A:  MOVFF  02,9D
175E:  MOVFF  01,9C
1762:  MOVFF  00,9B
1766:  BSF    FD8.1
1768:  MOVFF  24,C4
176C:  MOVFF  23,C3
1770:  MOVFF  22,C2
1774:  MOVFF  21,C1
1778:  MOVFF  44,C8
177C:  MOVFF  43,C7
1780:  MOVFF  42,C6
1784:  MOVFF  41,C5
1788:  CALL   0416
178C:  MOVFF  03,A2
1790:  MOVFF  02,A1
1794:  MOVFF  01,A0
1798:  MOVFF  00,9F
179C:  MOVFF  61,A6
17A0:  MOVFF  60,A5
17A4:  MOVFF  5F,A4
17A8:  MOVFF  5E,A3
17AC:  MOVFF  9E,AA
17B0:  MOVFF  9D,A9
17B4:  MOVFF  9C,A8
17B8:  MOVFF  9B,A7
17BC:  MOVFF  03,AE
17C0:  MOVFF  02,AD
17C4:  MOVFF  01,AC
17C8:  MOVFF  00,AB
17CC:  MOVFF  50,B2
17D0:  MOVFF  4F,B1
17D4:  MOVFF  4E,B0
17D8:  MOVFF  4D,AF
17DC:  CLRF   xB4
17DE:  MOVLW  63
17E0:  MOVWF  xB3
17E2:  RCALL  13E2
....................  
....................        KalmanAnglePitch=Kalman1DOutput[0]; 
17E4:  MOVFF  66,61
17E8:  MOVFF  65,60
17EC:  MOVFF  64,5F
17F0:  MOVFF  63,5E
....................        KalmanUncertaintyAnglePitch=Kalman1DOutput[1]; 
17F4:  MOVFF  6A,9E
17F8:  MOVFF  69,9D
17FC:  MOVFF  68,9C
1800:  MOVFF  67,9B
1804:  RCALL  163E
1806:  MOVFF  01,62
....................         
....................        clear_interrupt(INT_TIMER2); 
180A:  BCF    F9E.1
180C:  BCF    F9E.1
180E:  GOTO   0054
.................... } 
....................  
....................  
....................  
.................... void main() { 
*
2884:  CLRF   FF8
2886:  BCF    FD0.7
2888:  BSF    07.7
288A:  BCF    FB8.3
288C:  MOVLW  0C
288E:  MOVWF  FAF
2890:  MOVLW  A2
2892:  MOVWF  FAC
2894:  MOVLW  90
2896:  MOVWF  FAB
2898:  BSF    F93.1
289A:  BSF    F93.0
289C:  MOVLW  04
289E:  MOVWF  FC8
28A0:  MOVLW  28
28A2:  MOVWF  FC6
28A4:  BCF    FC7.7
28A6:  BCF    FC7.6
28A8:  BSF    FC7.6
28AA:  CLRF   5C
28AC:  CLRF   5B
28AE:  CLRF   5A
28B0:  CLRF   59
28B2:  MOVLW  04
28B4:  MOVWF  5D
28B6:  CLRF   x61
28B8:  CLRF   x60
28BA:  CLRF   5F
28BC:  CLRF   5E
28BE:  MOVWF  x62
28C0:  BRA    28DA
28C2:  DATA 02,00
28C4:  DATA 17,00
28C6:  DATA 00,01
28C8:  DATA 0F,B4
28CA:  DATA 07,3C
28CC:  DATA 40,1D
28CE:  DATA 00,08
28D0:  DATA 40,63
28D2:  DATA 00,02
28D4:  DATA 00,17
28D6:  DATA 00,00
28D8:  DATA 00,00
28DA:  MOVLW  00
28DC:  MOVWF  FF8
28DE:  MOVLW  28
28E0:  MOVWF  FF7
28E2:  MOVLW  C2
28E4:  MOVWF  FF6
28E6:  TBLRD*+
28E8:  MOVF   FF5,W
28EA:  MOVWF  00
28EC:  XORLW  00
28EE:  BZ    2916
28F0:  TBLRD*+
28F2:  MOVF   FF5,W
28F4:  MOVWF  01
28F6:  BTFSC  FE8.7
28F8:  BRA    2904
28FA:  ANDLW  0F
28FC:  MOVWF  FEA
28FE:  TBLRD*+
2900:  MOVFF  FF5,FE9
2904:  BTFSC  01.6
2906:  TBLRD*+
2908:  BTFSS  01.6
290A:  TBLRD*+
290C:  MOVFF  FF5,FEE
2910:  DCFSNZ 00,F
2912:  BRA    28E6
2914:  BRA    2908
2916:  CLRF   FF8
....................      
....................      
....................     delay_ms(3000); 
2918:  MOVLW  0C
291A:  MOVWF  x77
291C:  MOVLW  FA
291E:  MOVWF  x7B
2920:  CALL   1ACC
2924:  DECFSZ x77,F
2926:  BRA    291C
....................     //set_tris_c(0x80);                               // RC7 is RX input    RC6 is TX output 
....................                         //Enable global interrupts 
....................     //set_uart_speed(9600)     ;                      //Init the uart 
....................     //delay_ms(4000); 
....................      
....................      
....................     output_float(PIN_B1);                           // SCL 
2928:  BSF    F93.1
....................     output_float(PIN_B0);                           // SDA 
292A:  BSF    F93.0
....................      
....................  
....................     printf(ANSI_COLOR_YELLOW"start of init  \n\r"ANSI_COLOR_RESET ); 
292C:  MOVLW  12
292E:  MOVWF  FF6
2930:  MOVLW  18
2932:  MOVWF  FF7
2934:  CALL   1AF2
....................  
....................     mpu9250_init();                                 // Init the MPU9250 
2938:  GOTO   1B62
....................  
....................     mpu9250_print_initRegisters() ;                  // Print the registers of the MPU9250 
293C:  GOTO   1CBE
....................     printf("Calibration of Gyro is started don't move the sensor\n\r"); 
2940:  MOVLW  2E
2942:  MOVWF  FF6
2944:  MOVLW  18
2946:  MOVWF  FF7
2948:  CALL   1AF2
....................     delay_ms(2000); 
294C:  MOVLW  08
294E:  MOVWF  x77
2950:  MOVLW  FA
2952:  MOVWF  x7B
2954:  CALL   1ACC
2958:  DECFSZ x77,F
295A:  BRA    2950
....................     mpu9250_gyro_calibration(&RateCalibration);     // Calibrate the gyro 
295C:  CLRF   x78
295E:  MOVLW  41
2960:  MOVWF  x77
2962:  GOTO   1E66
....................     printf("Calibration of Gyro is finished\n\r"); 
2966:  MOVLW  66
2968:  MOVWF  FF6
296A:  MOVLW  18
296C:  MOVWF  FF7
296E:  CALL   1AF2
....................     printf("RateCalibrationPitch = %.5f , RateCalibrationRoll = %.5f , RateCalibrationYaw = %.5f \n\r",RateCalibration.pitch,RateCalibration.roll,RateCalibration.yaw); 
2972:  MOVLW  88
2974:  MOVWF  FF6
2976:  MOVLW  18
2978:  MOVWF  FF7
297A:  MOVLW  17
297C:  MOVWF  x79
297E:  CALL   1C5C
2982:  MOVLW  89
2984:  MOVWF  FE9
2986:  MOVFF  44,7A
298A:  MOVFF  43,79
298E:  MOVFF  42,78
2992:  MOVFF  41,77
2996:  MOVLW  05
2998:  MOVWF  x7B
299A:  CALL   216E
299E:  MOVLW  A3
29A0:  MOVWF  FF6
29A2:  MOVLW  18
29A4:  MOVWF  FF7
29A6:  MOVLW  19
29A8:  MOVWF  x79
29AA:  CALL   1C5C
29AE:  MOVLW  89
29B0:  MOVWF  FE9
29B2:  MOVFF  48,7A
29B6:  MOVFF  47,79
29BA:  MOVFF  46,78
29BE:  MOVFF  45,77
29C2:  MOVLW  05
29C4:  MOVWF  x7B
29C6:  CALL   216E
29CA:  MOVLW  C0
29CC:  MOVWF  FF6
29CE:  MOVLW  18
29D0:  MOVWF  FF7
29D2:  MOVLW  18
29D4:  MOVWF  x79
29D6:  CALL   1C5C
29DA:  MOVLW  89
29DC:  MOVWF  FE9
29DE:  MOVFF  4C,7A
29E2:  MOVFF  4B,79
29E6:  MOVFF  4A,78
29EA:  MOVFF  49,77
29EE:  MOVLW  05
29F0:  MOVWF  x7B
29F2:  CALL   216E
29F6:  MOVLW  DC
29F8:  MOVWF  FF6
29FA:  MOVLW  18
29FC:  MOVWF  FF7
29FE:  MOVLW  03
2A00:  MOVWF  x79
2A02:  CALL   1C5C
....................  
....................  
....................    // Declare a variable to store the loop counter 
....................      
....................     enable_interrupts(GLOBAL); 
2A06:  MOVLW  C0
2A08:  IORWF  FF2,F
....................     setup_timer_2(T2_DIV_BY_1, 255, 1); 
2A0A:  MOVLW  00
2A0C:  IORLW  04
2A0E:  MOVWF  FCA
2A10:  MOVLW  FF
2A12:  MOVWF  FCB
....................     clear_interrupt(INT_TIMER2); 
2A14:  BCF    F9E.1
....................     enable_interrupts(INT_TIMER2); 
2A16:  BSF    F9D.1
....................     float mag[3] = {0,0,0}; 
2A18:  CLRF   x6B
2A1A:  CLRF   x6C
2A1C:  CLRF   x6D
2A1E:  CLRF   x6E
2A20:  CLRF   x6F
2A22:  CLRF   x70
2A24:  CLRF   x71
2A26:  CLRF   x72
2A28:  CLRF   x73
2A2A:  CLRF   x74
2A2C:  CLRF   x75
2A2E:  CLRF   x76
....................     // Loop forever 
....................      while (1) 
....................      { 
....................         mpu9250_read_magnometer(mag); 
2A30:  CLRF   x78
2A32:  MOVLW  6B
2A34:  MOVWF  x77
2A36:  BRA    2322
2A38:  CLRF   16
2A3A:  BTFSC  FF2.7
2A3C:  BSF    16.7
2A3E:  BCF    FF2.7
....................        //printf("magx = %f  magy = %f magz = %f  \n\r",  mag[0],mag[1],mag[2]); 
....................          
....................        printf("Roll = %d  Pitch = %d  \n\r",  (int)KalmanAngleRoll,(int) KalmanAnglePitch); 
2A40:  MOVFF  5C,9E
2A44:  MOVFF  5B,9D
2A48:  MOVFF  5A,9C
2A4C:  MOVFF  59,9B
2A50:  CALL   163E
2A54:  BTFSC  16.7
2A56:  BSF    FF2.7
2A58:  MOVFF  01,77
2A5C:  CLRF   16
2A5E:  BTFSC  FF2.7
2A60:  BSF    16.7
2A62:  BCF    FF2.7
2A64:  MOVFF  61,9E
2A68:  MOVFF  60,9D
2A6C:  MOVFF  5F,9C
2A70:  MOVFF  5E,9B
2A74:  CALL   163E
2A78:  BTFSC  16.7
2A7A:  BSF    FF2.7
2A7C:  MOVFF  01,78
2A80:  MOVLW  E0
2A82:  MOVWF  FF6
2A84:  MOVLW  18
2A86:  MOVWF  FF7
2A88:  MOVLW  07
2A8A:  MOVWF  x79
2A8C:  CALL   1C5C
2A90:  MOVFF  77,79
2A94:  MOVLW  18
2A96:  MOVWF  x7A
2A98:  RCALL  27D2
2A9A:  MOVLW  E9
2A9C:  MOVWF  FF6
2A9E:  MOVLW  18
2AA0:  MOVWF  FF7
2AA2:  MOVLW  0A
2AA4:  MOVWF  x79
2AA6:  CALL   1C5C
2AAA:  MOVFF  78,79
2AAE:  MOVLW  18
2AB0:  MOVWF  x7A
2AB2:  RCALL  27D2
2AB4:  MOVLW  F5
2AB6:  MOVWF  FF6
2AB8:  MOVLW  18
2ABA:  MOVWF  FF7
2ABC:  MOVLW  04
2ABE:  MOVWF  x79
2AC0:  CALL   1C5C
....................        printf("Rollacc = %d  Pitchacc = %d  \n\r",  (int)(gyro[0] - RateCalibration.roll), (int)(gyro[1] - RateCalibration.pitch)); 
2AC4:  BSF    FD8.1
2AC6:  CLRF   16
2AC8:  BTFSC  FF2.7
2ACA:  BSF    16.7
2ACC:  BCF    FF2.7
2ACE:  MOVFF  20,C4
2AD2:  MOVFF  1F,C3
2AD6:  MOVFF  1E,C2
2ADA:  MOVFF  1D,C1
2ADE:  MOVFF  48,C8
2AE2:  MOVFF  47,C7
2AE6:  MOVFF  46,C6
2AEA:  MOVFF  45,C5
2AEE:  CALL   0416
2AF2:  BTFSC  16.7
2AF4:  BSF    FF2.7
2AF6:  CLRF   16
2AF8:  BTFSC  FF2.7
2AFA:  BSF    16.7
2AFC:  BCF    FF2.7
2AFE:  MOVFF  03,9E
2B02:  MOVFF  02,9D
2B06:  MOVFF  01,9C
2B0A:  MOVFF  00,9B
2B0E:  CALL   163E
2B12:  BTFSC  16.7
2B14:  BSF    FF2.7
2B16:  MOVFF  01,77
2B1A:  BSF    FD8.1
2B1C:  CLRF   16
2B1E:  BTFSC  FF2.7
2B20:  BSF    16.7
2B22:  BCF    FF2.7
2B24:  MOVFF  24,C4
2B28:  MOVFF  23,C3
2B2C:  MOVFF  22,C2
2B30:  MOVFF  21,C1
2B34:  MOVFF  44,C8
2B38:  MOVFF  43,C7
2B3C:  MOVFF  42,C6
2B40:  MOVFF  41,C5
2B44:  CALL   0416
2B48:  BTFSC  16.7
2B4A:  BSF    FF2.7
2B4C:  CLRF   16
2B4E:  BTFSC  FF2.7
2B50:  BSF    16.7
2B52:  BCF    FF2.7
2B54:  MOVFF  03,9E
2B58:  MOVFF  02,9D
2B5C:  MOVFF  01,9C
2B60:  MOVFF  00,9B
2B64:  CALL   163E
2B68:  BTFSC  16.7
2B6A:  BSF    FF2.7
2B6C:  MOVFF  01,78
2B70:  MOVLW  FA
2B72:  MOVWF  FF6
2B74:  MOVLW  18
2B76:  MOVWF  FF7
2B78:  MOVLW  0A
2B7A:  MOVWF  x79
2B7C:  CALL   1C5C
2B80:  MOVFF  77,79
2B84:  MOVLW  18
2B86:  MOVWF  x7A
2B88:  RCALL  27D2
2B8A:  MOVLW  06
2B8C:  MOVWF  FF6
2B8E:  MOVLW  19
2B90:  MOVWF  FF7
2B92:  MOVLW  0D
2B94:  MOVWF  x79
2B96:  CALL   1C5C
2B9A:  MOVFF  78,79
2B9E:  MOVLW  18
2BA0:  MOVWF  x7A
2BA2:  RCALL  27D2
2BA4:  MOVLW  15
2BA6:  MOVWF  FF6
2BA8:  MOVLW  19
2BAA:  MOVWF  FF7
2BAC:  MOVLW  04
2BAE:  MOVWF  x79
2BB0:  CALL   1C5C
2BB4:  BRA    2A30
....................         
....................      } 
.................... } 
....................  
2BB6:  SLEEP 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #import(file="build/default/production/MPU9250/mpu9250_program.o") 
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
015E:  MOVLW  8E
0160:  MOVWF  00
0162:  MOVFF  AA,01
0166:  MOVFF  A9,02
016A:  CLRF   03
016C:  BTFSS  xAA.7
016E:  BRA    017A
0170:  COMF   01,F
0172:  COMF   02,F
0174:  INCF   02,F
0176:  BNZ   017A
0178:  INCF   01,F
017A:  MOVF   01,F
017C:  BNZ   0190
017E:  MOVFF  02,01
0182:  CLRF   02
0184:  MOVLW  08
0186:  SUBWF  00,F
0188:  MOVF   01,F
018A:  BNZ   0190
018C:  CLRF   00
018E:  BRA    01A4
0190:  BCF    FD8.0
0192:  BTFSC  01.7
0194:  BRA    019E
0196:  RLCF   02,F
0198:  RLCF   01,F
019A:  DECF   00,F
019C:  BRA    0190
019E:  BTFSC  xAA.7
01A0:  BRA    01A4
01A2:  BCF    01.7
01A4:  RETURN 0
*
0938:  MOVFF  BD,C4
093C:  MOVF   xC1,W
093E:  XORWF  xC4,F
0940:  BTFSS  xC4.7
0942:  BRA    094E
0944:  BCF    FD8.2
0946:  BCF    FD8.0
0948:  BTFSC  xBD.7
094A:  BSF    FD8.0
094C:  BRA    09AC
094E:  MOVFF  BD,C4
0952:  MOVFF  C0,C5
0956:  MOVF   xBC,W
0958:  SUBWF  xC5,F
095A:  BZ    0968
095C:  BTFSS  xC4.7
095E:  BRA    09AC
0960:  MOVF   FD8,W
0962:  XORLW  01
0964:  MOVWF  FD8
0966:  BRA    09AC
0968:  MOVFF  C1,C5
096C:  MOVF   xBD,W
096E:  SUBWF  xC5,F
0970:  BZ    097E
0972:  BTFSS  xC4.7
0974:  BRA    09AC
0976:  MOVF   FD8,W
0978:  XORLW  01
097A:  MOVWF  FD8
097C:  BRA    09AC
097E:  MOVFF  C2,C5
0982:  MOVF   xBE,W
0984:  SUBWF  xC5,F
0986:  BZ    0994
0988:  BTFSS  xC4.7
098A:  BRA    09AC
098C:  MOVF   FD8,W
098E:  XORLW  01
0990:  MOVWF  FD8
0992:  BRA    09AC
0994:  MOVFF  C3,C5
0998:  MOVF   xBF,W
099A:  SUBWF  xC5,F
099C:  BZ    09AA
099E:  BTFSS  xC4.7
09A0:  BRA    09AC
09A2:  MOVF   FD8,W
09A4:  XORLW  01
09A6:  MOVWF  FD8
09A8:  BRA    09AC
09AA:  BCF    FD8.0
09AC:  RETURN 0
*
191A:  DATA 4D,50
191C:  DATA 55,39
191E:  DATA 32,35
1920:  DATA 30,20
1922:  DATA 69,73
1924:  DATA 20,6F
1926:  DATA 6E,6C
1928:  DATA 69,6E
192A:  DATA 65,2E
192C:  DATA 2E,2E
192E:  DATA 0A,0D
1930:  DATA 00,00
1932:  DATA 4D,50
1934:  DATA 55,39
1936:  DATA 32,35
1938:  DATA 30,20
193A:  DATA 69,73
193C:  DATA 20,6E
193E:  DATA 6F,74
1940:  DATA 20,6F
1942:  DATA 6E,6C
1944:  DATA 69,6E
1946:  DATA 65,2E
1948:  DATA 2E,2E
194A:  DATA 0A,0D
194C:  DATA 00,00
194E:  DATA 41,4B
1950:  DATA 38,39
1952:  DATA 36,33
1954:  DATA 20,69
1956:  DATA 73,20
1958:  DATA 6F,6E
195A:  DATA 6C,69
195C:  DATA 6E,65
195E:  DATA 2E,2E
1960:  DATA 2E,0A
1962:  DATA 0D,00
1964:  DATA 41,4B
1966:  DATA 38,39
1968:  DATA 36,33
196A:  DATA 20,69
196C:  DATA 73,20
196E:  DATA 6E,6F
1970:  DATA 74,20
1972:  DATA 6F,6E
1974:  DATA 6C,69
1976:  DATA 6E,65
1978:  DATA 2E,2E
197A:  DATA 2E,0A
197C:  DATA 0D,00
197E:  DATA 30,78
1980:  DATA 30,33
1982:  DATA 2D,3E
1984:  DATA 3E,20
1986:  DATA 43,4F
1988:  DATA 4E,46
198A:  DATA 49,47
198C:  DATA 3A,20
198E:  DATA 25,78
1990:  DATA 0A,0D
1992:  DATA 00,00
1994:  DATA 30,78
1996:  DATA 30,31
1998:  DATA 2D,3E
199A:  DATA 3E,20
199C:  DATA 50,57
199E:  DATA 52,5F
19A0:  DATA 4D,47
19A2:  DATA 4D,54
19A4:  DATA 5F,31
19A6:  DATA 3A,20
19A8:  DATA 25,78
19AA:  DATA 0A,0D
19AC:  DATA 00,00
19AE:  DATA 30,78
19B0:  DATA 30,30
19B2:  DATA 2D,3E
19B4:  DATA 3E,20
19B6:  DATA 50,57
19B8:  DATA 52,5F
19BA:  DATA 4D,47
19BC:  DATA 4D,54
19BE:  DATA 5F,32
19C0:  DATA 3A,20
19C2:  DATA 25,78
19C4:  DATA 0A,0D
19C6:  DATA 00,00
19C8:  DATA 30,78
19CA:  DATA 30,32
19CC:  DATA 2D,3E
19CE:  DATA 3E,20
19D0:  DATA 49,4E
19D2:  DATA 54,5F
19D4:  DATA 50,49
19D6:  DATA 4E,5F
19D8:  DATA 43,46
19DA:  DATA 47,3A
19DC:  DATA 20,25
19DE:  DATA 78,0A
19E0:  DATA 0D,00
19E2:  DATA 30,78
19E4:  DATA 30,37
19E6:  DATA 31,2D
19E8:  DATA 3E,3E
19EA:  DATA 20,57
19EC:  DATA 48,4F
19EE:  DATA 5F,41
19F0:  DATA 4D,5F
19F2:  DATA 49,5F
19F4:  DATA 4D,50
19F6:  DATA 55,39
19F8:  DATA 32,35
19FA:  DATA 30,3A
19FC:  DATA 20,25
19FE:  DATA 78,0A
1A00:  DATA 0D,00
1A02:  DATA 30,34
1A04:  DATA 38,2D
1A06:  DATA 3E,3E
1A08:  DATA 20,20
1A0A:  DATA 57,48
1A0C:  DATA 4F,5F
1A0E:  DATA 41,4D
1A10:  DATA 5F,49
1A12:  DATA 5F,41
1A14:  DATA 4B,38
1A16:  DATA 39,36
1A18:  DATA 33,3A
1A1A:  DATA 20,25
1A1C:  DATA 78,0A
1A1E:  DATA 0D,00
1A20:  DATA 1B,5B
1A22:  DATA 33,33
1A24:  DATA 6D,47
1A26:  DATA 79,72
1A28:  DATA 6F,20
1A2A:  DATA 3A,20
1A2C:  DATA 58,20
1A2E:  DATA 3D,20
1A30:  DATA 25,2E
1A32:  DATA 35,66
1A34:  DATA 2C,20
1A36:  DATA 59,20
1A38:  DATA 3D,20
1A3A:  DATA 25,2E
1A3C:  DATA 35,66
1A3E:  DATA 2C,20
1A40:  DATA 5A,20
1A42:  DATA 3D,20
1A44:  DATA 25,2E
1A46:  DATA 35,66
1A48:  DATA 20,28
1A4A:  DATA 64,65
1A4C:  DATA 67,2F
1A4E:  DATA 73,29
1A50:  DATA 20,20
1A52:  DATA 20,09
1A54:  DATA 1B,5B
1A56:  DATA 30,6D
1A58:  DATA 00,00
1A5A:  DATA 1B,5B
1A5C:  DATA 33,33
1A5E:  DATA 6D,4D
1A60:  DATA 61,67
1A62:  DATA 20,20
1A64:  DATA 3A,20
1A66:  DATA 58,20
1A68:  DATA 3D,20
1A6A:  DATA 25,2E
1A6C:  DATA 35,66
1A6E:  DATA 2C,20
1A70:  DATA 59,20
1A72:  DATA 3D,20
1A74:  DATA 25,2E
1A76:  DATA 35,66
1A78:  DATA 2C,20
1A7A:  DATA 5A,20
1A7C:  DATA 3D,20
1A7E:  DATA 25,2E
1A80:  DATA 35,66
1A82:  DATA 20,28
1A84:  DATA 75,54
1A86:  DATA 29,20
1A88:  DATA 20,20
1A8A:  DATA 20,20
1A8C:  DATA 20,09
1A8E:  DATA 1B,5B
1A90:  DATA 30,6D
1A92:  DATA 00,00
1A94:  DATA 1B,5B
1A96:  DATA 33,33
1A98:  DATA 6D,41
1A9A:  DATA 63,63
1A9C:  DATA 65,6C
1A9E:  DATA 3A,20
1AA0:  DATA 58,20
1AA2:  DATA 3D,20
1AA4:  DATA 25,2E
1AA6:  DATA 35,66
1AA8:  DATA 2C,20
1AAA:  DATA 59,20
1AAC:  DATA 3D,20
1AAE:  DATA 25,2E
1AB0:  DATA 35,66
1AB2:  DATA 2C,20
1AB4:  DATA 5A,20
1AB6:  DATA 3D,20
1AB8:  DATA 25,2E
1ABA:  DATA 35,66
1ABC:  DATA 20,28
1ABE:  DATA 67,29
1AC0:  DATA 20,20
1AC2:  DATA 20,20
1AC4:  DATA 20,0A
1AC6:  DATA 0D,1B
1AC8:  DATA 5B,30
1ACA:  DATA 6D,00
*
1C7C:  BTFSC  x79.7
1C7E:  BRA    1CA0
1C80:  MOVLW  0F
1C82:  MOVWF  00
1C84:  SWAPF  x78,W
1C86:  ANDWF  00,F
1C88:  MOVLW  0A
1C8A:  SUBWF  00,W
1C8C:  BC    1C94
1C8E:  MOVLW  30
1C90:  ADDWF  00,F
1C92:  BRA    1C98
1C94:  MOVF   x79,W
1C96:  ADDWF  00,F
1C98:  MOVF   00,W
1C9A:  BTFSS  F9E.4
1C9C:  BRA    1C9A
1C9E:  MOVWF  FAD
1CA0:  MOVLW  0F
1CA2:  ANDWF  x78,F
1CA4:  MOVLW  0A
1CA6:  SUBWF  x78,W
1CA8:  BC    1CAE
1CAA:  MOVLW  30
1CAC:  BRA    1CB2
1CAE:  BCF    x79.7
1CB0:  MOVF   x79,W
1CB2:  ADDWF  x78,F
1CB4:  MOVF   x78,W
1CB6:  BTFSS  F9E.4
1CB8:  BRA    1CB6
1CBA:  MOVWF  FAD
1CBC:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #fuses NOMCLR HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 9600)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
.................... #include "mpu9250_config.h" 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_CONFIG_H 
.................... #define	MPU9250_CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses NOMCLR HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 9600)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_CONFIG_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // 2 g 
.................... #define AFS_4G          0x08 // 4 g 
.................... #define AFS_8G          0x10 // 8 g 
.................... #define AFS_16G         0x18 // 16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // 250 dps 
.................... #define GFS_500         0x08 // 500 dps 
.................... #define GFS_1000        0x10 // 1000 dps 
.................... #define GFS_2000        0x18 // 2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
.................... #include "mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses NOMCLR HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 9600)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
.................... #include "mpu9250_config.h" 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_CONFIG_H 
.................... #define	MPU9250_CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include "configure.h" 
....................  
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_CONFIG_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // 2 g 
.................... #define AFS_4G          0x08 // 4 g 
.................... #define AFS_8G          0x10 // 8 g 
.................... #define AFS_16G         0x18 // 16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // 250 dps 
.................... #define GFS_500         0x08 // 500 dps 
.................... #define GFS_1000        0x10 // 1000 dps 
.................... #define GFS_2000        0x18 // 2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
.................... #include "mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... #include "mpu9250_config.h" 
.................... #include "mpu9250_private.h" 
.................... #include "mpu9250_interface.h" 
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]) ; 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]) ; 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
.................... //#include "../MyMath.h" 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
09AE:  MOVFF  AE,BF
09B2:  MOVFF  AD,BE
09B6:  MOVFF  AC,BD
09BA:  MOVFF  AB,BC
09BE:  CLRF   xC3
09C0:  CLRF   xC2
09C2:  CLRF   xC1
09C4:  CLRF   xC0
09C6:  RCALL  0938
09C8:  BC    09CC
09CA:  BNZ   09D6
....................       return(0.0); 
09CC:  CLRF   00
09CE:  CLRF   01
09D0:  CLRF   02
09D2:  CLRF   03
09D4:  BRA    0AB8
....................  
....................    y=x; 
09D6:  MOVFF  AE,B2
09DA:  MOVFF  AD,B1
09DE:  MOVFF  AC,B0
09E2:  MOVFF  AB,AF
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
09E6:  CLRF   xB8
09E8:  MOVLW  AF
09EA:  MOVWF  xB7
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
09EC:  MOVFF  B7,FE9
09F0:  MOVFF  B8,FEA
09F4:  MOVF   FEF,W
09F6:  CLRF   xBC
09F8:  MOVWF  xBB
09FA:  MOVLW  7F
09FC:  ADDWF  xBB,F
09FE:  MOVLW  00
0A00:  ADDWFC xBC,F
0A02:  BCF    FD8.0
0A04:  RRCF   xBC,W
0A06:  RRCF   xBB,W
0A08:  MOVFF  B8,FEA
0A0C:  MOVFF  B7,FE9
0A10:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0A12:  MOVFF  B2,B6
0A16:  MOVFF  B1,B5
0A1A:  MOVFF  B0,B4
0A1E:  MOVFF  AF,B3
....................       y+=(x/y); 
0A22:  MOVFF  AE,C3
0A26:  MOVFF  AD,C2
0A2A:  MOVFF  AC,C1
0A2E:  MOVFF  AB,C0
0A32:  MOVFF  B2,C7
0A36:  MOVFF  B1,C6
0A3A:  MOVFF  B0,C5
0A3E:  MOVFF  AF,C4
0A42:  CALL   01A6
0A46:  BCF    FD8.1
0A48:  MOVFF  B2,C4
0A4C:  MOVFF  B1,C3
0A50:  MOVFF  B0,C2
0A54:  MOVFF  AF,C1
0A58:  MOVFF  03,C8
0A5C:  MOVFF  02,C7
0A60:  MOVFF  01,C6
0A64:  MOVFF  00,C5
0A68:  RCALL  0416
0A6A:  MOVFF  03,B2
0A6E:  MOVFF  02,B1
0A72:  MOVFF  01,B0
0A76:  MOVFF  00,AF
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
0A7A:  MOVFF  B7,FE9
0A7E:  MOVFF  B8,FEA
0A82:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
0A84:  MOVFF  B6,BF
0A88:  MOVFF  B5,BE
0A8C:  MOVFF  B4,BD
0A90:  MOVFF  B3,BC
0A94:  MOVFF  B2,C3
0A98:  MOVFF  B1,C2
0A9C:  MOVFF  B0,C1
0AA0:  MOVFF  AF,C0
0AA4:  RCALL  0938
0AA6:  BNZ   0A12
....................  
....................    return(res); 
0AA8:  MOVFF  B3,00
0AAC:  MOVFF  B4,01
0AB0:  MOVFF  B5,02
0AB4:  MOVFF  B6,03
0AB8:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
0ABA:  BCF    xBB.0
....................    flag = 0; 
0ABC:  BCF    xBB.1
....................    y = x; 
0ABE:  MOVFF  AE,B2
0AC2:  MOVFF  AD,B1
0AC6:  MOVFF  AC,B0
0ACA:  MOVFF  AB,AF
....................  
....................    if (x < 0) 
0ACE:  MOVFF  AE,BF
0AD2:  MOVFF  AD,BE
0AD6:  MOVFF  AC,BD
0ADA:  MOVFF  AB,BC
0ADE:  CLRF   xC3
0AE0:  CLRF   xC2
0AE2:  CLRF   xC1
0AE4:  CLRF   xC0
0AE6:  RCALL  0938
0AE8:  BNC   0AF2
....................    { 
....................       s = 1; 
0AEA:  BSF    xBB.0
....................       y = -y; 
0AEC:  MOVF   xB0,W
0AEE:  XORLW  80
0AF0:  MOVWF  xB0
....................    } 
....................  
....................    if (y > 1.0) 
0AF2:  CLRF   xBF
0AF4:  CLRF   xBE
0AF6:  CLRF   xBD
0AF8:  MOVLW  7F
0AFA:  MOVWF  xBC
0AFC:  MOVFF  B2,C3
0B00:  MOVFF  B1,C2
0B04:  MOVFF  B0,C1
0B08:  MOVFF  AF,C0
0B0C:  RCALL  0938
0B0E:  BNC   0B40
....................    { 
....................       y = 1.0/y; 
0B10:  CLRF   xC3
0B12:  CLRF   xC2
0B14:  CLRF   xC1
0B16:  MOVLW  7F
0B18:  MOVWF  xC0
0B1A:  MOVFF  B2,C7
0B1E:  MOVFF  B1,C6
0B22:  MOVFF  B0,C5
0B26:  MOVFF  AF,C4
0B2A:  CALL   01A6
0B2E:  MOVFF  03,B2
0B32:  MOVFF  02,B1
0B36:  MOVFF  01,B0
0B3A:  MOVFF  00,AF
....................       flag = 1; 
0B3E:  BSF    xBB.1
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
0B40:  MOVLW  0A
0B42:  MOVWF  xC3
0B44:  MOVLW  89
0B46:  MOVWF  xC2
0B48:  MOVLW  34
0B4A:  MOVWF  xC1
0B4C:  MOVLW  7C
0B4E:  MOVWF  xC0
0B50:  MOVFF  B2,C7
0B54:  MOVFF  B1,C6
0B58:  MOVFF  B0,C5
0B5C:  MOVFF  AF,C4
0B60:  RCALL  0846
0B62:  MOVFF  03,BF
0B66:  MOVFF  02,BE
0B6A:  MOVFF  01,BD
0B6E:  MOVFF  00,BC
0B72:  MOVFF  03,C3
0B76:  MOVFF  02,C2
0B7A:  MOVFF  01,C1
0B7E:  MOVFF  00,C0
0B82:  MOVFF  B2,C7
0B86:  MOVFF  B1,C6
0B8A:  MOVFF  B0,C5
0B8E:  MOVFF  AF,C4
0B92:  RCALL  0846
0B94:  MOVFF  03,BF
0B98:  MOVFF  02,BE
0B9C:  MOVFF  01,BD
0BA0:  MOVFF  00,BC
0BA4:  BCF    FD8.1
0BA6:  MOVFF  03,C4
0BAA:  MOVFF  02,C3
0BAE:  MOVFF  01,C2
0BB2:  MOVFF  00,C1
0BB6:  MOVLW  7C
0BB8:  MOVWF  xC8
0BBA:  MOVLW  79
0BBC:  MOVWF  xC7
0BBE:  MOVLW  35
0BC0:  MOVWF  xC6
0BC2:  MOVLW  81
0BC4:  MOVWF  xC5
0BC6:  RCALL  0416
0BC8:  MOVFF  03,B6
0BCC:  MOVFF  02,B5
0BD0:  MOVFF  01,B4
0BD4:  MOVFF  00,B3
....................    res = res*y*y + pat[2]; 
0BD8:  MOVFF  B6,C3
0BDC:  MOVFF  B5,C2
0BE0:  MOVFF  B4,C1
0BE4:  MOVFF  B3,C0
0BE8:  MOVFF  B2,C7
0BEC:  MOVFF  B1,C6
0BF0:  MOVFF  B0,C5
0BF4:  MOVFF  AF,C4
0BF8:  RCALL  0846
0BFA:  MOVFF  03,BF
0BFE:  MOVFF  02,BE
0C02:  MOVFF  01,BD
0C06:  MOVFF  00,BC
0C0A:  MOVFF  03,C3
0C0E:  MOVFF  02,C2
0C12:  MOVFF  01,C1
0C16:  MOVFF  00,C0
0C1A:  MOVFF  B2,C7
0C1E:  MOVFF  B1,C6
0C22:  MOVFF  B0,C5
0C26:  MOVFF  AF,C4
0C2A:  RCALL  0846
0C2C:  MOVFF  03,BF
0C30:  MOVFF  02,BE
0C34:  MOVFF  01,BD
0C38:  MOVFF  00,BC
0C3C:  BCF    FD8.1
0C3E:  MOVFF  03,C4
0C42:  MOVFF  02,C3
0C46:  MOVFF  01,C2
0C4A:  MOVFF  00,C1
0C4E:  MOVLW  3F
0C50:  MOVWF  xC8
0C52:  MOVLW  02
0C54:  MOVWF  xC7
0C56:  MOVLW  33
0C58:  MOVWF  xC6
0C5A:  MOVLW  83
0C5C:  MOVWF  xC5
0C5E:  CALL   0416
0C62:  MOVFF  03,B6
0C66:  MOVFF  02,B5
0C6A:  MOVFF  01,B4
0C6E:  MOVFF  00,B3
....................    res = res*y*y + pat[3]; 
0C72:  MOVFF  B6,C3
0C76:  MOVFF  B5,C2
0C7A:  MOVFF  B4,C1
0C7E:  MOVFF  B3,C0
0C82:  MOVFF  B2,C7
0C86:  MOVFF  B1,C6
0C8A:  MOVFF  B0,C5
0C8E:  MOVFF  AF,C4
0C92:  RCALL  0846
0C94:  MOVFF  03,BF
0C98:  MOVFF  02,BE
0C9C:  MOVFF  01,BD
0CA0:  MOVFF  00,BC
0CA4:  MOVFF  03,C3
0CA8:  MOVFF  02,C2
0CAC:  MOVFF  01,C1
0CB0:  MOVFF  00,C0
0CB4:  MOVFF  B2,C7
0CB8:  MOVFF  B1,C6
0CBC:  MOVFF  B0,C5
0CC0:  MOVFF  AF,C4
0CC4:  RCALL  0846
0CC6:  MOVFF  03,BF
0CCA:  MOVFF  02,BE
0CCE:  MOVFF  01,BD
0CD2:  MOVFF  00,BC
0CD6:  BCF    FD8.1
0CD8:  MOVFF  03,C4
0CDC:  MOVFF  02,C3
0CE0:  MOVFF  01,C2
0CE4:  MOVFF  00,C1
0CE8:  MOVLW  33
0CEA:  MOVWF  xC8
0CEC:  MOVLW  8C
0CEE:  MOVWF  xC7
0CF0:  MOVLW  1E
0CF2:  MOVWF  xC6
0CF4:  MOVLW  83
0CF6:  MOVWF  xC5
0CF8:  CALL   0416
0CFC:  MOVFF  03,B6
0D00:  MOVFF  02,B5
0D04:  MOVFF  01,B4
0D08:  MOVFF  00,B3
....................  
....................    r = qat[0]*y*y + qat[1]; 
0D0C:  CLRF   xC3
0D0E:  CLRF   xC2
0D10:  CLRF   xC1
0D12:  MOVLW  7F
0D14:  MOVWF  xC0
0D16:  MOVFF  B2,C7
0D1A:  MOVFF  B1,C6
0D1E:  MOVFF  B0,C5
0D22:  MOVFF  AF,C4
0D26:  RCALL  0846
0D28:  MOVFF  03,BF
0D2C:  MOVFF  02,BE
0D30:  MOVFF  01,BD
0D34:  MOVFF  00,BC
0D38:  MOVFF  03,C3
0D3C:  MOVFF  02,C2
0D40:  MOVFF  01,C1
0D44:  MOVFF  00,C0
0D48:  MOVFF  B2,C7
0D4C:  MOVFF  B1,C6
0D50:  MOVFF  B0,C5
0D54:  MOVFF  AF,C4
0D58:  RCALL  0846
0D5A:  MOVFF  03,BF
0D5E:  MOVFF  02,BE
0D62:  MOVFF  01,BD
0D66:  MOVFF  00,BC
0D6A:  BCF    FD8.1
0D6C:  MOVFF  03,C4
0D70:  MOVFF  02,C3
0D74:  MOVFF  01,C2
0D78:  MOVFF  00,C1
0D7C:  MOVLW  1B
0D7E:  MOVWF  xC8
0D80:  MOVLW  E4
0D82:  MOVWF  xC7
0D84:  MOVLW  35
0D86:  MOVWF  xC6
0D88:  MOVLW  82
0D8A:  MOVWF  xC5
0D8C:  CALL   0416
0D90:  MOVFF  03,BA
0D94:  MOVFF  02,B9
0D98:  MOVFF  01,B8
0D9C:  MOVFF  00,B7
....................    r = r*y*y + qat[2]; 
0DA0:  MOVFF  BA,C3
0DA4:  MOVFF  B9,C2
0DA8:  MOVFF  B8,C1
0DAC:  MOVFF  B7,C0
0DB0:  MOVFF  B2,C7
0DB4:  MOVFF  B1,C6
0DB8:  MOVFF  B0,C5
0DBC:  MOVFF  AF,C4
0DC0:  RCALL  0846
0DC2:  MOVFF  03,BF
0DC6:  MOVFF  02,BE
0DCA:  MOVFF  01,BD
0DCE:  MOVFF  00,BC
0DD2:  MOVFF  03,C3
0DD6:  MOVFF  02,C2
0DDA:  MOVFF  01,C1
0DDE:  MOVFF  00,C0
0DE2:  MOVFF  B2,C7
0DE6:  MOVFF  B1,C6
0DEA:  MOVFF  B0,C5
0DEE:  MOVFF  AF,C4
0DF2:  RCALL  0846
0DF4:  MOVFF  03,BF
0DF8:  MOVFF  02,BE
0DFC:  MOVFF  01,BD
0E00:  MOVFF  00,BC
0E04:  BCF    FD8.1
0E06:  MOVFF  03,C4
0E0A:  MOVFF  02,C3
0E0E:  MOVFF  01,C2
0E12:  MOVFF  00,C1
0E16:  MOVLW  A4
0E18:  MOVWF  xC8
0E1A:  MOVLW  DB
0E1C:  MOVWF  xC7
0E1E:  MOVLW  67
0E20:  MOVWF  xC6
0E22:  MOVLW  83
0E24:  MOVWF  xC5
0E26:  CALL   0416
0E2A:  MOVFF  03,BA
0E2E:  MOVFF  02,B9
0E32:  MOVFF  01,B8
0E36:  MOVFF  00,B7
....................    r = r*y*y + qat[3]; 
0E3A:  MOVFF  BA,C3
0E3E:  MOVFF  B9,C2
0E42:  MOVFF  B8,C1
0E46:  MOVFF  B7,C0
0E4A:  MOVFF  B2,C7
0E4E:  MOVFF  B1,C6
0E52:  MOVFF  B0,C5
0E56:  MOVFF  AF,C4
0E5A:  RCALL  0846
0E5C:  MOVFF  03,BF
0E60:  MOVFF  02,BE
0E64:  MOVFF  01,BD
0E68:  MOVFF  00,BC
0E6C:  MOVFF  03,C3
0E70:  MOVFF  02,C2
0E74:  MOVFF  01,C1
0E78:  MOVFF  00,C0
0E7C:  MOVFF  B2,C7
0E80:  MOVFF  B1,C6
0E84:  MOVFF  B0,C5
0E88:  MOVFF  AF,C4
0E8C:  RCALL  0846
0E8E:  MOVFF  03,BF
0E92:  MOVFF  02,BE
0E96:  MOVFF  01,BD
0E9A:  MOVFF  00,BC
0E9E:  BCF    FD8.1
0EA0:  MOVFF  03,C4
0EA4:  MOVFF  02,C3
0EA8:  MOVFF  01,C2
0EAC:  MOVFF  00,C1
0EB0:  MOVLW  33
0EB2:  MOVWF  xC8
0EB4:  MOVLW  8C
0EB6:  MOVWF  xC7
0EB8:  MOVLW  1E
0EBA:  MOVWF  xC6
0EBC:  MOVLW  83
0EBE:  MOVWF  xC5
0EC0:  CALL   0416
0EC4:  MOVFF  03,BA
0EC8:  MOVFF  02,B9
0ECC:  MOVFF  01,B8
0ED0:  MOVFF  00,B7
....................  
....................    res = y*res/r; 
0ED4:  MOVFF  B2,C3
0ED8:  MOVFF  B1,C2
0EDC:  MOVFF  B0,C1
0EE0:  MOVFF  AF,C0
0EE4:  MOVFF  B6,C7
0EE8:  MOVFF  B5,C6
0EEC:  MOVFF  B4,C5
0EF0:  MOVFF  B3,C4
0EF4:  RCALL  0846
0EF6:  MOVFF  03,BF
0EFA:  MOVFF  02,BE
0EFE:  MOVFF  01,BD
0F02:  MOVFF  00,BC
0F06:  MOVFF  03,C3
0F0A:  MOVFF  02,C2
0F0E:  MOVFF  01,C1
0F12:  MOVFF  00,C0
0F16:  MOVFF  BA,C7
0F1A:  MOVFF  B9,C6
0F1E:  MOVFF  B8,C5
0F22:  MOVFF  B7,C4
0F26:  CALL   01A6
0F2A:  MOVFF  03,B6
0F2E:  MOVFF  02,B5
0F32:  MOVFF  01,B4
0F36:  MOVFF  00,B3
....................  
....................  
....................    if (flag)                              // for |x| > 1 
0F3A:  BTFSS  xBB.1
0F3C:  BRA    0F74
....................       res = PI_DIV_BY_TWO - res; 
0F3E:  BSF    FD8.1
0F40:  MOVLW  DB
0F42:  MOVWF  xC4
0F44:  MOVLW  0F
0F46:  MOVWF  xC3
0F48:  MOVLW  49
0F4A:  MOVWF  xC2
0F4C:  MOVLW  7F
0F4E:  MOVWF  xC1
0F50:  MOVFF  B6,C8
0F54:  MOVFF  B5,C7
0F58:  MOVFF  B4,C6
0F5C:  MOVFF  B3,C5
0F60:  CALL   0416
0F64:  MOVFF  03,B6
0F68:  MOVFF  02,B5
0F6C:  MOVFF  01,B4
0F70:  MOVFF  00,B3
....................    if (s) 
0F74:  BTFSS  xBB.0
0F76:  BRA    0F7E
....................       res = -res; 
0F78:  MOVF   xB4,W
0F7A:  XORLW  80
0F7C:  MOVWF  xB4
....................  
....................    return(res); 
0F7E:  MOVFF  B3,00
0F82:  MOVFF  B4,01
0F86:  MOVFF  B5,02
0F8A:  MOVFF  B6,03
0F8E:  RETURN 0
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Function to write a byte to a specific register of a device 
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) { 
....................     i2c_start(); 
*
1B14:  BSF    FC5.0
1B16:  BTFSC  FC5.0
1B18:  BRA    1B16
....................     i2c_write(deviceAddress << 1); 
1B1A:  BCF    FD8.0
1B1C:  RLCF   x78,W
1B1E:  MOVWF  x7C
1B20:  CLRF   16
1B22:  BTFSC  FF2.7
1B24:  BSF    16.7
1B26:  BCF    FF2.7
1B28:  MOVWF  xB8
1B2A:  CALL   0096
1B2E:  BTFSC  16.7
1B30:  BSF    FF2.7
1B32:  CLRF   16
1B34:  BTFSC  FF2.7
1B36:  BSF    16.7
1B38:  BCF    FF2.7
....................     i2c_write(registerAddress); 
1B3A:  MOVFF  79,B8
1B3E:  CALL   0096
1B42:  BTFSC  16.7
1B44:  BSF    FF2.7
1B46:  CLRF   16
1B48:  BTFSC  FF2.7
1B4A:  BSF    16.7
1B4C:  BCF    FF2.7
....................     i2c_write(data); 
1B4E:  MOVFF  7A,B8
1B52:  CALL   0096
1B56:  BTFSC  16.7
1B58:  BSF    FF2.7
....................     i2c_stop(); 
1B5A:  BSF    FC5.2
1B5C:  BTFSC  FC5.2
1B5E:  BRA    1B5C
1B60:  RETURN 0
.................... } 
....................  
.................... // Function to read a byte from a specific register of a device 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) { 
....................     i2c_start(); 
*
00CE:  BSF    FC5.0
00D0:  BTFSC  FC5.0
00D2:  BRA    00D0
....................     i2c_write(deviceAddress << 1); 
00D4:  BCF    FD8.0
00D6:  RLCF   xB2,W
00D8:  MOVWF  xB7
00DA:  MOVWF  xB8
00DC:  RCALL  0096
....................     i2c_write(registerAddress); 
00DE:  MOVFF  B3,B8
00E2:  RCALL  0096
....................     i2c_start(); 
00E4:  BSF    FC5.1
00E6:  BTFSC  FC5.1
00E8:  BRA    00E6
....................     i2c_write(deviceAddress << 1 | 0x01); 
00EA:  BCF    FD8.0
00EC:  RLCF   xB2,W
00EE:  IORLW  01
00F0:  MOVWF  xB7
00F2:  MOVWF  xB8
00F4:  RCALL  0096
....................     *data = i2c_read(0); 
00F6:  MOVFF  B5,03
00FA:  MOVFF  B4,FE9
00FE:  MOVFF  B5,FEA
0102:  CLRF   00
0104:  RCALL  00B2
0106:  MOVFF  01,FEF
....................     i2c_stop(); 
010A:  BSF    FC5.2
010C:  BTFSC  FC5.2
010E:  BRA    010C
0110:  RETURN 0
.................... } 
....................  
.................... // Function to read a 16-bit value from two consecutive registers of a device 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
....................     uint8_t highByte, lowByte; 
....................     mpu9250_readByte(deviceAddress, registerLow, &lowByte); 
0112:  MOVFF  AB,B2
0116:  MOVFF  AD,B3
011A:  CLRF   xB5
011C:  MOVLW  B1
011E:  MOVWF  xB4
0120:  RCALL  00CE
....................     mpu9250_readByte(deviceAddress, registerHigh, &highByte); 
0122:  MOVFF  AB,B2
0126:  MOVFF  AC,B3
012A:  CLRF   xB5
012C:  MOVLW  B0
012E:  MOVWF  xB4
0130:  RCALL  00CE
....................  
....................         *data = make16(highByte,lowByte); 
0132:  MOVFF  AE,FE9
0136:  MOVFF  AF,FEA
013A:  MOVFF  B0,FEC
013E:  MOVF   FED,F
0140:  MOVFF  B1,FEF
0144:  RETURN 0
....................  
.................... } 
....................  
.................... // Function to read a 16-bit value from two consecutive gyro registers 
.................... void read_gyro_word(uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
....................     read_word(MPU9250_ADDRESS, registerHigh, registerLow, data); 
0146:  MOVLW  68
0148:  MOVWF  xAB
014A:  MOVFF  A3,AC
014E:  MOVFF  A4,AD
0152:  MOVFF  A6,AF
0156:  MOVFF  A5,AE
015A:  RCALL  0112
015C:  RETURN 0
.................... } 
.................... // Function to read a 16-bit value from two consecutive accelerometer registers 
.................... void read_accel_word(uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
....................     read_word(MPU9250_ADDRESS, registerHigh, registerLow, data); 
*
03FE:  MOVLW  68
0400:  MOVWF  xAB
0402:  MOVFF  A7,AC
0406:  MOVFF  A8,AD
040A:  MOVFF  AA,AF
040E:  MOVFF  A9,AE
0412:  RCALL  0112
0414:  RETURN 0
.................... } 
.................... // Function to read a 16-bit value from two consecutive magnetometer registers 
.................... void read_mag_word(uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
*
22FC:  CLRF   16
22FE:  BTFSC  FF2.7
2300:  BSF    16.7
2302:  BCF    FF2.7
....................     read_word(AK8963_ADDRESS, registerHigh, registerLow, data); 
2304:  MOVLW  0C
2306:  MOVWF  xAB
2308:  MOVFF  83,AC
230C:  MOVFF  84,AD
2310:  MOVFF  86,AF
2314:  MOVFF  85,AE
2318:  CALL   0112
231C:  BTFSC  16.7
231E:  BSF    FF2.7
2320:  RETURN 0
.................... } 
....................  
.................... // Function to initialize MPU9250 
.................... void mpu9250_init() { 
....................  
....................     mpu9250_writeByte(MPU9250_ADDRESS, CONFIG, CONFIG_VALUE);                    // Set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
*
1B62:  MOVLW  68
1B64:  MOVWF  x78
1B66:  MOVLW  1A
1B68:  MOVWF  x79
1B6A:  MOVLW  03
1B6C:  MOVWF  x7A
1B6E:  RCALL  1B14
....................     mpu9250_writeByte(MPU9250_ADDRESS, PWR_MGMT_1, PWR_MGMT_1_VALUE);            // Set the clock source to PLL with X axis gyroscope reference and disable sleep mode 
1B70:  MOVLW  68
1B72:  MOVWF  x78
1B74:  MOVLW  6B
1B76:  MOVWF  x79
1B78:  MOVLW  01
1B7A:  MOVWF  x7A
1B7C:  RCALL  1B14
....................     mpu9250_writeByte(MPU9250_ADDRESS, PWR_MGMT_2, PWR_MGMT_2_VALUE);            // Enable all sensors and disable standby mode for accel and gyro only 
1B7E:  MOVLW  68
1B80:  MOVWF  x78
1B82:  MOVLW  6C
1B84:  MOVWF  x79
1B86:  CLRF   x7A
1B88:  RCALL  1B14
....................     mpu9250_writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, AFS_8G);                    // Set the accelerometer range to 8 g 
1B8A:  MOVLW  68
1B8C:  MOVWF  x78
1B8E:  MOVLW  1C
1B90:  MOVWF  x79
1B92:  MOVLW  10
1B94:  MOVWF  x7A
1B96:  RCALL  1B14
....................     mpu9250_writeByte(MPU9250_ADDRESS, GYRO_CONFIG, GFS_500);                    // Set the gyro range to 500 dps 
1B98:  MOVLW  68
1B9A:  MOVWF  x78
1B9C:  MOVLW  1B
1B9E:  MOVWF  x79
1BA0:  MOVLW  08
1BA2:  MOVWF  x7A
1BA4:  RCALL  1B14
....................  
....................  
....................     mpu9250_writeByte(MPU9250_ADDRESS, INT_PIN_CFG, INT_PIN_CFG_VALUE1);         // Enable the I2C bypass mode of the MPU-9250 
1BA6:  MOVLW  68
1BA8:  MOVWF  x78
1BAA:  MOVLW  37
1BAC:  MOVWF  x79
1BAE:  MOVLW  02
1BB0:  MOVWF  x7A
1BB2:  RCALL  1B14
....................     mpu9250_writeByte(MPU9250_ADDRESS,MPU9250_I2C_MST_CTRL, I2C_MST_CLK_400kHz); // Set bits 3:0 to 1101 for 400kHz I2C master clock speed 
1BB4:  MOVLW  68
1BB6:  MOVWF  x78
1BB8:  MOVLW  24
1BBA:  MOVWF  x79
1BBC:  MOVLW  0D
1BBE:  MOVWF  x7A
1BC0:  RCALL  1B14
....................  
....................     mpu9250_writeByte(AK8963_ADDRESS, AK8963_CNTL2_Reg , 0x01);                  // Reset the AK8963 magnetometer 
1BC2:  MOVLW  0C
1BC4:  MOVWF  x78
1BC6:  MOVLW  0B
1BC8:  MOVWF  x79
1BCA:  MOVLW  01
1BCC:  MOVWF  x7A
1BCE:  RCALL  1B14
....................     mpu9250_writeByte(AK8963_ADDRESS, AK8963_CNTL1_Reg, 0x12);                   // Set the magnetometer to 16 bit resolution, 100 Hz update rate 
1BD0:  MOVLW  0C
1BD2:  MOVWF  x78
1BD4:  MOVLW  0A
1BD6:  MOVWF  x79
1BD8:  MOVLW  12
1BDA:  MOVWF  x7A
1BDC:  RCALL  1B14
....................  
....................     delay_ms(100); 
1BDE:  MOVLW  64
1BE0:  MOVWF  x7B
1BE2:  RCALL  1ACC
....................  
....................     uint8_t status = 0; 
1BE4:  CLRF   x77
1BE6:  CLRF   16
1BE8:  BTFSC  FF2.7
1BEA:  BSF    16.7
1BEC:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, WHO_AM_I_MPU9250, &status); 
1BEE:  MOVLW  68
1BF0:  MOVWF  xB2
1BF2:  MOVLW  75
1BF4:  MOVWF  xB3
1BF6:  CLRF   xB5
1BF8:  MOVLW  77
1BFA:  MOVWF  xB4
1BFC:  CALL   00CE
1C00:  BTFSC  16.7
1C02:  BSF    FF2.7
....................     if (status == MPU9250_ADDRESS_ID) { 
1C04:  MOVF   x77,W
1C06:  SUBLW  71
1C08:  BNZ   1C16
....................         printf( "MPU9250 is online...\n\r" ); 
1C0A:  MOVLW  1A
1C0C:  MOVWF  FF6
1C0E:  MOVLW  19
1C10:  MOVWF  FF7
1C12:  RCALL  1AF2
....................     } else { 
1C14:  BRA    1C20
....................         printf( "MPU9250 is not online...\n\r" ); 
1C16:  MOVLW  32
1C18:  MOVWF  FF6
1C1A:  MOVLW  19
1C1C:  MOVWF  FF7
1C1E:  RCALL  1AF2
1C20:  CLRF   16
1C22:  BTFSC  FF2.7
1C24:  BSF    16.7
1C26:  BCF    FF2.7
....................     } 
....................     mpu9250_readByte(AK8963_ADDRESS, WHO_AM_I_AK8963, &status); 
1C28:  MOVLW  0C
1C2A:  MOVWF  xB2
1C2C:  CLRF   xB3
1C2E:  CLRF   xB5
1C30:  MOVLW  77
1C32:  MOVWF  xB4
1C34:  CALL   00CE
1C38:  BTFSC  16.7
1C3A:  BSF    FF2.7
....................     if (status == AK8963_ADDRESS_ID) { 
1C3C:  MOVF   x77,W
1C3E:  SUBLW  48
1C40:  BNZ   1C4E
....................         printf( "AK8963 is online...\n\r" ); 
1C42:  MOVLW  4E
1C44:  MOVWF  FF6
1C46:  MOVLW  19
1C48:  MOVWF  FF7
1C4A:  RCALL  1AF2
....................     } else { 
1C4C:  BRA    1C58
....................         printf( "AK8963 is not online...\n\r" ); 
1C4E:  MOVLW  64
1C50:  MOVWF  FF6
1C52:  MOVLW  19
1C54:  MOVWF  FF7
1C56:  RCALL  1AF2
....................     } 
1C58:  GOTO   293C (RETURN)
....................  
.................... } 
....................  
.................... // Function to read and print the initial register values of the MPU9250 
.................... void mpu9250_print_initRegisters(void) { 
*
1CBE:  CLRF   x77
1CC0:  CLRF   16
1CC2:  BTFSC  FF2.7
1CC4:  BSF    16.7
1CC6:  BCF    FF2.7
....................     uint8_t data = 0; 
....................     mpu9250_readByte(MPU9250_ADDRESS, CONFIG, &data); 
1CC8:  MOVLW  68
1CCA:  MOVWF  xB2
1CCC:  MOVLW  1A
1CCE:  MOVWF  xB3
1CD0:  CLRF   xB5
1CD2:  MOVLW  77
1CD4:  MOVWF  xB4
1CD6:  CALL   00CE
1CDA:  BTFSC  16.7
1CDC:  BSF    FF2.7
....................     printf("0x03->> CONFIG: %x\n\r", data); 
1CDE:  MOVLW  7E
1CE0:  MOVWF  FF6
1CE2:  MOVLW  19
1CE4:  MOVWF  FF7
1CE6:  MOVLW  10
1CE8:  MOVWF  x79
1CEA:  RCALL  1C5C
1CEC:  MOVFF  77,78
1CF0:  MOVLW  57
1CF2:  MOVWF  x79
1CF4:  RCALL  1C7C
1CF6:  MOVLW  0A
1CF8:  BTFSS  F9E.4
1CFA:  BRA    1CF8
1CFC:  MOVWF  FAD
1CFE:  MOVLW  0D
1D00:  BTFSS  F9E.4
1D02:  BRA    1D00
1D04:  MOVWF  FAD
1D06:  CLRF   16
1D08:  BTFSC  FF2.7
1D0A:  BSF    16.7
1D0C:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, PWR_MGMT_1, &data); 
1D0E:  MOVLW  68
1D10:  MOVWF  xB2
1D12:  MOVLW  6B
1D14:  MOVWF  xB3
1D16:  CLRF   xB5
1D18:  MOVLW  77
1D1A:  MOVWF  xB4
1D1C:  CALL   00CE
1D20:  BTFSC  16.7
1D22:  BSF    FF2.7
....................     printf("0x01->> PWR_MGMT_1: %x\n\r", data); 
1D24:  MOVLW  94
1D26:  MOVWF  FF6
1D28:  MOVLW  19
1D2A:  MOVWF  FF7
1D2C:  MOVLW  14
1D2E:  MOVWF  x79
1D30:  RCALL  1C5C
1D32:  MOVFF  77,78
1D36:  MOVLW  57
1D38:  MOVWF  x79
1D3A:  RCALL  1C7C
1D3C:  MOVLW  0A
1D3E:  BTFSS  F9E.4
1D40:  BRA    1D3E
1D42:  MOVWF  FAD
1D44:  MOVLW  0D
1D46:  BTFSS  F9E.4
1D48:  BRA    1D46
1D4A:  MOVWF  FAD
1D4C:  CLRF   16
1D4E:  BTFSC  FF2.7
1D50:  BSF    16.7
1D52:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, PWR_MGMT_2, &data); 
1D54:  MOVLW  68
1D56:  MOVWF  xB2
1D58:  MOVLW  6C
1D5A:  MOVWF  xB3
1D5C:  CLRF   xB5
1D5E:  MOVLW  77
1D60:  MOVWF  xB4
1D62:  CALL   00CE
1D66:  BTFSC  16.7
1D68:  BSF    FF2.7
....................     printf("0x00->> PWR_MGMT_2: %x\n\r", data); 
1D6A:  MOVLW  AE
1D6C:  MOVWF  FF6
1D6E:  MOVLW  19
1D70:  MOVWF  FF7
1D72:  MOVLW  14
1D74:  MOVWF  x79
1D76:  RCALL  1C5C
1D78:  MOVFF  77,78
1D7C:  MOVLW  57
1D7E:  MOVWF  x79
1D80:  RCALL  1C7C
1D82:  MOVLW  0A
1D84:  BTFSS  F9E.4
1D86:  BRA    1D84
1D88:  MOVWF  FAD
1D8A:  MOVLW  0D
1D8C:  BTFSS  F9E.4
1D8E:  BRA    1D8C
1D90:  MOVWF  FAD
1D92:  CLRF   16
1D94:  BTFSC  FF2.7
1D96:  BSF    16.7
1D98:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, INT_PIN_CFG, &data); 
1D9A:  MOVLW  68
1D9C:  MOVWF  xB2
1D9E:  MOVLW  37
1DA0:  MOVWF  xB3
1DA2:  CLRF   xB5
1DA4:  MOVLW  77
1DA6:  MOVWF  xB4
1DA8:  CALL   00CE
1DAC:  BTFSC  16.7
1DAE:  BSF    FF2.7
....................     printf("0x02->> INT_PIN_CFG: %x\n\r", data); 
1DB0:  MOVLW  C8
1DB2:  MOVWF  FF6
1DB4:  MOVLW  19
1DB6:  MOVWF  FF7
1DB8:  MOVLW  15
1DBA:  MOVWF  x79
1DBC:  RCALL  1C5C
1DBE:  MOVFF  77,78
1DC2:  MOVLW  57
1DC4:  MOVWF  x79
1DC6:  RCALL  1C7C
1DC8:  MOVLW  0A
1DCA:  BTFSS  F9E.4
1DCC:  BRA    1DCA
1DCE:  MOVWF  FAD
1DD0:  MOVLW  0D
1DD2:  BTFSS  F9E.4
1DD4:  BRA    1DD2
1DD6:  MOVWF  FAD
1DD8:  CLRF   16
1DDA:  BTFSC  FF2.7
1DDC:  BSF    16.7
1DDE:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, WHO_AM_I_MPU9250, &data); 
1DE0:  MOVLW  68
1DE2:  MOVWF  xB2
1DE4:  MOVLW  75
1DE6:  MOVWF  xB3
1DE8:  CLRF   xB5
1DEA:  MOVLW  77
1DEC:  MOVWF  xB4
1DEE:  CALL   00CE
1DF2:  BTFSC  16.7
1DF4:  BSF    FF2.7
....................     printf("0x071->> WHO_AM_I_MPU9250: %x\n\r", data); 
1DF6:  MOVLW  E2
1DF8:  MOVWF  FF6
1DFA:  MOVLW  19
1DFC:  MOVWF  FF7
1DFE:  MOVLW  1B
1E00:  MOVWF  x79
1E02:  RCALL  1C5C
1E04:  MOVFF  77,78
1E08:  MOVLW  57
1E0A:  MOVWF  x79
1E0C:  RCALL  1C7C
1E0E:  MOVLW  0A
1E10:  BTFSS  F9E.4
1E12:  BRA    1E10
1E14:  MOVWF  FAD
1E16:  MOVLW  0D
1E18:  BTFSS  F9E.4
1E1A:  BRA    1E18
1E1C:  MOVWF  FAD
1E1E:  CLRF   16
1E20:  BTFSC  FF2.7
1E22:  BSF    16.7
1E24:  BCF    FF2.7
....................     mpu9250_readByte(AK8963_ADDRESS, WHO_AM_I_AK8963, &data); 
1E26:  MOVLW  0C
1E28:  MOVWF  xB2
1E2A:  CLRF   xB3
1E2C:  CLRF   xB5
1E2E:  MOVLW  77
1E30:  MOVWF  xB4
1E32:  CALL   00CE
1E36:  BTFSC  16.7
1E38:  BSF    FF2.7
....................     printf("048->>  WHO_AM_I_AK8963: %x\n\r", data); 
1E3A:  MOVLW  02
1E3C:  MOVWF  FF6
1E3E:  MOVLW  1A
1E40:  MOVWF  FF7
1E42:  MOVLW  19
1E44:  MOVWF  x79
1E46:  RCALL  1C5C
1E48:  MOVFF  77,78
1E4C:  MOVLW  57
1E4E:  MOVWF  x79
1E50:  RCALL  1C7C
1E52:  MOVLW  0A
1E54:  BTFSS  F9E.4
1E56:  BRA    1E54
1E58:  MOVWF  FAD
1E5A:  MOVLW  0D
1E5C:  BTFSS  F9E.4
1E5E:  BRA    1E5C
1E60:  MOVWF  FAD
1E62:  GOTO   2940 (RETURN)
.................... } 
....................  
.................... // Function to read gyro data and convert it to degrees per second 
.................... void mpu9250_read_gyro(float gyroData[]) { 
*
0300:  CLRF   xA2
0302:  CLRF   xA1
....................     int16_t gyroX, gyroY, gyroZ = 0; 
....................     read_gyro_word(GYRO_XOUT_H, GYRO_XOUT_L, &gyroX); 
0304:  MOVLW  43
0306:  MOVWF  xA3
0308:  MOVLW  44
030A:  MOVWF  xA4
030C:  CLRF   xA6
030E:  MOVLW  9D
0310:  MOVWF  xA5
0312:  RCALL  0146
....................     read_gyro_word(GYRO_YOUT_H, GYRO_YOUT_L, &gyroY); 
0314:  MOVLW  45
0316:  MOVWF  xA3
0318:  MOVLW  46
031A:  MOVWF  xA4
031C:  CLRF   xA6
031E:  MOVLW  9F
0320:  MOVWF  xA5
0322:  RCALL  0146
....................     read_gyro_word(GYRO_ZOUT_H, GYRO_ZOUT_L, &gyroZ); 
0324:  MOVLW  47
0326:  MOVWF  xA3
0328:  MOVLW  48
032A:  MOVWF  xA4
032C:  CLRF   xA6
032E:  MOVLW  A1
0330:  MOVWF  xA5
0332:  RCALL  0146
....................     gyroData[0] = gyroX / GYRO_SCALE; 
0334:  MOVFF  9B,FE9
0338:  MOVFF  9C,FEA
033C:  MOVFF  9E,AA
0340:  MOVFF  9D,A9
0344:  RCALL  015E
0346:  MOVFF  03,C3
034A:  MOVFF  02,C2
034E:  MOVFF  01,C1
0352:  MOVFF  00,C0
0356:  CLRF   xC7
0358:  CLRF   xC6
035A:  MOVLW  03
035C:  MOVWF  xC5
035E:  MOVLW  85
0360:  MOVWF  xC4
0362:  RCALL  01A6
0364:  MOVFF  00,FEF
0368:  MOVFF  01,FEC
036C:  MOVFF  02,FEC
0370:  MOVFF  03,FEC
....................     gyroData[1] = gyroY / GYRO_SCALE; 
0374:  MOVLW  04
0376:  ADDWF  x9B,W
0378:  MOVWF  FE9
037A:  MOVLW  00
037C:  ADDWFC x9C,W
037E:  MOVWF  FEA
0380:  MOVFF  A0,AA
0384:  MOVFF  9F,A9
0388:  RCALL  015E
038A:  MOVFF  03,C3
038E:  MOVFF  02,C2
0392:  MOVFF  01,C1
0396:  MOVFF  00,C0
039A:  CLRF   xC7
039C:  CLRF   xC6
039E:  MOVLW  03
03A0:  MOVWF  xC5
03A2:  MOVLW  85
03A4:  MOVWF  xC4
03A6:  RCALL  01A6
03A8:  MOVFF  00,FEF
03AC:  MOVFF  01,FEC
03B0:  MOVFF  02,FEC
03B4:  MOVFF  03,FEC
....................     gyroData[2] = gyroZ / GYRO_SCALE; 
03B8:  MOVLW  08
03BA:  ADDWF  x9B,W
03BC:  MOVWF  FE9
03BE:  MOVLW  00
03C0:  ADDWFC x9C,W
03C2:  MOVWF  FEA
03C4:  MOVFF  A2,AA
03C8:  MOVFF  A1,A9
03CC:  RCALL  015E
03CE:  MOVFF  03,C3
03D2:  MOVFF  02,C2
03D6:  MOVFF  01,C1
03DA:  MOVFF  00,C0
03DE:  CLRF   xC7
03E0:  CLRF   xC6
03E2:  MOVLW  03
03E4:  MOVWF  xC5
03E6:  MOVLW  85
03E8:  MOVWF  xC4
03EA:  RCALL  01A6
03EC:  MOVFF  00,FEF
03F0:  MOVFF  01,FEC
03F4:  MOVFF  02,FEC
03F8:  MOVFF  03,FEC
03FC:  RETURN 0
.................... } 
....................  
.................... // Function to read accelerometer data and convert it to g 
.................... void mpu9250_read_accelerometer(float accelData[] ) { 
*
0680:  CLRF   xA6
0682:  CLRF   xA5
....................     int16_t accelX, accelY, accelZ = 0; 
....................     read_accel_word(ACCEL_XOUT_H, ACCEL_XOUT_L, &accelX); 
0684:  MOVLW  3B
0686:  MOVWF  xA7
0688:  MOVLW  3C
068A:  MOVWF  xA8
068C:  CLRF   xAA
068E:  MOVLW  A1
0690:  MOVWF  xA9
0692:  RCALL  03FE
....................     read_accel_word(ACCEL_YOUT_H, ACCEL_YOUT_L, &accelY); 
0694:  MOVLW  3D
0696:  MOVWF  xA7
0698:  MOVLW  3E
069A:  MOVWF  xA8
069C:  CLRF   xAA
069E:  MOVLW  A3
06A0:  MOVWF  xA9
06A2:  RCALL  03FE
....................     read_accel_word(ACCEL_ZOUT_H, ACCEL_ZOUT_L, &accelZ); 
06A4:  MOVLW  3F
06A6:  MOVWF  xA7
06A8:  MOVLW  40
06AA:  MOVWF  xA8
06AC:  CLRF   xAA
06AE:  MOVLW  A5
06B0:  MOVWF  xA9
06B2:  RCALL  03FE
....................     accelData[0] = (accelX / ACCEL_SCALE) +ACCEL_X_OFFSET; 
06B4:  MOVFF  9F,FE9
06B8:  MOVFF  A0,FEA
06BC:  MOVFF  A2,AA
06C0:  MOVFF  A1,A9
06C4:  RCALL  015E
06C6:  MOVFF  03,C3
06CA:  MOVFF  02,C2
06CE:  MOVFF  01,C1
06D2:  MOVFF  00,C0
06D6:  CLRF   xC7
06D8:  CLRF   xC6
06DA:  CLRF   xC5
06DC:  MOVLW  8B
06DE:  MOVWF  xC4
06E0:  RCALL  01A6
06E2:  MOVFF  03,AC
06E6:  MOVFF  02,AB
06EA:  MOVFF  01,AA
06EE:  MOVFF  00,A9
06F2:  MOVFF  FEA,AE
06F6:  MOVFF  FE9,AD
06FA:  BCF    FD8.1
06FC:  MOVFF  03,C4
0700:  MOVFF  02,C3
0704:  MOVFF  01,C2
0708:  MOVFF  00,C1
070C:  MOVLW  0A
070E:  MOVWF  xC8
0710:  MOVLW  D7
0712:  MOVWF  xC7
0714:  MOVLW  23
0716:  MOVWF  xC6
0718:  MOVLW  77
071A:  MOVWF  xC5
071C:  RCALL  0416
071E:  MOVFF  AE,FEA
0722:  MOVFF  AD,FE9
0726:  MOVFF  00,FEF
072A:  MOVFF  01,FEC
072E:  MOVFF  02,FEC
0732:  MOVFF  03,FEC
....................     accelData[1] = (accelY / ACCEL_SCALE) -ACCEL_Y_OFFSET; 
0736:  MOVLW  04
0738:  ADDWF  x9F,W
073A:  MOVWF  FE9
073C:  MOVLW  00
073E:  ADDWFC xA0,W
0740:  MOVWF  FEA
0742:  MOVFF  A4,AA
0746:  MOVFF  A3,A9
074A:  RCALL  015E
074C:  MOVFF  03,C3
0750:  MOVFF  02,C2
0754:  MOVFF  01,C1
0758:  MOVFF  00,C0
075C:  CLRF   xC7
075E:  CLRF   xC6
0760:  CLRF   xC5
0762:  MOVLW  8B
0764:  MOVWF  xC4
0766:  RCALL  01A6
0768:  MOVFF  03,AC
076C:  MOVFF  02,AB
0770:  MOVFF  01,AA
0774:  MOVFF  00,A9
0778:  MOVFF  FEA,AE
077C:  MOVFF  FE9,AD
0780:  BSF    FD8.1
0782:  MOVFF  03,C4
0786:  MOVFF  02,C3
078A:  MOVFF  01,C2
078E:  MOVFF  00,C1
0792:  MOVLW  FA
0794:  MOVWF  xC8
0796:  MOVLW  ED
0798:  MOVWF  xC7
079A:  MOVLW  6B
079C:  MOVWF  xC6
079E:  MOVLW  78
07A0:  MOVWF  xC5
07A2:  RCALL  0416
07A4:  MOVFF  AE,FEA
07A8:  MOVFF  AD,FE9
07AC:  MOVFF  00,FEF
07B0:  MOVFF  01,FEC
07B4:  MOVFF  02,FEC
07B8:  MOVFF  03,FEC
....................     accelData[2] = (accelZ / ACCEL_SCALE) +ACCEL_Z_OFFSET; 
07BC:  MOVLW  08
07BE:  ADDWF  x9F,W
07C0:  MOVWF  FE9
07C2:  MOVLW  00
07C4:  ADDWFC xA0,W
07C6:  MOVWF  FEA
07C8:  MOVFF  A6,AA
07CC:  MOVFF  A5,A9
07D0:  RCALL  015E
07D2:  MOVFF  03,C3
07D6:  MOVFF  02,C2
07DA:  MOVFF  01,C1
07DE:  MOVFF  00,C0
07E2:  CLRF   xC7
07E4:  CLRF   xC6
07E6:  CLRF   xC5
07E8:  MOVLW  8B
07EA:  MOVWF  xC4
07EC:  RCALL  01A6
07EE:  MOVFF  03,AC
07F2:  MOVFF  02,AB
07F6:  MOVFF  01,AA
07FA:  MOVFF  00,A9
07FE:  MOVFF  FEA,AE
0802:  MOVFF  FE9,AD
0806:  BCF    FD8.1
0808:  MOVFF  03,C4
080C:  MOVFF  02,C3
0810:  MOVFF  01,C2
0814:  MOVFF  00,C1
0818:  MOVLW  79
081A:  MOVWF  xC8
081C:  MOVLW  01
081E:  MOVWF  xC7
0820:  MOVLW  76
0822:  MOVWF  xC6
0824:  MOVLW  7A
0826:  MOVWF  xC5
0828:  RCALL  0416
082A:  MOVFF  AE,FEA
082E:  MOVFF  AD,FE9
0832:  MOVFF  00,FEF
0836:  MOVFF  01,FEC
083A:  MOVFF  02,FEC
083E:  MOVFF  03,FEC
0842:  GOTO   0F9C (RETURN)
.................... } 
....................  
.................... //Function to read magnetometer data and convert it to uT 
.................... void mpu9250_read_magnometer(float magData[]) { 
*
2322:  CLRF   x7E
2324:  CLRF   x7D
2326:  MOVLW  F0
2328:  MOVWF  x82
232A:  CLRF   16
232C:  BTFSC  FF2.7
232E:  BSF    16.7
2330:  BCF    FF2.7
....................  
....................     int16_t magX, magY, magZ = 0; 
....................     uint8_t x_axis , y_axis , z_axis ; 
....................     uint8_t status = 0xF0; 
....................  
....................     mpu9250_readByte( MPU9250_ADDRESS,AK8963_ASAX , &x_axis ); 
2332:  MOVLW  68
2334:  MOVWF  xB2
2336:  MOVLW  10
2338:  MOVWF  xB3
233A:  CLRF   xB5
233C:  MOVLW  7F
233E:  MOVWF  xB4
2340:  CALL   00CE
2344:  BTFSC  16.7
2346:  BSF    FF2.7
2348:  CLRF   16
234A:  BTFSC  FF2.7
234C:  BSF    16.7
234E:  BCF    FF2.7
....................     mpu9250_readByte( MPU9250_ADDRESS,AK8963_ASAY , &y_axis ); 
2350:  MOVLW  68
2352:  MOVWF  xB2
2354:  MOVLW  11
2356:  MOVWF  xB3
2358:  CLRF   xB5
235A:  MOVLW  80
235C:  MOVWF  xB4
235E:  CALL   00CE
2362:  BTFSC  16.7
2364:  BSF    FF2.7
2366:  CLRF   16
2368:  BTFSC  FF2.7
236A:  BSF    16.7
236C:  BCF    FF2.7
....................     mpu9250_readByte( MPU9250_ADDRESS,AK8963_ASAZ , &z_axis ); 
236E:  MOVLW  68
2370:  MOVWF  xB2
2372:  MOVLW  12
2374:  MOVWF  xB3
2376:  CLRF   xB5
2378:  MOVLW  81
237A:  MOVWF  xB4
237C:  CALL   00CE
2380:  BTFSC  16.7
2382:  BSF    FF2.7
....................  
....................      
....................      
....................     // Check if the data is ready polling ST1 
....................     while(status & 0x01  == 0x01) 
2384:  BTFSS  x82.0
2386:  BRA    23A8
2388:  CLRF   16
238A:  BTFSC  FF2.7
238C:  BSF    16.7
238E:  BCF    FF2.7
....................     { 
....................         mpu9250_readByte(AK8963_ADDRESS, AK8963_ST1_REG, &status); 
2390:  MOVLW  0C
2392:  MOVWF  xB2
2394:  MOVLW  02
2396:  MOVWF  xB3
2398:  CLRF   xB5
239A:  MOVLW  82
239C:  MOVWF  xB4
239E:  CALL   00CE
23A2:  BTFSC  16.7
23A4:  BSF    FF2.7
23A6:  BRA    2384
....................      
....................     } 
....................      
....................     read_mag_word(MAG_XOUT_H, MAG_XOUT_L, &magX); 
23A8:  MOVLW  04
23AA:  MOVWF  x83
23AC:  MOVLW  03
23AE:  MOVWF  x84
23B0:  CLRF   x86
23B2:  MOVLW  79
23B4:  MOVWF  x85
23B6:  RCALL  22FC
....................         read_mag_word(MAG_YOUT_H, MAG_YOUT_L, &magY); 
23B8:  MOVLW  06
23BA:  MOVWF  x83
23BC:  MOVLW  05
23BE:  MOVWF  x84
23C0:  CLRF   x86
23C2:  MOVLW  7B
23C4:  MOVWF  x85
23C6:  RCALL  22FC
....................         read_mag_word(MAG_ZOUT_H, MAG_ZOUT_L, &magZ); 
23C8:  MOVLW  08
23CA:  MOVWF  x83
23CC:  MOVLW  07
23CE:  MOVWF  x84
23D0:  CLRF   x86
23D2:  MOVLW  7D
23D4:  MOVWF  x85
23D6:  RCALL  22FC
....................         // Convert the magnetometer data to uT 
....................         magData[0] = magX *((x_axis-128)*0.5 /128 +1); 
23D8:  MOVFF  77,FE9
23DC:  MOVFF  78,FEA
23E0:  MOVLW  80
23E2:  SUBWF  x7F,W
23E4:  CLRF   16
23E6:  BTFSC  FF2.7
23E8:  BSF    16.7
23EA:  BCF    FF2.7
23EC:  CLRF   x9C
23EE:  MOVWF  x9B
23F0:  CALL   13AC
23F4:  BTFSC  16.7
23F6:  BSF    FF2.7
23F8:  CLRF   16
23FA:  BTFSC  FF2.7
23FC:  BSF    16.7
23FE:  BCF    FF2.7
2400:  MOVFF  03,C3
2404:  MOVFF  02,C2
2408:  MOVFF  01,C1
240C:  MOVFF  00,C0
2410:  CLRF   xC7
2412:  CLRF   xC6
2414:  CLRF   xC5
2416:  MOVLW  7E
2418:  MOVWF  xC4
241A:  CALL   0846
241E:  BTFSC  16.7
2420:  BSF    FF2.7
2422:  MOVFF  03,88
2426:  MOVFF  02,87
242A:  MOVFF  01,86
242E:  MOVFF  00,85
2432:  CLRF   16
2434:  BTFSC  FF2.7
2436:  BSF    16.7
2438:  BCF    FF2.7
243A:  MOVFF  03,C3
243E:  MOVFF  02,C2
2442:  MOVFF  01,C1
2446:  MOVFF  00,C0
244A:  CLRF   xC7
244C:  CLRF   xC6
244E:  CLRF   xC5
2450:  MOVLW  86
2452:  MOVWF  xC4
2454:  CALL   01A6
2458:  BTFSC  16.7
245A:  BSF    FF2.7
245C:  MOVFF  03,88
2460:  MOVFF  02,87
2464:  MOVFF  01,86
2468:  MOVFF  00,85
246C:  MOVFF  FEA,8A
2470:  MOVFF  FE9,89
2474:  BCF    FD8.1
2476:  CLRF   16
2478:  BTFSC  FF2.7
247A:  BSF    16.7
247C:  BCF    FF2.7
247E:  MOVFF  03,C4
2482:  MOVFF  02,C3
2486:  MOVFF  01,C2
248A:  MOVFF  00,C1
248E:  CLRF   xC8
2490:  CLRF   xC7
2492:  CLRF   xC6
2494:  MOVLW  7F
2496:  MOVWF  xC5
2498:  CALL   0416
249C:  BTFSC  16.7
249E:  BSF    FF2.7
24A0:  MOVFF  8A,FEA
24A4:  MOVFF  89,FE9
24A8:  MOVFF  03,88
24AC:  MOVFF  02,87
24B0:  MOVFF  01,86
24B4:  MOVFF  00,85
24B8:  CLRF   16
24BA:  BTFSC  FF2.7
24BC:  BSF    16.7
24BE:  BCF    FF2.7
24C0:  MOVFF  7A,AA
24C4:  MOVFF  79,A9
24C8:  CALL   015E
24CC:  BTFSC  16.7
24CE:  BSF    FF2.7
24D0:  CLRF   16
24D2:  BTFSC  FF2.7
24D4:  BSF    16.7
24D6:  BCF    FF2.7
24D8:  MOVFF  03,C3
24DC:  MOVFF  02,C2
24E0:  MOVFF  01,C1
24E4:  MOVFF  00,C0
24E8:  MOVFF  88,C7
24EC:  MOVFF  87,C6
24F0:  MOVFF  86,C5
24F4:  MOVFF  85,C4
24F8:  CALL   0846
24FC:  BTFSC  16.7
24FE:  BSF    FF2.7
2500:  MOVFF  00,FEF
2504:  MOVFF  01,FEC
2508:  MOVFF  02,FEC
250C:  MOVFF  03,FEC
....................         magData[1] = magY *((y_axis-128)*0.5 /128 +1) ; 
2510:  MOVLW  04
2512:  ADDWF  x77,W
2514:  MOVWF  FE9
2516:  MOVLW  00
2518:  ADDWFC x78,W
251A:  MOVWF  FEA
251C:  MOVLW  80
251E:  SUBWF  x80,W
2520:  CLRF   16
2522:  BTFSC  FF2.7
2524:  BSF    16.7
2526:  BCF    FF2.7
2528:  CLRF   x9C
252A:  MOVWF  x9B
252C:  CALL   13AC
2530:  BTFSC  16.7
2532:  BSF    FF2.7
2534:  CLRF   16
2536:  BTFSC  FF2.7
2538:  BSF    16.7
253A:  BCF    FF2.7
253C:  MOVFF  03,C3
2540:  MOVFF  02,C2
2544:  MOVFF  01,C1
2548:  MOVFF  00,C0
254C:  CLRF   xC7
254E:  CLRF   xC6
2550:  CLRF   xC5
2552:  MOVLW  7E
2554:  MOVWF  xC4
2556:  CALL   0846
255A:  BTFSC  16.7
255C:  BSF    FF2.7
255E:  MOVFF  03,88
2562:  MOVFF  02,87
2566:  MOVFF  01,86
256A:  MOVFF  00,85
256E:  CLRF   16
2570:  BTFSC  FF2.7
2572:  BSF    16.7
2574:  BCF    FF2.7
2576:  MOVFF  03,C3
257A:  MOVFF  02,C2
257E:  MOVFF  01,C1
2582:  MOVFF  00,C0
2586:  CLRF   xC7
2588:  CLRF   xC6
258A:  CLRF   xC5
258C:  MOVLW  86
258E:  MOVWF  xC4
2590:  CALL   01A6
2594:  BTFSC  16.7
2596:  BSF    FF2.7
2598:  MOVFF  03,88
259C:  MOVFF  02,87
25A0:  MOVFF  01,86
25A4:  MOVFF  00,85
25A8:  MOVFF  FEA,8A
25AC:  MOVFF  FE9,89
25B0:  BCF    FD8.1
25B2:  CLRF   16
25B4:  BTFSC  FF2.7
25B6:  BSF    16.7
25B8:  BCF    FF2.7
25BA:  MOVFF  03,C4
25BE:  MOVFF  02,C3
25C2:  MOVFF  01,C2
25C6:  MOVFF  00,C1
25CA:  CLRF   xC8
25CC:  CLRF   xC7
25CE:  CLRF   xC6
25D0:  MOVLW  7F
25D2:  MOVWF  xC5
25D4:  CALL   0416
25D8:  BTFSC  16.7
25DA:  BSF    FF2.7
25DC:  MOVFF  8A,FEA
25E0:  MOVFF  89,FE9
25E4:  MOVFF  03,88
25E8:  MOVFF  02,87
25EC:  MOVFF  01,86
25F0:  MOVFF  00,85
25F4:  CLRF   16
25F6:  BTFSC  FF2.7
25F8:  BSF    16.7
25FA:  BCF    FF2.7
25FC:  MOVFF  7C,AA
2600:  MOVFF  7B,A9
2604:  CALL   015E
2608:  BTFSC  16.7
260A:  BSF    FF2.7
260C:  CLRF   16
260E:  BTFSC  FF2.7
2610:  BSF    16.7
2612:  BCF    FF2.7
2614:  MOVFF  03,C3
2618:  MOVFF  02,C2
261C:  MOVFF  01,C1
2620:  MOVFF  00,C0
2624:  MOVFF  88,C7
2628:  MOVFF  87,C6
262C:  MOVFF  86,C5
2630:  MOVFF  85,C4
2634:  CALL   0846
2638:  BTFSC  16.7
263A:  BSF    FF2.7
263C:  MOVFF  00,FEF
2640:  MOVFF  01,FEC
2644:  MOVFF  02,FEC
2648:  MOVFF  03,FEC
....................         magData[2] =  magZ *((z_axis-128)*0.5 /128 +1) ; 
264C:  MOVLW  08
264E:  ADDWF  x77,W
2650:  MOVWF  FE9
2652:  MOVLW  00
2654:  ADDWFC x78,W
2656:  MOVWF  FEA
2658:  MOVLW  80
265A:  SUBWF  x81,W
265C:  CLRF   16
265E:  BTFSC  FF2.7
2660:  BSF    16.7
2662:  BCF    FF2.7
2664:  CLRF   x9C
2666:  MOVWF  x9B
2668:  CALL   13AC
266C:  BTFSC  16.7
266E:  BSF    FF2.7
2670:  CLRF   16
2672:  BTFSC  FF2.7
2674:  BSF    16.7
2676:  BCF    FF2.7
2678:  MOVFF  03,C3
267C:  MOVFF  02,C2
2680:  MOVFF  01,C1
2684:  MOVFF  00,C0
2688:  CLRF   xC7
268A:  CLRF   xC6
268C:  CLRF   xC5
268E:  MOVLW  7E
2690:  MOVWF  xC4
2692:  CALL   0846
2696:  BTFSC  16.7
2698:  BSF    FF2.7
269A:  MOVFF  03,88
269E:  MOVFF  02,87
26A2:  MOVFF  01,86
26A6:  MOVFF  00,85
26AA:  CLRF   16
26AC:  BTFSC  FF2.7
26AE:  BSF    16.7
26B0:  BCF    FF2.7
26B2:  MOVFF  03,C3
26B6:  MOVFF  02,C2
26BA:  MOVFF  01,C1
26BE:  MOVFF  00,C0
26C2:  CLRF   xC7
26C4:  CLRF   xC6
26C6:  CLRF   xC5
26C8:  MOVLW  86
26CA:  MOVWF  xC4
26CC:  CALL   01A6
26D0:  BTFSC  16.7
26D2:  BSF    FF2.7
26D4:  MOVFF  03,88
26D8:  MOVFF  02,87
26DC:  MOVFF  01,86
26E0:  MOVFF  00,85
26E4:  MOVFF  FEA,8A
26E8:  MOVFF  FE9,89
26EC:  BCF    FD8.1
26EE:  CLRF   16
26F0:  BTFSC  FF2.7
26F2:  BSF    16.7
26F4:  BCF    FF2.7
26F6:  MOVFF  03,C4
26FA:  MOVFF  02,C3
26FE:  MOVFF  01,C2
2702:  MOVFF  00,C1
2706:  CLRF   xC8
2708:  CLRF   xC7
270A:  CLRF   xC6
270C:  MOVLW  7F
270E:  MOVWF  xC5
2710:  CALL   0416
2714:  BTFSC  16.7
2716:  BSF    FF2.7
2718:  MOVFF  8A,FEA
271C:  MOVFF  89,FE9
2720:  MOVFF  03,88
2724:  MOVFF  02,87
2728:  MOVFF  01,86
272C:  MOVFF  00,85
2730:  CLRF   16
2732:  BTFSC  FF2.7
2734:  BSF    16.7
2736:  BCF    FF2.7
2738:  MOVFF  7E,AA
273C:  MOVFF  7D,A9
2740:  CALL   015E
2744:  BTFSC  16.7
2746:  BSF    FF2.7
2748:  CLRF   16
274A:  BTFSC  FF2.7
274C:  BSF    16.7
274E:  BCF    FF2.7
2750:  MOVFF  03,C3
2754:  MOVFF  02,C2
2758:  MOVFF  01,C1
275C:  MOVFF  00,C0
2760:  MOVFF  88,C7
2764:  MOVFF  87,C6
2768:  MOVFF  86,C5
276C:  MOVFF  85,C4
2770:  CALL   0846
2774:  BTFSC  16.7
2776:  BSF    FF2.7
2778:  MOVFF  00,FEF
277C:  MOVFF  01,FEC
2780:  MOVFF  02,FEC
2784:  MOVFF  03,FEC
2788:  CLRF   16
278A:  BTFSC  FF2.7
278C:  BSF    16.7
278E:  BCF    FF2.7
....................     mpu9250_readByte(AK8963_ADDRESS, AK8963_ST2_REG, &status); 
2790:  MOVLW  0C
2792:  MOVWF  xB2
2794:  MOVLW  09
2796:  MOVWF  xB3
2798:  CLRF   xB5
279A:  MOVLW  82
279C:  MOVWF  xB4
279E:  CALL   00CE
27A2:  BTFSC  16.7
27A4:  BSF    FF2.7
27A6:  GOTO   2A38 (RETURN)
....................      
....................     //mpu9250_writeByte(AK8963_ADDRESS, AK8963_CNTL1_Reg, 0x11);                   // Set the magnetometer to 16 bit resolution, 100 Hz update rate 
....................  
.................... //    if (status==0x01) { 
.................... //        // Read the magnetometer data 
.................... //        read_mag_word(MAG_XOUT_H, MAG_XOUT_L, &magX); 
.................... //        read_mag_word(MAG_YOUT_H, MAG_YOUT_L, &magY); 
.................... //        read_mag_word(MAG_ZOUT_H, MAG_ZOUT_L, &magZ); 
.................... //        // Convert the magnetometer data to uT 
.................... //        magData[0] = magX / MAG_SCALE; 
.................... //        magData[1] = magY / MAG_SCALE; 
.................... //        magData[2] = magZ / MAG_SCALE; 
.................... //    } 
.................... //    else { 
.................... //        // Handle the error and notify the user 
.................... //        printf( "Magnetometer data is not ready! -> %d \n\r" , status); 
.................... //         
.................... //        // Read the magnetometer data 
.................... //        read_mag_word(MAG_XOUT_H, MAG_XOUT_L, &magX); 
.................... //        read_mag_word(MAG_YOUT_H, MAG_YOUT_L, &magY); 
.................... //        read_mag_word(MAG_ZOUT_H, MAG_ZOUT_L, &magZ); 
.................... //        // Convert the magnetometer data to uT 
.................... //        magData[0] = magX / MAG_SCALE; 
.................... //        magData[1] = magY / MAG_SCALE; 
.................... //        magData[2] = magZ / MAG_SCALE; 
.................... //    } 
....................  
.................... } 
....................  
.................... void mpu9250_print_module_values() { 
....................  
....................     // Read the gyro values 
....................     mpu9250_read_gyro(gyro); 
....................     mpu9250_read_magnometer(mag); 
....................     mpu9250_read_accelerometer(accel); 
....................  
....................     // Read the mag values 
....................     printf(ANSI_COLOR_YELLOW"Gyro : X = %.5f, Y = %.5f, Z = %.5f (deg/s)   \t"ANSI_COLOR_RESET, gyro[0], gyro[1], gyro[2]); 
....................     printf(ANSI_COLOR_YELLOW"Mag  : X = %.5f, Y = %.5f, Z = %.5f (uT)      \t"ANSI_COLOR_RESET,  mag[0],  mag[1],  mag[2]); 
....................     printf(ANSI_COLOR_YELLOW"Accel: X = %.5f, Y = %.5f, Z = %.5f (g)     \n\r"ANSI_COLOR_RESET,accel[0],accel[1],accel[2]); 
....................      
.................... } 
....................  
....................  
....................  
.................... // Function to calibrate the accelerometer 
.................... void mpu9250_gyro_calibration( RateCalibration_t *RateCalibration ) 
.................... { 
....................  
....................     for (uint16_t RateCalibrationNumber=0; RateCalibrationNumber<4000; RateCalibrationNumber ++) { 
*
1E66:  CLRF   x7A
1E68:  CLRF   x79
1E6A:  MOVF   x7A,W
1E6C:  SUBLW  0F
1E6E:  BTFSS  FD8.0
1E70:  BRA    1FB6
1E72:  BNZ   1E7C
1E74:  MOVF   x79,W
1E76:  SUBLW  9F
1E78:  BTFSS  FD8.0
1E7A:  BRA    1FB6
1E7C:  CLRF   16
1E7E:  BTFSC  FF2.7
1E80:  BSF    16.7
1E82:  BCF    FF2.7
....................         mpu9250_read_gyro(gyro); 
1E84:  CLRF   x9C
1E86:  MOVLW  1D
1E88:  MOVWF  x9B
1E8A:  CALL   0300
1E8E:  BTFSC  16.7
1E90:  BSF    FF2.7
....................         RateCalibration->roll += gyro[0];     //calculate average value of gyro in x axis 
1E92:  MOVLW  04
1E94:  ADDWF  x77,W
1E96:  MOVWF  FE9
1E98:  MOVLW  00
1E9A:  ADDWFC x78,W
1E9C:  MOVWF  FEA
1E9E:  MOVFF  FEA,82
1EA2:  MOVFF  FE9,81
1EA6:  BCF    FD8.1
1EA8:  CLRF   16
1EAA:  BTFSC  FF2.7
1EAC:  BSF    16.7
1EAE:  BCF    FF2.7
1EB0:  MOVFF  FEF,C1
1EB4:  MOVFF  FEC,C2
1EB8:  MOVFF  FEC,C3
1EBC:  MOVFF  FEC,C4
1EC0:  MOVFF  20,C8
1EC4:  MOVFF  1F,C7
1EC8:  MOVFF  1E,C6
1ECC:  MOVFF  1D,C5
1ED0:  CALL   0416
1ED4:  BTFSC  16.7
1ED6:  BSF    FF2.7
1ED8:  MOVFF  82,FEA
1EDC:  MOVFF  81,FE9
1EE0:  MOVFF  00,FEF
1EE4:  MOVFF  01,FEC
1EE8:  MOVFF  02,FEC
1EEC:  MOVFF  03,FEC
....................         RateCalibration->pitch  += gyro[1];     //calculate average value of gyro in y axis 
1EF0:  MOVFF  77,FE9
1EF4:  MOVFF  78,FEA
1EF8:  MOVFF  FEA,82
1EFC:  MOVFF  FE9,81
1F00:  BCF    FD8.1
1F02:  CLRF   16
1F04:  BTFSC  FF2.7
1F06:  BSF    16.7
1F08:  BCF    FF2.7
1F0A:  MOVFF  FEF,C1
1F0E:  MOVFF  FEC,C2
1F12:  MOVFF  FEC,C3
1F16:  MOVFF  FEC,C4
1F1A:  MOVFF  24,C8
1F1E:  MOVFF  23,C7
1F22:  MOVFF  22,C6
1F26:  MOVFF  21,C5
1F2A:  CALL   0416
1F2E:  BTFSC  16.7
1F30:  BSF    FF2.7
1F32:  MOVFF  82,FEA
1F36:  MOVFF  81,FE9
1F3A:  MOVFF  00,FEF
1F3E:  MOVFF  01,FEC
1F42:  MOVFF  02,FEC
1F46:  MOVFF  03,FEC
....................         RateCalibration->yaw   += gyro[2];     //calculate average value of gyro in z axis 
1F4A:  MOVLW  08
1F4C:  ADDWF  x77,W
1F4E:  MOVWF  FE9
1F50:  MOVLW  00
1F52:  ADDWFC x78,W
1F54:  MOVWF  FEA
1F56:  MOVFF  FEA,82
1F5A:  MOVFF  FE9,81
1F5E:  BCF    FD8.1
1F60:  CLRF   16
1F62:  BTFSC  FF2.7
1F64:  BSF    16.7
1F66:  BCF    FF2.7
1F68:  MOVFF  FEF,C1
1F6C:  MOVFF  FEC,C2
1F70:  MOVFF  FEC,C3
1F74:  MOVFF  FEC,C4
1F78:  MOVFF  28,C8
1F7C:  MOVFF  27,C7
1F80:  MOVFF  26,C6
1F84:  MOVFF  25,C5
1F88:  CALL   0416
1F8C:  BTFSC  16.7
1F8E:  BSF    FF2.7
1F90:  MOVFF  82,FEA
1F94:  MOVFF  81,FE9
1F98:  MOVFF  00,FEF
1F9C:  MOVFF  01,FEC
1FA0:  MOVFF  02,FEC
1FA4:  MOVFF  03,FEC
....................  
....................         delay_ms(1) ; 
1FA8:  MOVLW  01
1FAA:  MOVWF  x7B
1FAC:  RCALL  1ACC
1FAE:  INCF   x79,F
1FB0:  BTFSC  FD8.2
1FB2:  INCF   x7A,F
1FB4:  BRA    1E6A
....................     } 
....................     RateCalibration->roll /= 4000;     //calculate average value of gyro in x axis 
1FB6:  MOVLW  04
1FB8:  ADDWF  x77,W
1FBA:  MOVWF  FE9
1FBC:  MOVLW  00
1FBE:  ADDWFC x78,W
1FC0:  MOVWF  FEA
1FC2:  CLRF   16
1FC4:  BTFSC  FF2.7
1FC6:  BSF    16.7
1FC8:  BCF    FF2.7
1FCA:  MOVFF  FEF,C0
1FCE:  MOVFF  FEC,C1
1FD2:  MOVFF  FEC,C2
1FD6:  MOVFF  FEC,C3
1FDA:  MOVF   FED,F
1FDC:  MOVF   FED,F
1FDE:  MOVF   FED,F
1FE0:  CLRF   xC7
1FE2:  CLRF   xC6
1FE4:  MOVLW  7A
1FE6:  MOVWF  xC5
1FE8:  MOVLW  8A
1FEA:  MOVWF  xC4
1FEC:  CALL   01A6
1FF0:  BTFSC  16.7
1FF2:  BSF    FF2.7
1FF4:  MOVFF  00,FEF
1FF8:  MOVFF  01,FEC
1FFC:  MOVFF  02,FEC
2000:  MOVFF  03,FEC
....................     RateCalibration->pitch  /= 4000;     //calculate average value of gyro in y axis 
2004:  MOVFF  77,FE9
2008:  MOVFF  78,FEA
200C:  CLRF   16
200E:  BTFSC  FF2.7
2010:  BSF    16.7
2012:  BCF    FF2.7
2014:  MOVFF  FEF,C0
2018:  MOVFF  FEC,C1
201C:  MOVFF  FEC,C2
2020:  MOVFF  FEC,C3
2024:  MOVF   FED,F
2026:  MOVF   FED,F
2028:  MOVF   FED,F
202A:  CLRF   xC7
202C:  CLRF   xC6
202E:  MOVLW  7A
2030:  MOVWF  xC5
2032:  MOVLW  8A
2034:  MOVWF  xC4
2036:  CALL   01A6
203A:  BTFSC  16.7
203C:  BSF    FF2.7
203E:  MOVFF  00,FEF
2042:  MOVFF  01,FEC
2046:  MOVFF  02,FEC
204A:  MOVFF  03,FEC
....................     RateCalibration->yaw   /= 4000;     //calculate average value of gyro in z axis 
204E:  MOVLW  08
2050:  ADDWF  x77,W
2052:  MOVWF  FE9
2054:  MOVLW  00
2056:  ADDWFC x78,W
2058:  MOVWF  FEA
205A:  CLRF   16
205C:  BTFSC  FF2.7
205E:  BSF    16.7
2060:  BCF    FF2.7
2062:  MOVFF  FEF,C0
2066:  MOVFF  FEC,C1
206A:  MOVFF  FEC,C2
206E:  MOVFF  FEC,C3
2072:  MOVF   FED,F
2074:  MOVF   FED,F
2076:  MOVF   FED,F
2078:  CLRF   xC7
207A:  CLRF   xC6
207C:  MOVLW  7A
207E:  MOVWF  xC5
2080:  MOVLW  8A
2082:  MOVWF  xC4
2084:  CALL   01A6
2088:  BTFSC  16.7
208A:  BSF    FF2.7
208C:  MOVFF  00,FEF
2090:  MOVFF  01,FEC
2094:  MOVFF  02,FEC
2098:  MOVFF  03,FEC
209C:  GOTO   2966 (RETURN)
....................  
....................  
.................... } 
....................  
....................  
.................... // Function to calculate the yaw, pitch and roll angles 
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[]) 
.................... { 
....................  
....................         // Read the accelerometer and magnetometer values 
....................         mpu9250_read_accelerometer(accelData); 
*
0F90:  MOVFF  9E,A0
0F94:  MOVFF  9D,9F
0F98:  GOTO   0680
....................  
....................         // Calculate the roll angle 
....................         Angle->roll = atan( accelData[1] / sqrt(  (float)(accelData[0] * accelData[0] + accelData[2] * accelData[2]) )) * 180.0 / PI; 
0F9C:  MOVLW  04
0F9E:  ADDWF  x9B,W
0FA0:  MOVWF  01
0FA2:  MOVLW  00
0FA4:  ADDWFC x9C,W
0FA6:  MOVWF  03
0FA8:  MOVFF  01,9F
0FAC:  MOVWF  xA0
0FAE:  MOVLW  04
0FB0:  ADDWF  x9D,W
0FB2:  MOVWF  FE9
0FB4:  MOVLW  00
0FB6:  ADDWFC x9E,W
0FB8:  MOVWF  FEA
0FBA:  MOVFF  FEF,A1
0FBE:  MOVFF  FEC,A2
0FC2:  MOVFF  FEC,A3
0FC6:  MOVFF  FEC,A4
0FCA:  MOVFF  9D,FE9
0FCE:  MOVFF  9E,FEA
0FD2:  MOVFF  FEF,A5
0FD6:  MOVFF  FEC,A6
0FDA:  MOVFF  FEC,A7
0FDE:  MOVFF  FEC,A8
0FE2:  MOVFF  9D,FE9
0FE6:  MOVFF  9E,FEA
0FEA:  MOVFF  FEF,00
0FEE:  MOVFF  FEC,01
0FF2:  MOVFF  FEC,02
0FF6:  MOVFF  FEC,03
0FFA:  MOVFF  A8,C3
0FFE:  MOVFF  A7,C2
1002:  MOVFF  A6,C1
1006:  MOVFF  A5,C0
100A:  MOVFF  03,C7
100E:  MOVFF  02,C6
1012:  MOVFF  01,C5
1016:  MOVFF  00,C4
101A:  RCALL  0846
101C:  MOVFF  03,A8
1020:  MOVFF  02,A7
1024:  MOVFF  01,A6
1028:  MOVFF  00,A5
102C:  MOVLW  08
102E:  ADDWF  x9D,W
1030:  MOVWF  FE9
1032:  MOVLW  00
1034:  ADDWFC x9E,W
1036:  MOVWF  FEA
1038:  MOVFF  FEF,A9
103C:  MOVFF  FEC,AA
1040:  MOVFF  FEC,AB
1044:  MOVFF  FEC,AC
1048:  MOVLW  08
104A:  ADDWF  x9D,W
104C:  MOVWF  FE9
104E:  MOVLW  00
1050:  ADDWFC x9E,W
1052:  MOVWF  FEA
1054:  MOVFF  FEF,00
1058:  MOVFF  FEC,01
105C:  MOVFF  FEC,02
1060:  MOVFF  FEC,03
1064:  MOVFF  AC,C3
1068:  MOVFF  AB,C2
106C:  MOVFF  AA,C1
1070:  MOVFF  A9,C0
1074:  MOVFF  03,C7
1078:  MOVFF  02,C6
107C:  MOVFF  01,C5
1080:  MOVFF  00,C4
1084:  CALL   0846
1088:  MOVFF  FEA,AA
108C:  MOVFF  FE9,A9
1090:  BCF    FD8.1
1092:  MOVFF  A8,C4
1096:  MOVFF  A7,C3
109A:  MOVFF  A6,C2
109E:  MOVFF  A5,C1
10A2:  MOVFF  03,C8
10A6:  MOVFF  02,C7
10AA:  MOVFF  01,C6
10AE:  MOVFF  00,C5
10B2:  CALL   0416
10B6:  MOVFF  AA,FEA
10BA:  MOVFF  A9,FE9
10BE:  MOVFF  03,A8
10C2:  MOVFF  02,A7
10C6:  MOVFF  01,A6
10CA:  MOVFF  00,A5
10CE:  MOVFF  03,AE
10D2:  MOVFF  02,AD
10D6:  MOVFF  01,AC
10DA:  MOVFF  00,AB
10DE:  RCALL  09AE
10E0:  MOVFF  A4,C3
10E4:  MOVFF  A3,C2
10E8:  MOVFF  A2,C1
10EC:  MOVFF  A1,C0
10F0:  MOVFF  03,C7
10F4:  MOVFF  02,C6
10F8:  MOVFF  01,C5
10FC:  MOVFF  00,C4
1100:  CALL   01A6
1104:  MOVFF  03,A4
1108:  MOVFF  02,A3
110C:  MOVFF  01,A2
1110:  MOVFF  00,A1
1114:  MOVFF  03,AE
1118:  MOVFF  02,AD
111C:  MOVFF  01,AC
1120:  MOVFF  00,AB
1124:  RCALL  0ABA
1126:  MOVFF  03,A4
112A:  MOVFF  02,A3
112E:  MOVFF  01,A2
1132:  MOVFF  00,A1
1136:  MOVFF  03,C3
113A:  MOVFF  02,C2
113E:  MOVFF  01,C1
1142:  MOVFF  00,C0
1146:  CLRF   xC7
1148:  CLRF   xC6
114A:  MOVLW  34
114C:  MOVWF  xC5
114E:  MOVLW  86
1150:  MOVWF  xC4
1152:  CALL   0846
1156:  MOVFF  03,A4
115A:  MOVFF  02,A3
115E:  MOVFF  01,A2
1162:  MOVFF  00,A1
1166:  MOVFF  03,C3
116A:  MOVFF  02,C2
116E:  MOVFF  01,C1
1172:  MOVFF  00,C0
1176:  MOVLW  DB
1178:  MOVWF  xC7
117A:  MOVLW  0F
117C:  MOVWF  xC6
117E:  MOVLW  49
1180:  MOVWF  xC5
1182:  MOVLW  80
1184:  MOVWF  xC4
1186:  CALL   01A6
118A:  MOVFF  A0,FEA
118E:  MOVFF  9F,FE9
1192:  MOVFF  00,FEF
1196:  MOVFF  01,FEC
119A:  MOVFF  02,FEC
119E:  MOVFF  03,FEC
....................         // Calculate the pitch angle 
....................         Angle->pitch = atan( accelData[0] / sqrt( (float) (accelData[1] * accelData[1] + accelData[2] * accelData[2]) )) * (-180.0) / PI; 
11A2:  MOVFF  9B,9F
11A6:  MOVFF  9C,A0
11AA:  MOVFF  9D,FE9
11AE:  MOVFF  9E,FEA
11B2:  MOVFF  FEF,A1
11B6:  MOVFF  FEC,A2
11BA:  MOVFF  FEC,A3
11BE:  MOVFF  FEC,A4
11C2:  MOVLW  04
11C4:  ADDWF  x9D,W
11C6:  MOVWF  FE9
11C8:  MOVLW  00
11CA:  ADDWFC x9E,W
11CC:  MOVWF  FEA
11CE:  MOVFF  FEF,A5
11D2:  MOVFF  FEC,A6
11D6:  MOVFF  FEC,A7
11DA:  MOVFF  FEC,A8
11DE:  MOVLW  04
11E0:  ADDWF  x9D,W
11E2:  MOVWF  FE9
11E4:  MOVLW  00
11E6:  ADDWFC x9E,W
11E8:  MOVWF  FEA
11EA:  MOVFF  FEF,00
11EE:  MOVFF  FEC,01
11F2:  MOVFF  FEC,02
11F6:  MOVFF  FEC,03
11FA:  MOVFF  A8,C3
11FE:  MOVFF  A7,C2
1202:  MOVFF  A6,C1
1206:  MOVFF  A5,C0
120A:  MOVFF  03,C7
120E:  MOVFF  02,C6
1212:  MOVFF  01,C5
1216:  MOVFF  00,C4
121A:  CALL   0846
121E:  MOVFF  03,A8
1222:  MOVFF  02,A7
1226:  MOVFF  01,A6
122A:  MOVFF  00,A5
122E:  MOVLW  08
1230:  ADDWF  x9D,W
1232:  MOVWF  FE9
1234:  MOVLW  00
1236:  ADDWFC x9E,W
1238:  MOVWF  FEA
123A:  MOVFF  FEF,A9
123E:  MOVFF  FEC,AA
1242:  MOVFF  FEC,AB
1246:  MOVFF  FEC,AC
124A:  MOVLW  08
124C:  ADDWF  x9D,W
124E:  MOVWF  FE9
1250:  MOVLW  00
1252:  ADDWFC x9E,W
1254:  MOVWF  FEA
1256:  MOVFF  FEF,00
125A:  MOVFF  FEC,01
125E:  MOVFF  FEC,02
1262:  MOVFF  FEC,03
1266:  MOVFF  AC,C3
126A:  MOVFF  AB,C2
126E:  MOVFF  AA,C1
1272:  MOVFF  A9,C0
1276:  MOVFF  03,C7
127A:  MOVFF  02,C6
127E:  MOVFF  01,C5
1282:  MOVFF  00,C4
1286:  CALL   0846
128A:  MOVFF  FEA,AA
128E:  MOVFF  FE9,A9
1292:  BCF    FD8.1
1294:  MOVFF  A8,C4
1298:  MOVFF  A7,C3
129C:  MOVFF  A6,C2
12A0:  MOVFF  A5,C1
12A4:  MOVFF  03,C8
12A8:  MOVFF  02,C7
12AC:  MOVFF  01,C6
12B0:  MOVFF  00,C5
12B4:  CALL   0416
12B8:  MOVFF  AA,FEA
12BC:  MOVFF  A9,FE9
12C0:  MOVFF  03,A8
12C4:  MOVFF  02,A7
12C8:  MOVFF  01,A6
12CC:  MOVFF  00,A5
12D0:  MOVFF  03,AE
12D4:  MOVFF  02,AD
12D8:  MOVFF  01,AC
12DC:  MOVFF  00,AB
12E0:  CALL   09AE
12E4:  MOVFF  A4,C3
12E8:  MOVFF  A3,C2
12EC:  MOVFF  A2,C1
12F0:  MOVFF  A1,C0
12F4:  MOVFF  03,C7
12F8:  MOVFF  02,C6
12FC:  MOVFF  01,C5
1300:  MOVFF  00,C4
1304:  CALL   01A6
1308:  MOVFF  03,A4
130C:  MOVFF  02,A3
1310:  MOVFF  01,A2
1314:  MOVFF  00,A1
1318:  MOVFF  03,AE
131C:  MOVFF  02,AD
1320:  MOVFF  01,AC
1324:  MOVFF  00,AB
1328:  CALL   0ABA
132C:  MOVFF  03,A4
1330:  MOVFF  02,A3
1334:  MOVFF  01,A2
1338:  MOVFF  00,A1
133C:  MOVFF  03,C3
1340:  MOVFF  02,C2
1344:  MOVFF  01,C1
1348:  MOVFF  00,C0
134C:  CLRF   xC7
134E:  CLRF   xC6
1350:  MOVLW  B4
1352:  MOVWF  xC5
1354:  MOVLW  86
1356:  MOVWF  xC4
1358:  CALL   0846
135C:  MOVFF  03,A4
1360:  MOVFF  02,A3
1364:  MOVFF  01,A2
1368:  MOVFF  00,A1
136C:  MOVFF  03,C3
1370:  MOVFF  02,C2
1374:  MOVFF  01,C1
1378:  MOVFF  00,C0
137C:  MOVLW  DB
137E:  MOVWF  xC7
1380:  MOVLW  0F
1382:  MOVWF  xC6
1384:  MOVLW  49
1386:  MOVWF  xC5
1388:  MOVLW  80
138A:  MOVWF  xC4
138C:  CALL   01A6
1390:  MOVFF  A0,FEA
1394:  MOVFF  9F,FE9
1398:  MOVFF  00,FEF
139C:  MOVFF  01,FEC
13A0:  MOVFF  02,FEC
13A4:  MOVFF  03,FEC
13A8:  GOTO   1692 (RETURN)
.................... //Angle->roll = atan(0.1);Angle->pitch= 1; 
....................  
.................... } 
....................  
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]) 
.................... { 
....................   KalmanState=KalmanState+0.0192*KalmanInput; 
*
13E2:  MOVLW  52
13E4:  MOVWF  xC3
13E6:  MOVLW  49
13E8:  MOVWF  xC2
13EA:  MOVLW  1D
13EC:  MOVWF  xC1
13EE:  MOVLW  79
13F0:  MOVWF  xC0
13F2:  MOVFF  AE,C7
13F6:  MOVFF  AD,C6
13FA:  MOVFF  AC,C5
13FE:  MOVFF  AB,C4
1402:  CALL   0846
1406:  BCF    FD8.1
1408:  MOVFF  A6,C4
140C:  MOVFF  A5,C3
1410:  MOVFF  A4,C2
1414:  MOVFF  A3,C1
1418:  MOVFF  03,C8
141C:  MOVFF  02,C7
1420:  MOVFF  01,C6
1424:  MOVFF  00,C5
1428:  CALL   0416
142C:  MOVFF  03,A6
1430:  MOVFF  02,A5
1434:  MOVFF  01,A4
1438:  MOVFF  00,A3
....................   KalmanUncertainty=KalmanUncertainty + 0.0192 * 0.0192 * 4 * 4; 
143C:  BCF    FD8.1
143E:  MOVFF  AA,C4
1442:  MOVFF  A9,C3
1446:  MOVFF  A8,C2
144A:  MOVFF  A7,C1
144E:  MOVLW  07
1450:  MOVWF  xC8
1452:  MOVLW  46
1454:  MOVWF  xC7
1456:  MOVLW  41
1458:  MOVWF  xC6
145A:  MOVLW  77
145C:  MOVWF  xC5
145E:  CALL   0416
1462:  MOVFF  03,AA
1466:  MOVFF  02,A9
146A:  MOVFF  01,A8
146E:  MOVFF  00,A7
....................   float KalmanGain=KalmanUncertainty * 1/(1*KalmanUncertainty + 3 * 3); 
1472:  MOVFF  AA,C3
1476:  MOVFF  A9,C2
147A:  MOVFF  A8,C1
147E:  MOVFF  A7,C0
1482:  CLRF   xC7
1484:  CLRF   xC6
1486:  CLRF   xC5
1488:  MOVLW  7F
148A:  MOVWF  xC4
148C:  CALL   0846
1490:  MOVFF  03,BC
1494:  MOVFF  02,BB
1498:  MOVFF  01,BA
149C:  MOVFF  00,B9
14A0:  CLRF   xC3
14A2:  CLRF   xC2
14A4:  CLRF   xC1
14A6:  MOVLW  7F
14A8:  MOVWF  xC0
14AA:  MOVFF  AA,C7
14AE:  MOVFF  A9,C6
14B2:  MOVFF  A8,C5
14B6:  MOVFF  A7,C4
14BA:  CALL   0846
14BE:  MOVFF  03,C0
14C2:  MOVFF  02,BF
14C6:  MOVFF  01,BE
14CA:  MOVFF  00,BD
14CE:  BCF    FD8.1
14D0:  MOVFF  03,C4
14D4:  MOVFF  02,C3
14D8:  MOVFF  01,C2
14DC:  MOVFF  00,C1
14E0:  CLRF   xC8
14E2:  CLRF   xC7
14E4:  MOVLW  10
14E6:  MOVWF  xC6
14E8:  MOVLW  82
14EA:  MOVWF  xC5
14EC:  CALL   0416
14F0:  MOVFF  BC,C3
14F4:  MOVFF  BB,C2
14F8:  MOVFF  BA,C1
14FC:  MOVFF  B9,C0
1500:  MOVFF  03,C7
1504:  MOVFF  02,C6
1508:  MOVFF  01,C5
150C:  MOVFF  00,C4
1510:  CALL   01A6
1514:  MOVFF  03,B8
1518:  MOVFF  02,B7
151C:  MOVFF  01,B6
1520:  MOVFF  00,B5
....................   KalmanState=KalmanState+KalmanGain * (KalmanMeasurement-KalmanState); 
1524:  BSF    FD8.1
1526:  MOVFF  B2,C4
152A:  MOVFF  B1,C3
152E:  MOVFF  B0,C2
1532:  MOVFF  AF,C1
1536:  MOVFF  A6,C8
153A:  MOVFF  A5,C7
153E:  MOVFF  A4,C6
1542:  MOVFF  A3,C5
1546:  CALL   0416
154A:  MOVFF  B8,C3
154E:  MOVFF  B7,C2
1552:  MOVFF  B6,C1
1556:  MOVFF  B5,C0
155A:  MOVFF  03,C7
155E:  MOVFF  02,C6
1562:  MOVFF  01,C5
1566:  MOVFF  00,C4
156A:  CALL   0846
156E:  BCF    FD8.1
1570:  MOVFF  A6,C4
1574:  MOVFF  A5,C3
1578:  MOVFF  A4,C2
157C:  MOVFF  A3,C1
1580:  MOVFF  03,C8
1584:  MOVFF  02,C7
1588:  MOVFF  01,C6
158C:  MOVFF  00,C5
1590:  CALL   0416
1594:  MOVFF  03,A6
1598:  MOVFF  02,A5
159C:  MOVFF  01,A4
15A0:  MOVFF  00,A3
....................   KalmanUncertainty=(1-KalmanGain) * KalmanUncertainty; 
15A4:  BSF    FD8.1
15A6:  CLRF   xC4
15A8:  CLRF   xC3
15AA:  CLRF   xC2
15AC:  MOVLW  7F
15AE:  MOVWF  xC1
15B0:  MOVFF  B8,C8
15B4:  MOVFF  B7,C7
15B8:  MOVFF  B6,C6
15BC:  MOVFF  B5,C5
15C0:  CALL   0416
15C4:  MOVFF  03,BC
15C8:  MOVFF  02,BB
15CC:  MOVFF  01,BA
15D0:  MOVFF  00,B9
15D4:  MOVFF  03,C3
15D8:  MOVFF  02,C2
15DC:  MOVFF  01,C1
15E0:  MOVFF  00,C0
15E4:  MOVFF  AA,C7
15E8:  MOVFF  A9,C6
15EC:  MOVFF  A8,C5
15F0:  MOVFF  A7,C4
15F4:  CALL   0846
15F8:  MOVFF  03,AA
15FC:  MOVFF  02,A9
1600:  MOVFF  01,A8
1604:  MOVFF  00,A7
....................     Kalman1DOutput[0]=KalmanState; 
1608:  MOVFF  B3,FE9
160C:  MOVFF  B4,FEA
1610:  MOVFF  A3,FEF
1614:  MOVFF  A4,FEC
1618:  MOVFF  A5,FEC
161C:  MOVFF  A6,FEC
....................     Kalman1DOutput[1]=KalmanUncertainty; 
1620:  MOVLW  04
1622:  ADDWF  xB3,W
1624:  MOVWF  FE9
1626:  MOVLW  00
1628:  ADDWFC xB4,W
162A:  MOVWF  FEA
162C:  MOVFF  A7,FEF
1630:  MOVFF  A8,FEC
1634:  MOVFF  A9,FEC
1638:  MOVFF  AA,FEC
163C:  RETURN 0
.................... } 
....................  
.................... // Calculate the roll angle 
....................  
....................  
.................... // Calculate the pitch angle 
....................  
....................  

Configuration Fuses:
   Word  1: CC27   PLL12 CPUDIV1 USBDIV HS FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0500   CCP2C1 NOPBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
