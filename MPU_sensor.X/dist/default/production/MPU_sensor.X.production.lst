CCS PCH C Compiler, Version 5.015, 5967               26-Jan-24 19:24

               Filename:   C:\Users\hp\Desktop\MPU_sensor.X\dist\default\production\MPU_sensor.X.production.lst

               ROM used:   12584 bytes (38%)
                           Largest free fragment is 19704
               RAM used:   1133 (55%) at main() level
                           1229 (60%) worst case
               Stack used: 13 locations (6 in main + 7 for interrupts)
               Stack size: 31

*
0000:  GOTO   2EB4
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.1
004A:  GOTO   0054
004E:  BTFSC  F9E.1
0050:  GOTO   2052
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #import(file="build/default/production/main.o") 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
....................  
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
0202:  MOVLB  4
0204:  MOVF   xBD,W
0206:  BTFSC  FD8.2
0208:  BRA    0354
020A:  MOVWF  xC9
020C:  MOVF   xC1,W
020E:  BTFSC  FD8.2
0210:  BRA    0354
0212:  SUBWF  xC9,F
0214:  BNC   0220
0216:  MOVLW  7F
0218:  ADDWF  xC9,F
021A:  BTFSC  FD8.0
021C:  BRA    0354
021E:  BRA    022C
0220:  MOVLW  81
0222:  SUBWF  xC9,F
0224:  BTFSS  FD8.0
0226:  BRA    0354
0228:  BTFSC  FD8.2
022A:  BRA    0354
022C:  MOVFF  4C9,00
0230:  CLRF   01
0232:  CLRF   02
0234:  CLRF   03
0236:  CLRF   xC8
0238:  MOVFF  4BE,4C7
023C:  BSF    xC7.7
023E:  MOVFF  4BF,4C6
0242:  MOVFF  4C0,4C5
0246:  MOVLW  19
0248:  MOVWF  xC9
024A:  MOVF   xC4,W
024C:  SUBWF  xC5,F
024E:  BC    026A
0250:  MOVLW  01
0252:  SUBWF  xC6,F
0254:  BC    026A
0256:  SUBWF  xC7,F
0258:  BC    026A
025A:  SUBWF  xC8,F
025C:  BC    026A
025E:  INCF   xC8,F
0260:  INCF   xC7,F
0262:  INCF   xC6,F
0264:  MOVF   xC4,W
0266:  ADDWF  xC5,F
0268:  BRA    02BA
026A:  MOVF   xC3,W
026C:  SUBWF  xC6,F
026E:  BC    0294
0270:  MOVLW  01
0272:  SUBWF  xC7,F
0274:  BC    0294
0276:  SUBWF  xC8,F
0278:  BC    0294
027A:  INCF   xC8,F
027C:  INCF   xC7,F
027E:  MOVF   xC3,W
0280:  ADDWF  xC6,F
0282:  MOVF   xC4,W
0284:  ADDWF  xC5,F
0286:  BNC   02BA
0288:  INCF   xC6,F
028A:  BNZ   02BA
028C:  INCF   xC7,F
028E:  BNZ   02BA
0290:  INCF   xC8,F
0292:  BRA    02BA
0294:  MOVF   xC2,W
0296:  IORLW  80
0298:  SUBWF  xC7,F
029A:  BC    02B8
029C:  MOVLW  01
029E:  SUBWF  xC8,F
02A0:  BC    02B8
02A2:  INCF   xC8,F
02A4:  MOVF   xC2,W
02A6:  IORLW  80
02A8:  ADDWF  xC7,F
02AA:  MOVF   xC3,W
02AC:  ADDWF  xC6,F
02AE:  BNC   0282
02B0:  INCF   xC7,F
02B2:  BNZ   0282
02B4:  INCF   xC8,F
02B6:  BRA    0282
02B8:  BSF    03.0
02BA:  DECFSZ xC9,F
02BC:  BRA    02C0
02BE:  BRA    02D6
02C0:  BCF    FD8.0
02C2:  RLCF   xC5,F
02C4:  RLCF   xC6,F
02C6:  RLCF   xC7,F
02C8:  RLCF   xC8,F
02CA:  BCF    FD8.0
02CC:  RLCF   03,F
02CE:  RLCF   02,F
02D0:  RLCF   01,F
02D2:  RLCF   xCA,F
02D4:  BRA    024A
02D6:  BTFSS  xCA.0
02D8:  BRA    02E6
02DA:  BCF    FD8.0
02DC:  RRCF   01,F
02DE:  RRCF   02,F
02E0:  RRCF   03,F
02E2:  RRCF   xCA,F
02E4:  BRA    02EA
02E6:  DECF   00,F
02E8:  BZ    0354
02EA:  BTFSC  xCA.7
02EC:  BRA    032A
02EE:  BCF    FD8.0
02F0:  RLCF   xC5,F
02F2:  RLCF   xC6,F
02F4:  RLCF   xC7,F
02F6:  RLCF   xC8,F
02F8:  MOVF   xC4,W
02FA:  SUBWF  xC5,F
02FC:  BC    030C
02FE:  MOVLW  01
0300:  SUBWF  xC6,F
0302:  BC    030C
0304:  SUBWF  xC7,F
0306:  BC    030C
0308:  SUBWF  xC8,F
030A:  BNC   0340
030C:  MOVF   xC3,W
030E:  SUBWF  xC6,F
0310:  BC    031C
0312:  MOVLW  01
0314:  SUBWF  xC7,F
0316:  BC    031C
0318:  SUBWF  xC8,F
031A:  BNC   0340
031C:  MOVF   xC2,W
031E:  IORLW  80
0320:  SUBWF  xC7,F
0322:  BC    032A
0324:  MOVLW  01
0326:  SUBWF  xC8,F
0328:  BNC   0340
032A:  INCF   03,F
032C:  BNZ   0340
032E:  INCF   02,F
0330:  BNZ   0340
0332:  INCF   01,F
0334:  BNZ   0340
0336:  INCF   00,F
0338:  BZ    0354
033A:  RRCF   01,F
033C:  RRCF   02,F
033E:  RRCF   03,F
0340:  MOVFF  4BE,4C9
0344:  MOVF   xC2,W
0346:  XORWF  xC9,F
0348:  BTFSS  xC9.7
034A:  BRA    0350
034C:  BSF    01.7
034E:  BRA    035C
0350:  BCF    01.7
0352:  BRA    035C
0354:  CLRF   00
0356:  CLRF   01
0358:  CLRF   02
035A:  CLRF   03
035C:  MOVLB  0
035E:  RETURN 0
*
04A2:  MOVLW  80
04A4:  BTFSS  FD8.1
04A6:  BRA    04AC
04A8:  MOVLB  4
04AA:  XORWF  xC2,F
04AC:  MOVLB  4
04AE:  CLRF   xC7
04B0:  CLRF   xC8
04B2:  MOVFF  4BE,4C6
04B6:  MOVF   xC2,W
04B8:  XORWF  xC6,F
04BA:  MOVF   xBD,W
04BC:  BTFSC  FD8.2
04BE:  BRA    067E
04C0:  MOVWF  xC5
04C2:  MOVWF  00
04C4:  MOVF   xC1,W
04C6:  BTFSC  FD8.2
04C8:  BRA    0690
04CA:  SUBWF  xC5,F
04CC:  BTFSC  FD8.2
04CE:  BRA    05D6
04D0:  BNC   054E
04D2:  MOVFF  4C2,4CB
04D6:  BSF    xCB.7
04D8:  MOVFF  4C3,4CA
04DC:  MOVFF  4C4,4C9
04E0:  CLRF   xC8
04E2:  BCF    FD8.0
04E4:  RRCF   xCB,F
04E6:  RRCF   xCA,F
04E8:  RRCF   xC9,F
04EA:  RRCF   xC8,F
04EC:  DECFSZ xC5,F
04EE:  BRA    04E0
04F0:  BTFSS  xC6.7
04F2:  BRA    04FA
04F4:  BSF    xC7.0
04F6:  BRA    06B8
04F8:  BCF    xC7.0
04FA:  BCF    xC5.0
04FC:  BSF    xC7.4
04FE:  MOVLW  04
0500:  MOVWF  FEA
0502:  MOVLW  C0
0504:  MOVWF  FE9
0506:  BRA    06DE
0508:  BCF    xC7.4
050A:  BTFSC  xC6.7
050C:  BRA    0522
050E:  BTFSS  xC5.0
0510:  BRA    0538
0512:  RRCF   xCB,F
0514:  RRCF   xCA,F
0516:  RRCF   xC9,F
0518:  RRCF   xC8,F
051A:  INCF   00,F
051C:  BTFSC  FD8.2
051E:  BRA    06AE
0520:  BRA    0538
0522:  BTFSC  xCB.7
0524:  BRA    053E
0526:  BCF    FD8.0
0528:  RLCF   xC8,F
052A:  RLCF   xC9,F
052C:  RLCF   xCA,F
052E:  RLCF   xCB,F
0530:  DECF   00,F
0532:  BTFSC  FD8.2
0534:  BRA    06AE
0536:  BRA    0522
0538:  BSF    xC7.6
053A:  BRA    0616
053C:  BCF    xC7.6
053E:  MOVFF  4BE,4C6
0542:  BTFSS  xBE.7
0544:  BRA    054A
0546:  BSF    xCB.7
0548:  BRA    06A0
054A:  BCF    xCB.7
054C:  BRA    06A0
054E:  MOVFF  4C1,4C5
0552:  MOVFF  4C1,00
0556:  MOVF   xBD,W
0558:  SUBWF  xC5,F
055A:  MOVFF  4BE,4CB
055E:  BSF    xCB.7
0560:  MOVFF  4BF,4CA
0564:  MOVFF  4C0,4C9
0568:  CLRF   xC8
056A:  BCF    FD8.0
056C:  RRCF   xCB,F
056E:  RRCF   xCA,F
0570:  RRCF   xC9,F
0572:  RRCF   xC8,F
0574:  DECFSZ xC5,F
0576:  BRA    0568
0578:  BTFSS  xC6.7
057A:  BRA    0582
057C:  BSF    xC7.1
057E:  BRA    06B8
0580:  BCF    xC7.1
0582:  BCF    xC5.0
0584:  BSF    xC7.5
0586:  MOVLW  04
0588:  MOVWF  FEA
058A:  MOVLW  C4
058C:  MOVWF  FE9
058E:  BRA    06DE
0590:  BCF    xC7.5
0592:  BTFSC  xC6.7
0594:  BRA    05AA
0596:  BTFSS  xC5.0
0598:  BRA    05C0
059A:  RRCF   xCB,F
059C:  RRCF   xCA,F
059E:  RRCF   xC9,F
05A0:  RRCF   xC8,F
05A2:  INCF   00,F
05A4:  BTFSC  FD8.2
05A6:  BRA    06AE
05A8:  BRA    05C0
05AA:  BTFSC  xCB.7
05AC:  BRA    05C6
05AE:  BCF    FD8.0
05B0:  RLCF   xC8,F
05B2:  RLCF   xC9,F
05B4:  RLCF   xCA,F
05B6:  RLCF   xCB,F
05B8:  DECF   00,F
05BA:  BTFSC  FD8.2
05BC:  BRA    06AE
05BE:  BRA    05AA
05C0:  BSF    xC7.7
05C2:  BRA    0616
05C4:  BCF    xC7.7
05C6:  MOVFF  4C2,4C6
05CA:  BTFSS  xC2.7
05CC:  BRA    05D2
05CE:  BSF    xCB.7
05D0:  BRA    06A0
05D2:  BCF    xCB.7
05D4:  BRA    06A0
05D6:  MOVFF  4C2,4CB
05DA:  BSF    xCB.7
05DC:  MOVFF  4C3,4CA
05E0:  MOVFF  4C4,4C9
05E4:  BTFSS  xC6.7
05E6:  BRA    05F0
05E8:  BCF    xCB.7
05EA:  BSF    xC7.2
05EC:  BRA    06B8
05EE:  BCF    xC7.2
05F0:  CLRF   xC8
05F2:  BCF    xC5.0
05F4:  MOVLW  04
05F6:  MOVWF  FEA
05F8:  MOVLW  C0
05FA:  MOVWF  FE9
05FC:  BRA    06DE
05FE:  BTFSC  xC6.7
0600:  BRA    063A
0602:  MOVFF  4BE,4C6
0606:  BTFSS  xC5.0
0608:  BRA    0616
060A:  RRCF   xCB,F
060C:  RRCF   xCA,F
060E:  RRCF   xC9,F
0610:  RRCF   xC8,F
0612:  INCF   00,F
0614:  BZ    06AE
0616:  BTFSS  xC8.7
0618:  BRA    0630
061A:  INCF   xC9,F
061C:  BNZ   0630
061E:  INCF   xCA,F
0620:  BNZ   0630
0622:  INCF   xCB,F
0624:  BNZ   0630
0626:  RRCF   xCB,F
0628:  RRCF   xCA,F
062A:  RRCF   xC9,F
062C:  INCF   00,F
062E:  BZ    06AE
0630:  BTFSC  xC7.6
0632:  BRA    053C
0634:  BTFSC  xC7.7
0636:  BRA    05C4
0638:  BRA    0672
063A:  MOVLW  80
063C:  XORWF  xCB,F
063E:  BTFSS  xCB.7
0640:  BRA    064A
0642:  BRA    06B8
0644:  MOVFF  4C2,4C6
0648:  BRA    065E
064A:  MOVFF  4BE,4C6
064E:  MOVF   xCB,F
0650:  BNZ   065E
0652:  MOVF   xCA,F
0654:  BNZ   065E
0656:  MOVF   xC9,F
0658:  BNZ   065E
065A:  CLRF   00
065C:  BRA    06A0
065E:  BTFSC  xCB.7
0660:  BRA    0672
0662:  BCF    FD8.0
0664:  RLCF   xC8,F
0666:  RLCF   xC9,F
0668:  RLCF   xCA,F
066A:  RLCF   xCB,F
066C:  DECFSZ 00,F
066E:  BRA    065E
0670:  BRA    06AE
0672:  BTFSS  xC6.7
0674:  BRA    067A
0676:  BSF    xCB.7
0678:  BRA    06A0
067A:  BCF    xCB.7
067C:  BRA    06A0
067E:  MOVFF  4C1,00
0682:  MOVFF  4C2,4CB
0686:  MOVFF  4C3,4CA
068A:  MOVFF  4C4,4C9
068E:  BRA    06A0
0690:  MOVFF  4BD,00
0694:  MOVFF  4BE,4CB
0698:  MOVFF  4BF,4CA
069C:  MOVFF  4C0,4C9
06A0:  MOVFF  4CB,01
06A4:  MOVFF  4CA,02
06A8:  MOVFF  4C9,03
06AC:  BRA    0716
06AE:  CLRF   00
06B0:  CLRF   01
06B2:  CLRF   02
06B4:  CLRF   03
06B6:  BRA    0716
06B8:  CLRF   xC8
06BA:  COMF   xC9,F
06BC:  COMF   xCA,F
06BE:  COMF   xCB,F
06C0:  COMF   xC8,F
06C2:  INCF   xC8,F
06C4:  BNZ   06D0
06C6:  INCF   xC9,F
06C8:  BNZ   06D0
06CA:  INCF   xCA,F
06CC:  BNZ   06D0
06CE:  INCF   xCB,F
06D0:  BTFSC  xC7.0
06D2:  BRA    04F8
06D4:  BTFSC  xC7.1
06D6:  BRA    0580
06D8:  BTFSC  xC7.2
06DA:  BRA    05EE
06DC:  BRA    0644
06DE:  MOVF   FEF,W
06E0:  ADDWF  xC9,F
06E2:  BNC   06EE
06E4:  INCF   xCA,F
06E6:  BNZ   06EE
06E8:  INCF   xCB,F
06EA:  BTFSC  FD8.2
06EC:  BSF    xC5.0
06EE:  MOVF   FED,F
06F0:  MOVF   FEF,W
06F2:  ADDWF  xCA,F
06F4:  BNC   06FC
06F6:  INCF   xCB,F
06F8:  BTFSC  FD8.2
06FA:  BSF    xC5.0
06FC:  MOVF   FED,F
06FE:  MOVF   FEF,W
0700:  BTFSC  FEF.7
0702:  BRA    0706
0704:  XORLW  80
0706:  ADDWF  xCB,F
0708:  BTFSC  FD8.0
070A:  BSF    xC5.0
070C:  BTFSC  xC7.4
070E:  BRA    0508
0710:  BTFSC  xC7.5
0712:  BRA    0590
0714:  BRA    05FE
0716:  MOVLB  0
0718:  RETURN 0
*
0930:  MOVLW  8E
0932:  MOVWF  00
0934:  MOVFF  4AC,01
0938:  MOVFF  4AB,02
093C:  CLRF   03
093E:  MOVF   01,F
0940:  BNZ   0954
0942:  MOVFF  02,01
0946:  CLRF   02
0948:  MOVLW  08
094A:  SUBWF  00,F
094C:  MOVF   01,F
094E:  BNZ   0954
0950:  CLRF   00
0952:  BRA    0964
0954:  BCF    FD8.0
0956:  BTFSC  01.7
0958:  BRA    0962
095A:  RLCF   02,F
095C:  RLCF   01,F
095E:  DECF   00,F
0960:  BRA    0954
0962:  BCF    01.7
0964:  RETURN 0
0966:  MOVLB  4
0968:  MOVF   xBD,W
096A:  BTFSC  FD8.2
096C:  BRA    0A50
096E:  MOVWF  00
0970:  MOVF   xC1,W
0972:  BTFSC  FD8.2
0974:  BRA    0A50
0976:  ADDWF  00,F
0978:  BNC   0982
097A:  MOVLW  81
097C:  ADDWF  00,F
097E:  BC    0A50
0980:  BRA    098A
0982:  MOVLW  7F
0984:  SUBWF  00,F
0986:  BNC   0A50
0988:  BZ    0A50
098A:  MOVFF  4BE,4C5
098E:  MOVF   xC2,W
0990:  XORWF  xC5,F
0992:  BSF    xBE.7
0994:  BSF    xC2.7
0996:  MOVF   xC0,W
0998:  MULWF  xC4
099A:  MOVFF  FF4,4C7
099E:  MOVF   xBF,W
09A0:  MULWF  xC3
09A2:  MOVFF  FF4,03
09A6:  MOVFF  FF3,4C6
09AA:  MULWF  xC4
09AC:  MOVF   FF3,W
09AE:  ADDWF  xC7,F
09B0:  MOVF   FF4,W
09B2:  ADDWFC xC6,F
09B4:  MOVLW  00
09B6:  ADDWFC 03,F
09B8:  MOVF   xC0,W
09BA:  MULWF  xC3
09BC:  MOVF   FF3,W
09BE:  ADDWF  xC7,F
09C0:  MOVF   FF4,W
09C2:  ADDWFC xC6,F
09C4:  MOVLW  00
09C6:  CLRF   02
09C8:  ADDWFC 03,F
09CA:  ADDWFC 02,F
09CC:  MOVF   xBE,W
09CE:  MULWF  xC4
09D0:  MOVF   FF3,W
09D2:  ADDWF  xC6,F
09D4:  MOVF   FF4,W
09D6:  ADDWFC 03,F
09D8:  MOVLW  00
09DA:  ADDWFC 02,F
09DC:  MOVF   xBE,W
09DE:  MULWF  xC3
09E0:  MOVF   FF3,W
09E2:  ADDWF  03,F
09E4:  MOVF   FF4,W
09E6:  ADDWFC 02,F
09E8:  MOVLW  00
09EA:  CLRF   01
09EC:  ADDWFC 01,F
09EE:  MOVF   xC0,W
09F0:  MULWF  xC2
09F2:  MOVF   FF3,W
09F4:  ADDWF  xC6,F
09F6:  MOVF   FF4,W
09F8:  ADDWFC 03,F
09FA:  MOVLW  00
09FC:  ADDWFC 02,F
09FE:  ADDWFC 01,F
0A00:  MOVF   xBF,W
0A02:  MULWF  xC2
0A04:  MOVF   FF3,W
0A06:  ADDWF  03,F
0A08:  MOVF   FF4,W
0A0A:  ADDWFC 02,F
0A0C:  MOVLW  00
0A0E:  ADDWFC 01,F
0A10:  MOVF   xBE,W
0A12:  MULWF  xC2
0A14:  MOVF   FF3,W
0A16:  ADDWF  02,F
0A18:  MOVF   FF4,W
0A1A:  ADDWFC 01,F
0A1C:  INCF   00,F
0A1E:  BTFSC  01.7
0A20:  BRA    0A2C
0A22:  RLCF   xC6,F
0A24:  RLCF   03,F
0A26:  RLCF   02,F
0A28:  RLCF   01,F
0A2A:  DECF   00,F
0A2C:  MOVLW  00
0A2E:  BTFSS  xC6.7
0A30:  BRA    0A46
0A32:  INCF   03,F
0A34:  ADDWFC 02,F
0A36:  ADDWFC 01,F
0A38:  MOVF   01,W
0A3A:  BNZ   0A46
0A3C:  MOVF   02,W
0A3E:  BNZ   0A46
0A40:  MOVF   03,W
0A42:  BNZ   0A46
0A44:  INCF   00,F
0A46:  BTFSC  xC5.7
0A48:  BSF    01.7
0A4A:  BTFSS  xC5.7
0A4C:  BCF    01.7
0A4E:  BRA    0A58
0A50:  CLRF   00
0A52:  CLRF   01
0A54:  CLRF   02
0A56:  CLRF   03
0A58:  MOVLB  0
0A5A:  RETURN 0
*
2016:  MOVLW  8E
2018:  MOVWF  00
201A:  MOVLB  4
201C:  MOVF   x89,W
201E:  SUBWF  00,F
2020:  MOVFF  48A,02
2024:  MOVFF  48B,01
2028:  BSF    02.7
202A:  MOVF   00,F
202C:  BZ    2040
202E:  BCF    FD8.0
2030:  MOVF   02,F
2032:  BNZ   2038
2034:  MOVF   01,F
2036:  BZ    2040
2038:  RRCF   02,F
203A:  RRCF   01,F
203C:  DECFSZ 00,F
203E:  BRA    202E
2040:  BTFSS  x8A.7
2042:  BRA    204E
2044:  COMF   01,F
2046:  COMF   02,F
2048:  INCF   01,F
204A:  BTFSC  FD8.2
204C:  INCF   02,F
204E:  MOVLB  0
2050:  RETURN 0
*
220E:  DATA 1B,5B
2210:  DATA 33,33
2212:  DATA 6D,73
2214:  DATA 74,61
2216:  DATA 72,74
2218:  DATA 20,6F
221A:  DATA 66,20
221C:  DATA 69,6E
221E:  DATA 69,74
2220:  DATA 20,20
2222:  DATA 0A,0D
2224:  DATA 1B,5B
2226:  DATA 30,6D
2228:  DATA 00,00
222A:  DATA 43,61
222C:  DATA 6C,69
222E:  DATA 62,72
2230:  DATA 61,74
2232:  DATA 69,6F
2234:  DATA 6E,20
2236:  DATA 6F,66
2238:  DATA 20,47
223A:  DATA 79,72
223C:  DATA 6F,20
223E:  DATA 69,73
2240:  DATA 20,73
2242:  DATA 74,61
2244:  DATA 72,74
2246:  DATA 65,64
2248:  DATA 20,64
224A:  DATA 6F,6E
224C:  DATA 27,74
224E:  DATA 20,6D
2250:  DATA 6F,76
2252:  DATA 65,20
2254:  DATA 74,68
2256:  DATA 65,20
2258:  DATA 73,65
225A:  DATA 6E,73
225C:  DATA 6F,72
225E:  DATA 0A,0D
2260:  DATA 00,00
2262:  DATA 43,61
2264:  DATA 6C,69
2266:  DATA 62,72
2268:  DATA 61,74
226A:  DATA 69,6F
226C:  DATA 6E,20
226E:  DATA 6F,66
2270:  DATA 20,47
2272:  DATA 79,72
2274:  DATA 6F,20
2276:  DATA 69,73
2278:  DATA 20,66
227A:  DATA 69,6E
227C:  DATA 69,73
227E:  DATA 68,65
2280:  DATA 64,0A
2282:  DATA 0D,00
2284:  DATA 52,61
2286:  DATA 74,65
2288:  DATA 43,61
228A:  DATA 6C,69
228C:  DATA 62,72
228E:  DATA 61,74
2290:  DATA 69,6F
2292:  DATA 6E,50
2294:  DATA 69,74
2296:  DATA 63,68
2298:  DATA 20,3D
229A:  DATA 20,25
229C:  DATA 2E,35
229E:  DATA 66,20
22A0:  DATA 2C,20
22A2:  DATA 52,61
22A4:  DATA 74,65
22A6:  DATA 43,61
22A8:  DATA 6C,69
22AA:  DATA 62,72
22AC:  DATA 61,74
22AE:  DATA 69,6F
22B0:  DATA 6E,52
22B2:  DATA 6F,6C
22B4:  DATA 6C,20
22B6:  DATA 3D,20
22B8:  DATA 25,2E
22BA:  DATA 35,66
22BC:  DATA 20,2C
22BE:  DATA 20,52
22C0:  DATA 61,74
22C2:  DATA 65,43
22C4:  DATA 61,6C
22C6:  DATA 69,62
22C8:  DATA 72,61
22CA:  DATA 74,69
22CC:  DATA 6F,6E
22CE:  DATA 59,61
22D0:  DATA 77,20
22D2:  DATA 3D,20
22D4:  DATA 25,2E
22D6:  DATA 35,66
22D8:  DATA 20,0A
22DA:  DATA 0D,00
22DC:  DATA 79,61
22DE:  DATA 77,3D
22E0:  DATA 20,25
22E2:  DATA 64,20
22E4:  DATA 20,50
22E6:  DATA 69,74
22E8:  DATA 63,68
22EA:  DATA 20,3D
22EC:  DATA 20,25
22EE:  DATA 64,20
22F0:  DATA 20,0A
22F2:  DATA 0D,00
*
24CE:  TBLRD*+
24D0:  MOVF   FF5,F
24D2:  BZ    24EE
24D4:  MOVFF  FF6,46C
24D8:  MOVFF  FF7,46D
24DC:  MOVF   FF5,W
24DE:  BTFSS  F9E.4
24E0:  BRA    24DE
24E2:  MOVWF  FAD
24E4:  MOVFF  46C,FF6
24E8:  MOVFF  46D,FF7
24EC:  BRA    24CE
24EE:  RETURN 0
*
2680:  TBLRD*+
2682:  MOVFF  FF6,46E
2686:  MOVFF  FF7,46F
268A:  MOVF   FF5,W
268C:  BTFSS  F9E.4
268E:  BRA    268C
2690:  MOVWF  FAD
2692:  MOVFF  46E,FF6
2696:  MOVFF  46F,FF7
269A:  MOVLB  4
269C:  DECFSZ x6D,F
269E:  BRA    26A2
26A0:  BRA    26A6
26A2:  MOVLB  0
26A4:  BRA    2680
26A6:  MOVLB  0
26A8:  RETURN 0
*
2B46:  MOVLB  4
2B48:  MOVF   x78,W
2B4A:  SUBLW  B6
2B4C:  MOVWF  x78
2B4E:  CLRF   03
2B50:  MOVFF  479,47C
2B54:  BSF    x79.7
2B56:  BCF    FD8.0
2B58:  RRCF   x79,F
2B5A:  RRCF   x7A,F
2B5C:  RRCF   x7B,F
2B5E:  RRCF   03,F
2B60:  RRCF   02,F
2B62:  RRCF   01,F
2B64:  RRCF   00,F
2B66:  DECFSZ x78,F
2B68:  BRA    2B56
2B6A:  BTFSS  x7C.7
2B6C:  BRA    2B84
2B6E:  COMF   00,F
2B70:  COMF   01,F
2B72:  COMF   02,F
2B74:  COMF   03,F
2B76:  INCF   00,F
2B78:  BTFSC  FD8.2
2B7A:  INCF   01,F
2B7C:  BTFSC  FD8.2
2B7E:  INCF   02,F
2B80:  BTFSC  FD8.2
2B82:  INCF   03,F
2B84:  MOVLB  0
2B86:  GOTO   2C82 (RETURN)
2B8A:  BTFSC  FD8.1
2B8C:  BRA    2B96
2B8E:  MOVLW  04
2B90:  MOVWF  FEA
2B92:  MOVLW  80
2B94:  MOVWF  FE9
2B96:  CLRF   00
2B98:  CLRF   01
2B9A:  CLRF   02
2B9C:  CLRF   03
2B9E:  MOVLB  4
2BA0:  CLRF   x80
2BA2:  CLRF   x81
2BA4:  CLRF   x82
2BA6:  CLRF   x83
2BA8:  MOVF   x7F,W
2BAA:  IORWF  x7E,W
2BAC:  IORWF  x7D,W
2BAE:  IORWF  x7C,W
2BB0:  BZ    2C0A
2BB2:  MOVLW  20
2BB4:  MOVWF  x84
2BB6:  BCF    FD8.0
2BB8:  RLCF   x78,F
2BBA:  RLCF   x79,F
2BBC:  RLCF   x7A,F
2BBE:  RLCF   x7B,F
2BC0:  RLCF   x80,F
2BC2:  RLCF   x81,F
2BC4:  RLCF   x82,F
2BC6:  RLCF   x83,F
2BC8:  MOVF   x7F,W
2BCA:  SUBWF  x83,W
2BCC:  BNZ   2BDE
2BCE:  MOVF   x7E,W
2BD0:  SUBWF  x82,W
2BD2:  BNZ   2BDE
2BD4:  MOVF   x7D,W
2BD6:  SUBWF  x81,W
2BD8:  BNZ   2BDE
2BDA:  MOVF   x7C,W
2BDC:  SUBWF  x80,W
2BDE:  BNC   2BFE
2BE0:  MOVF   x7C,W
2BE2:  SUBWF  x80,F
2BE4:  MOVF   x7D,W
2BE6:  BTFSS  FD8.0
2BE8:  INCFSZ x7D,W
2BEA:  SUBWF  x81,F
2BEC:  MOVF   x7E,W
2BEE:  BTFSS  FD8.0
2BF0:  INCFSZ x7E,W
2BF2:  SUBWF  x82,F
2BF4:  MOVF   x7F,W
2BF6:  BTFSS  FD8.0
2BF8:  INCFSZ x7F,W
2BFA:  SUBWF  x83,F
2BFC:  BSF    FD8.0
2BFE:  RLCF   00,F
2C00:  RLCF   01,F
2C02:  RLCF   02,F
2C04:  RLCF   03,F
2C06:  DECFSZ x84,F
2C08:  BRA    2BB6
2C0A:  MOVFF  480,FEF
2C0E:  MOVFF  481,FEC
2C12:  MOVFF  482,FEC
2C16:  MOVFF  483,FEC
2C1A:  MOVLB  0
2C1C:  RETURN 0
2C1E:  MOVF   FE9,W
2C20:  MOVLB  4
2C22:  MOVWF  x70
2C24:  MOVF   x6F,W
2C26:  MOVWF  x72
2C28:  BZ    2C6E
2C2A:  CLRF   16
2C2C:  BTFSC  FF2.7
2C2E:  BSF    16.7
2C30:  BCF    FF2.7
2C32:  MOVFF  46E,4C0
2C36:  MOVFF  46D,4BF
2C3A:  MOVFF  46C,4BE
2C3E:  MOVFF  46B,4BD
2C42:  CLRF   xC4
2C44:  CLRF   xC3
2C46:  MOVLW  20
2C48:  MOVWF  xC2
2C4A:  MOVLW  82
2C4C:  MOVWF  xC1
2C4E:  MOVLB  0
2C50:  CALL   0966
2C54:  BTFSC  16.7
2C56:  BSF    FF2.7
2C58:  MOVFF  03,46E
2C5C:  MOVFF  02,46D
2C60:  MOVFF  01,46C
2C64:  MOVFF  00,46B
2C68:  MOVLB  4
2C6A:  DECFSZ x72,F
2C6C:  BRA    2C2A
2C6E:  MOVFF  46E,47B
2C72:  MOVFF  46D,47A
2C76:  MOVFF  46C,479
2C7A:  MOVFF  46B,478
2C7E:  MOVLB  0
2C80:  BRA    2B46
2C82:  MOVFF  03,46E
2C86:  MOVFF  02,46D
2C8A:  MOVFF  01,46C
2C8E:  MOVFF  00,46B
2C92:  MOVLB  4
2C94:  BTFSS  x6E.7
2C96:  BRA    2CB2
2C98:  DECF   x70,F
2C9A:  BSF    x70.5
2C9C:  COMF   x6B,F
2C9E:  COMF   x6C,F
2CA0:  COMF   x6D,F
2CA2:  COMF   x6E,F
2CA4:  INCF   x6B,F
2CA6:  BTFSC  FD8.2
2CA8:  INCF   x6C,F
2CAA:  BTFSC  FD8.2
2CAC:  INCF   x6D,F
2CAE:  BTFSC  FD8.2
2CB0:  INCF   x6E,F
2CB2:  MOVLW  3B
2CB4:  MOVWF  x77
2CB6:  MOVLW  9A
2CB8:  MOVWF  x76
2CBA:  MOVLW  CA
2CBC:  MOVWF  x75
2CBE:  CLRF   x74
2CC0:  MOVLW  0A
2CC2:  MOVWF  x72
2CC4:  MOVF   x6F,W
2CC6:  BTFSC  FD8.2
2CC8:  INCF   x70,F
2CCA:  BSF    FD8.1
2CCC:  MOVLW  04
2CCE:  MOVWF  FEA
2CD0:  MOVLW  6B
2CD2:  MOVWF  FE9
2CD4:  MOVFF  46E,47B
2CD8:  MOVFF  46D,47A
2CDC:  MOVFF  46C,479
2CE0:  MOVFF  46B,478
2CE4:  MOVFF  477,47F
2CE8:  MOVFF  476,47E
2CEC:  MOVFF  475,47D
2CF0:  MOVFF  474,47C
2CF4:  MOVLB  0
2CF6:  RCALL  2B8A
2CF8:  MOVF   01,W
2CFA:  MOVF   00,F
2CFC:  BNZ   2D24
2CFE:  MOVLB  4
2D00:  INCF   x6F,W
2D02:  SUBWF  x72,W
2D04:  BTFSS  FD8.2
2D06:  BRA    2D0C
2D08:  MOVLB  0
2D0A:  BRA    2D24
2D0C:  MOVF   x70,W
2D0E:  BZ    2D2A
2D10:  ANDLW  0F
2D12:  SUBWF  x72,W
2D14:  BZ    2D18
2D16:  BC    2D90
2D18:  BTFSC  x70.7
2D1A:  BRA    2D90
2D1C:  BTFSC  x70.6
2D1E:  BRA    2D2A
2D20:  MOVLW  20
2D22:  BRA    2D86
2D24:  MOVLW  20
2D26:  MOVLB  4
2D28:  ANDWF  x70,F
2D2A:  BTFSS  x70.5
2D2C:  BRA    2D48
2D2E:  BCF    x70.5
2D30:  MOVF   x6F,W
2D32:  BTFSS  FD8.2
2D34:  DECF   x70,F
2D36:  MOVF   00,W
2D38:  MOVWF  x70
2D3A:  MOVLW  2D
2D3C:  BTFSS  F9E.4
2D3E:  BRA    2D3C
2D40:  MOVWF  FAD
2D42:  MOVF   x70,W
2D44:  MOVWF  00
2D46:  CLRF   x70
2D48:  MOVF   x6F,W
2D4A:  SUBWF  x72,W
2D4C:  BNZ   2D64
2D4E:  MOVF   00,W
2D50:  MOVWF  x70
2D52:  MOVLW  2E
2D54:  BTFSS  F9E.4
2D56:  BRA    2D54
2D58:  MOVWF  FAD
2D5A:  MOVF   x70,W
2D5C:  MOVWF  00
2D5E:  MOVLW  20
2D60:  ANDWF  x70,F
2D62:  MOVLW  00
2D64:  MOVLW  30
2D66:  BTFSS  x70.5
2D68:  BRA    2D86
2D6A:  BCF    x70.5
2D6C:  MOVF   x6F,W
2D6E:  BTFSS  FD8.2
2D70:  DECF   x70,F
2D72:  MOVF   00,W
2D74:  MOVWF  x70
2D76:  MOVLW  2D
2D78:  BTFSS  F9E.4
2D7A:  BRA    2D78
2D7C:  MOVWF  FAD
2D7E:  MOVF   x70,W
2D80:  MOVWF  00
2D82:  CLRF   x70
2D84:  MOVLW  30
2D86:  ADDWF  00,F
2D88:  MOVF   00,W
2D8A:  BTFSS  F9E.4
2D8C:  BRA    2D8A
2D8E:  MOVWF  FAD
2D90:  BCF    FD8.1
2D92:  MOVFF  477,47B
2D96:  MOVFF  476,47A
2D9A:  MOVFF  475,479
2D9E:  MOVFF  474,478
2DA2:  CLRF   x7F
2DA4:  CLRF   x7E
2DA6:  CLRF   x7D
2DA8:  MOVLW  0A
2DAA:  MOVWF  x7C
2DAC:  MOVLB  0
2DAE:  RCALL  2B8A
2DB0:  MOVFF  03,477
2DB4:  MOVFF  02,476
2DB8:  MOVFF  01,475
2DBC:  MOVFF  00,474
2DC0:  MOVLB  4
2DC2:  DECFSZ x72,F
2DC4:  BRA    2CCA
2DC6:  MOVLB  0
2DC8:  RETURN 0
2DCA:  MOVLB  4
2DCC:  MOVF   x74,W
2DCE:  CLRF   01
2DD0:  SUBWF  x73,W
2DD2:  BC    2DDA
2DD4:  MOVFF  473,00
2DD8:  BRA    2DF2
2DDA:  CLRF   00
2DDC:  MOVLW  08
2DDE:  MOVWF  x75
2DE0:  RLCF   x73,F
2DE2:  RLCF   00,F
2DE4:  MOVF   x74,W
2DE6:  SUBWF  00,W
2DE8:  BTFSC  FD8.0
2DEA:  MOVWF  00
2DEC:  RLCF   01,F
2DEE:  DECFSZ x75,F
2DF0:  BRA    2DE0
2DF2:  MOVLB  0
2DF4:  RETURN 0
2DF6:  MOVLW  20
2DF8:  MOVLB  4
2DFA:  BTFSS  x6E.4
2DFC:  MOVLW  30
2DFE:  MOVWF  x6F
2E00:  MOVFF  46D,00
2E04:  BTFSS  x6D.7
2E06:  BRA    2E18
2E08:  COMF   00,F
2E0A:  INCF   00,F
2E0C:  MOVFF  00,46D
2E10:  MOVLW  2D
2E12:  MOVWF  x6F
2E14:  BSF    x6E.7
2E16:  BSF    x6E.0
2E18:  MOVF   01,W
2E1A:  MOVFF  46D,473
2E1E:  MOVLW  64
2E20:  MOVWF  x74
2E22:  MOVLB  0
2E24:  RCALL  2DCA
2E26:  MOVFF  00,46D
2E2A:  MOVLW  30
2E2C:  ADDWF  01,W
2E2E:  MOVLB  4
2E30:  MOVWF  x70
2E32:  MOVFF  46D,473
2E36:  MOVLW  0A
2E38:  MOVWF  x74
2E3A:  MOVLB  0
2E3C:  RCALL  2DCA
2E3E:  MOVLW  30
2E40:  ADDWF  00,W
2E42:  MOVLB  4
2E44:  MOVWF  x72
2E46:  MOVLW  30
2E48:  ADDWF  01,W
2E4A:  MOVWF  x71
2E4C:  MOVFF  46F,00
2E50:  MOVLW  30
2E52:  SUBWF  x70,W
2E54:  BZ    2E5E
2E56:  BSF    x6E.1
2E58:  BTFSC  x6E.7
2E5A:  BSF    x6E.2
2E5C:  BRA    2E82
2E5E:  MOVFF  46F,470
2E62:  MOVLW  20
2E64:  MOVWF  x6F
2E66:  MOVLW  30
2E68:  SUBWF  x71,W
2E6A:  BZ    2E74
2E6C:  BSF    x6E.0
2E6E:  BTFSC  x6E.7
2E70:  BSF    x6E.1
2E72:  BRA    2E82
2E74:  BTFSS  FD8.2
2E76:  BSF    x6E.0
2E78:  BNZ   2E82
2E7A:  MOVFF  470,471
2E7E:  MOVLW  20
2E80:  MOVWF  x70
2E82:  BTFSC  x6E.2
2E84:  BRA    2E90
2E86:  BTFSC  x6E.1
2E88:  BRA    2E98
2E8A:  BTFSC  x6E.0
2E8C:  BRA    2EA0
2E8E:  BRA    2EA8
2E90:  MOVF   x6F,W
2E92:  BTFSS  F9E.4
2E94:  BRA    2E92
2E96:  MOVWF  FAD
2E98:  MOVF   x70,W
2E9A:  BTFSS  F9E.4
2E9C:  BRA    2E9A
2E9E:  MOVWF  FAD
2EA0:  MOVF   x71,W
2EA2:  BTFSS  F9E.4
2EA4:  BRA    2EA2
2EA6:  MOVWF  FAD
2EA8:  MOVF   x72,W
2EAA:  BTFSS  F9E.4
2EAC:  BRA    2EAA
2EAE:  MOVWF  FAD
2EB0:  MOVLB  0
2EB2:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
*
24A6:  MOVLW  04
24A8:  MOVWF  FEA
24AA:  MOVLW  6F
24AC:  MOVWF  FE9
24AE:  MOVF   FEF,W
24B0:  BZ    24CC
24B2:  MOVLW  02
24B4:  MOVWF  01
24B6:  CLRF   00
24B8:  DECFSZ 00,F
24BA:  BRA    24B8
24BC:  DECFSZ 01,F
24BE:  BRA    24B6
24C0:  MOVLW  97
24C2:  MOVWF  00
24C4:  DECFSZ 00,F
24C6:  BRA    24C4
24C8:  DECFSZ FEF,F
24CA:  BRA    24B2
24CC:  RETURN 0
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
*
00CA:  BCF    FC6.7
00CC:  BCF    F9E.3
00CE:  MOVFF  4B9,FC9
00D2:  MOVLW  02
00D4:  BTFSC  FC6.7
00D6:  BRA    00E2
00D8:  BTFSS  F9E.3
00DA:  BRA    00D8
00DC:  MOVLW  00
00DE:  BTFSC  FC5.6
00E0:  MOVLW  01
00E2:  MOVWF  01
00E4:  RETURN 0
00E6:  BCF    FC6.6
00E8:  BSF    FC5.3
00EA:  BTFSC  FC5.3
00EC:  BRA    00EA
00EE:  BTFSC  00.0
00F0:  BCF    FC5.5
00F2:  BTFSS  00.0
00F4:  BSF    FC5.5
00F6:  BSF    FC5.4
00F8:  BTFSC  FC5.4
00FA:  BRA    00F8
00FC:  MOVFF  FC9,01
0100:  RETURN 0
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
....................  
.................... #include "mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
.................... #include "mpu9250_config.h" 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_CONFIG_H 
.................... #define	MPU9250_CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_CONFIG_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // ±2 g 
.................... #define AFS_4G          0x08 // ±4 g 
.................... #define AFS_8G          0x10 // ±8 g 
.................... #define AFS_16G         0x18 // ±16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // ±250 dps 
.................... #define GFS_500         0x08 // ±500 dps 
.................... #define GFS_1000        0x10 // ±1000 dps 
.................... #define GFS_2000        0x18 // ±2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
.................... #include "mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... #include "mpu9250_config.h" 
.................... #include "mpu9250_private.h" 
.................... #include "mpu9250_interface.h" 
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]); 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[],float magData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]); 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[],float magData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // ±2 g 
.................... #define AFS_4G          0x08 // ±4 g 
.................... #define AFS_8G          0x10 // ±8 g 
.................... #define AFS_16G         0x18 // ±16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // ±250 dps 
.................... #define GFS_500         0x08 // ±500 dps 
.................... #define GFS_1000        0x10 // ±1000 dps 
.................... #define GFS_2000        0x18 // ±2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
.................... #include"SSD1780OLED_interface.h" 
.................... /*  
....................  * File:   SSD1780OLED_interface.h 
....................  * Author: mohamed 
....................  * 
....................  * Created on January 3, 2024, 4:23 AM 
....................  */ 
....................  
.................... #ifndef SSD1780OLED_INTERFACE_H 
.................... #define	SSD1780OLED_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... typedef enum {SendData,SendCommand}SendByte_T;     
....................  
.................... typedef enum {PageAddressing,HorizontalAddressing,VerticalAddressing}OledScreenAdressing_T;     
....................  
....................  
.................... void VOledInit();  
.................... #inline 
.................... uint8_t VOledSend(uint8_t ucSendByte,SendByte_T xByteType);     
.................... uint8_t VOledSendCommand(uint8_t ucCommand);     
.................... void VOledSendData(uint8_t ucData);     
.................... void VOledSetAddressingMode(OledScreenAdressing_T xScreenAdressing); 
.................... void VOledSetAddressSpace( 
....................                     uint16_t usColumnAddressStart,uint16_t usColumnAddressEnd, 
....................                     uint16_t usPageAddressStart,uint16_t usPageAddressEnd); 
.................... void VOledDrawPixel(uint8_t x, uint8_t y,uint8_t ucColor); 
.................... void VOledDisplay(); 
.................... void VOledFillScreen(uint8_t ucColor); 
.................... void VOled_DrawChar(uint16_t x, uint16_t y, uint8_t c, uint8_t size = 1); 
.................... #inline  
.................... void VOled_DrawStringFast(uint16_t x, uint16_t y, uint8_t* ptrString); 
.................... void VOled_Print(uint16_t x, uint16_t y, uint8_t* ptrString, uint8_t size = 1); 
.................... void VOled_writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, 
....................                              uint16_t color); 
.................... void VOledFillRect(int16_t x0, int16_t y0, int16_t x1, int16_t y1, 
....................         uint8_t ucColor); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* SSD1780OLED_INTERFACE_H */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... static void imu_update(void); 
.................... // Declare variables to store the sensor values 
.................... float gyro[3] = {0.0, 0.0, 0.0} ; 
.................... float mag[3] = {0.0, 0.0, 0.0}   ; 
.................... float accel[3] = {0.0, 0.0, 0.0}    ; 
....................  
.................... RateCalibration_t RateCalibration = {0.0, 0.0, 0.0} ; 
.................... Angle_t Angle = {0.0, 0.0, 0.0} ; 
....................  
.................... float KalmanAngleRoll=0 ; 
.................... int KalmanUncertaintyAngleRoll=2*2; 
.................... float KalmanAnglePitch=0  ; 
.................... int KalmanUncertaintyAnglePitch=2*2; 
.................... float Kalman1DOutput[]={0,0};       //angle predict, angle uncertainty predict 
....................  
.................... #INT_TIMER2 
.................... static void imu_update(void) 
.................... { 
....................        mpu9250_read_gyro(gyro); 
*
2052:  MOVLB  4
2054:  CLRF   x8A
2056:  MOVLW  1D
2058:  MOVWF  x89
205A:  MOVLB  0
205C:  CALL   0360
....................        mpu9250_calculate_angles(&Angle,accel,mag); 
2060:  MOVLB  4
2062:  CLRF   x8A
2064:  MOVLW  4D
2066:  MOVWF  x89
2068:  CLRF   x8C
206A:  MOVLW  35
206C:  MOVWF  x8B
206E:  CLRF   x8E
2070:  MOVLW  29
2072:  MOVWF  x8D
2074:  MOVLB  0
2076:  GOTO   14DE
....................  
....................        kalman_1d(KalmanAngleRoll,KalmanUncertaintyAngleRoll,gyro[0] - RateCalibration.roll,Angle.roll,Kalman1DOutput); 
207A:  MOVLB  4
207C:  CLRF   xAC
207E:  MOVFF  5D,4AB
2082:  MOVLB  0
2084:  CALL   0930
2088:  MOVFF  03,48C
208C:  MOVFF  02,48B
2090:  MOVFF  01,48A
2094:  MOVFF  00,489
2098:  BSF    FD8.1
209A:  MOVFF  20,4C0
209E:  MOVFF  1F,4BF
20A2:  MOVFF  1E,4BE
20A6:  MOVFF  1D,4BD
20AA:  MOVFF  48,4C4
20AE:  MOVFF  47,4C3
20B2:  MOVFF  46,4C2
20B6:  MOVFF  45,4C1
20BA:  CALL   04A2
20BE:  MOVFF  03,490
20C2:  MOVFF  02,48F
20C6:  MOVFF  01,48E
20CA:  MOVFF  00,48D
20CE:  MOVFF  5C,494
20D2:  MOVFF  5B,493
20D6:  MOVFF  5A,492
20DA:  MOVFF  59,491
20DE:  MOVFF  48C,498
20E2:  MOVFF  48B,497
20E6:  MOVFF  48A,496
20EA:  MOVFF  489,495
20EE:  MOVFF  03,49C
20F2:  MOVFF  02,49B
20F6:  MOVFF  01,49A
20FA:  MOVFF  00,499
20FE:  MOVFF  54,4A0
2102:  MOVFF  53,49F
2106:  MOVFF  52,49E
210A:  MOVFF  51,49D
210E:  MOVLB  4
2110:  CLRF   xA2
2112:  MOVLW  63
2114:  MOVWF  xA1
2116:  MOVLB  0
2118:  RCALL  1D9E
....................  
....................        KalmanAngleRoll=Kalman1DOutput[0]; 
211A:  MOVFF  66,5C
211E:  MOVFF  65,5B
2122:  MOVFF  64,5A
2126:  MOVFF  63,59
....................        KalmanUncertaintyAngleRoll=Kalman1DOutput[1] ; 
212A:  MOVFF  6A,48C
212E:  MOVFF  69,48B
2132:  MOVFF  68,48A
2136:  MOVFF  67,489
213A:  RCALL  2016
213C:  MOVFF  01,5D
....................        kalman_1d(KalmanAnglePitch,KalmanUncertaintyAnglePitch,gyro[1] - RateCalibration.pitch ,Angle.pitch,Kalman1DOutput); 
2140:  MOVLB  4
2142:  CLRF   xAC
2144:  MOVFF  62,4AB
2148:  MOVLB  0
214A:  CALL   0930
214E:  MOVFF  03,48C
2152:  MOVFF  02,48B
2156:  MOVFF  01,48A
215A:  MOVFF  00,489
215E:  BSF    FD8.1
2160:  MOVFF  24,4C0
2164:  MOVFF  23,4BF
2168:  MOVFF  22,4BE
216C:  MOVFF  21,4BD
2170:  MOVFF  44,4C4
2174:  MOVFF  43,4C3
2178:  MOVFF  42,4C2
217C:  MOVFF  41,4C1
2180:  CALL   04A2
2184:  MOVFF  03,490
2188:  MOVFF  02,48F
218C:  MOVFF  01,48E
2190:  MOVFF  00,48D
2194:  MOVFF  61,494
2198:  MOVFF  60,493
219C:  MOVFF  5F,492
21A0:  MOVFF  5E,491
21A4:  MOVFF  48C,498
21A8:  MOVFF  48B,497
21AC:  MOVFF  48A,496
21B0:  MOVFF  489,495
21B4:  MOVFF  03,49C
21B8:  MOVFF  02,49B
21BC:  MOVFF  01,49A
21C0:  MOVFF  00,499
21C4:  MOVFF  50,4A0
21C8:  MOVFF  4F,49F
21CC:  MOVFF  4E,49E
21D0:  MOVFF  4D,49D
21D4:  MOVLB  4
21D6:  CLRF   xA2
21D8:  MOVLW  63
21DA:  MOVWF  xA1
21DC:  MOVLB  0
21DE:  RCALL  1D9E
....................  
....................        KalmanAnglePitch=Kalman1DOutput[0]; 
21E0:  MOVFF  66,61
21E4:  MOVFF  65,60
21E8:  MOVFF  64,5F
21EC:  MOVFF  63,5E
....................        KalmanUncertaintyAnglePitch=Kalman1DOutput[1]; 
21F0:  MOVFF  6A,48C
21F4:  MOVFF  69,48B
21F8:  MOVFF  68,48A
21FC:  MOVFF  67,489
2200:  RCALL  2016
2202:  MOVFF  01,62
....................         
....................        clear_interrupt(INT_TIMER2); 
2206:  BCF    F9E.1
2208:  BCF    F9E.1
220A:  GOTO   0054
.................... } 
....................  
....................  
.................... void i2c_reset() 
.................... { 
....................  
.................... output_high(PIN_B0); 
.................... for (int i = 0; i < 10; i++)  
....................     { //9nth cycle acts as NACK 
....................         output_high(PIN_B1); 
....................         delay_us(5); 
....................          output_low(PIN_B1); 
....................         delay_us(5); 
....................     } 
....................   output_low(PIN_B0); 
....................   delay_us(5); 
....................   output_high(PIN_B1); 
....................   delay_us(5); 
....................   output_high(PIN_B0); 
....................   delay_us(5); 
....................    
....................   output_float(PIN_B1);                           // SCL 
....................   output_float(PIN_B0);                           // SDA 
....................   i2c_init(1); 
....................  
.................... } 
....................  
....................  
.................... void main() { 
*
2EB4:  CLRF   FF8
2EB6:  BCF    FD0.7
2EB8:  BSF    07.7
2EBA:  BSF    FB8.3
2EBC:  MOVLW  10
2EBE:  MOVWF  FAF
2EC0:  MOVLW  00
2EC2:  MOVWF  FB0
2EC4:  MOVLW  A6
2EC6:  MOVWF  FAC
2EC8:  MOVLW  90
2ECA:  MOVWF  FAB
2ECC:  BSF    F93.1
2ECE:  BSF    F93.0
2ED0:  MOVLW  04
2ED2:  MOVWF  FC8
2ED4:  MOVLW  28
2ED6:  MOVWF  FC6
2ED8:  BCF    FC7.7
2EDA:  BCF    FC7.6
2EDC:  BSF    FC7.6
2EDE:  CLRF   5C
2EE0:  CLRF   5B
2EE2:  CLRF   5A
2EE4:  CLRF   59
2EE6:  MOVLW  04
2EE8:  MOVWF  5D
2EEA:  CLRF   x61
2EEC:  CLRF   x60
2EEE:  CLRF   5F
2EF0:  CLRF   5E
2EF2:  MOVWF  x62
2EF4:  BRA    2F26
2EF6:  DATA 02,00
2EF8:  DATA 17,00
2EFA:  DATA 00,01
2EFC:  DATA 0F,B4
2EFE:  DATA 07,FF
2F00:  DATA 40,6B
2F02:  DATA 00,FF
2F04:  DATA C0,00
2F06:  DATA FF,C0
2F08:  DATA 00,FF
2F0A:  DATA C0,00
2F0C:  DATA 04,80
2F0E:  DATA 00,00
2F10:  DATA 00,00
2F12:  DATA 3C,40
2F14:  DATA 1D,00
2F16:  DATA 08,40
2F18:  DATA 63,00
2F1A:  DATA 02,00
2F1C:  DATA 17,00
2F1E:  DATA 00,02
2F20:  DATA 00,17
2F22:  DATA 00,00
2F24:  DATA 00,00
2F26:  MOVLW  00
2F28:  MOVWF  FF8
2F2A:  MOVLW  2E
2F2C:  MOVWF  FF7
2F2E:  MOVLW  F6
2F30:  MOVWF  FF6
2F32:  TBLRD*+
2F34:  MOVF   FF5,W
2F36:  MOVWF  00
2F38:  XORLW  00
2F3A:  BZ    2F62
2F3C:  TBLRD*+
2F3E:  MOVF   FF5,W
2F40:  MOVWF  01
2F42:  BTFSC  FE8.7
2F44:  BRA    2F50
2F46:  ANDLW  0F
2F48:  MOVWF  FEA
2F4A:  TBLRD*+
2F4C:  MOVFF  FF5,FE9
2F50:  BTFSC  01.6
2F52:  TBLRD*+
2F54:  BTFSS  01.6
2F56:  TBLRD*+
2F58:  MOVFF  FF5,FEE
2F5C:  DCFSNZ 00,F
2F5E:  BRA    2F32
2F60:  BRA    2F54
2F62:  CLRF   FF8
....................      
....................      
....................      
....................   output_float(PIN_B1);                           // SCL 
2F64:  BSF    F93.1
....................   output_float(PIN_B0);                           // SDA 
2F66:  BSF    F93.0
....................  
....................     delay_ms(500); 
2F68:  MOVLW  02
2F6A:  MOVLB  4
2F6C:  MOVWF  x6B
2F6E:  MOVLW  FA
2F70:  MOVWF  x6F
2F72:  MOVLB  0
2F74:  CALL   24A6
2F78:  MOVLB  4
2F7A:  DECFSZ x6B,F
2F7C:  BRA    2F6E
....................  
....................     printf(ANSI_COLOR_YELLOW"start of init  \n\r"ANSI_COLOR_RESET ); 
2F7E:  MOVLW  0E
2F80:  MOVWF  FF6
2F82:  MOVLW  22
2F84:  MOVWF  FF7
2F86:  MOVLB  0
2F88:  CALL   24CE
....................      
....................     mpu9250_init();                                 // Init the MPU9250 
2F8C:  GOTO   2542
....................  
....................     mpu9250_print_initRegisters() ;                  // Print the registers of the MPU9250 
2F90:  GOTO   26F0
....................     printf("Calibration of Gyro is started don't move the sensor\n\r"); 
2F94:  MOVLW  2A
2F96:  MOVWF  FF6
2F98:  MOVLW  22
2F9A:  MOVWF  FF7
2F9C:  CALL   24CE
....................     delay_ms(2000); 
2FA0:  MOVLW  08
2FA2:  MOVLB  4
2FA4:  MOVWF  x6B
2FA6:  MOVLW  FA
2FA8:  MOVWF  x6F
2FAA:  MOVLB  0
2FAC:  CALL   24A6
2FB0:  MOVLB  4
2FB2:  DECFSZ x6B,F
2FB4:  BRA    2FA6
....................     mpu9250_gyro_calibration(&RateCalibration);     // Calibrate the gyro 
2FB6:  CLRF   x6C
2FB8:  MOVLW  41
2FBA:  MOVWF  x6B
2FBC:  MOVLB  0
2FBE:  BRA    28EC
....................     printf("Calibration of Gyro is finished\n\r"); 
2FC0:  MOVLW  62
2FC2:  MOVWF  FF6
2FC4:  MOVLW  22
2FC6:  MOVWF  FF7
2FC8:  CALL   24CE
....................     printf("RateCalibrationPitch = %.5f , RateCalibrationRoll = %.5f , RateCalibrationYaw = %.5f \n\r",RateCalibration.pitch,RateCalibration.roll,RateCalibration.yaw); 
2FCC:  MOVLW  84
2FCE:  MOVWF  FF6
2FD0:  MOVLW  22
2FD2:  MOVWF  FF7
2FD4:  MOVLW  17
2FD6:  MOVLB  4
2FD8:  MOVWF  x6D
2FDA:  MOVLB  0
2FDC:  CALL   2680
2FE0:  MOVLW  89
2FE2:  MOVWF  FE9
2FE4:  MOVFF  44,46E
2FE8:  MOVFF  43,46D
2FEC:  MOVFF  42,46C
2FF0:  MOVFF  41,46B
2FF4:  MOVLW  05
2FF6:  MOVLB  4
2FF8:  MOVWF  x6F
2FFA:  MOVLB  0
2FFC:  RCALL  2C1E
2FFE:  MOVLW  9F
3000:  MOVWF  FF6
3002:  MOVLW  22
3004:  MOVWF  FF7
3006:  MOVLW  19
3008:  MOVLB  4
300A:  MOVWF  x6D
300C:  MOVLB  0
300E:  CALL   2680
3012:  MOVLW  89
3014:  MOVWF  FE9
3016:  MOVFF  48,46E
301A:  MOVFF  47,46D
301E:  MOVFF  46,46C
3022:  MOVFF  45,46B
3026:  MOVLW  05
3028:  MOVLB  4
302A:  MOVWF  x6F
302C:  MOVLB  0
302E:  RCALL  2C1E
3030:  MOVLW  BC
3032:  MOVWF  FF6
3034:  MOVLW  22
3036:  MOVWF  FF7
3038:  MOVLW  18
303A:  MOVLB  4
303C:  MOVWF  x6D
303E:  MOVLB  0
3040:  CALL   2680
3044:  MOVLW  89
3046:  MOVWF  FE9
3048:  MOVFF  4C,46E
304C:  MOVFF  4B,46D
3050:  MOVFF  4A,46C
3054:  MOVFF  49,46B
3058:  MOVLW  05
305A:  MOVLB  4
305C:  MOVWF  x6F
305E:  MOVLB  0
3060:  RCALL  2C1E
3062:  MOVLW  D8
3064:  MOVWF  FF6
3066:  MOVLW  22
3068:  MOVWF  FF7
306A:  MOVLW  03
306C:  MOVLB  4
306E:  MOVWF  x6D
3070:  MOVLB  0
3072:  CALL   2680
....................  
....................  
....................    // Declare a variable to store the loop counter 
....................  
....................     enable_interrupts(GLOBAL); 
3076:  MOVLW  C0
3078:  IORWF  FF2,F
....................     setup_timer_2(T2_DIV_BY_16, 255, 1); 
307A:  MOVLW  00
307C:  IORLW  06
307E:  MOVWF  FCA
3080:  MOVLW  FF
3082:  MOVWF  FCB
....................     clear_interrupt(INT_TIMER2); 
3084:  BCF    F9E.1
....................     enable_interrupts(INT_TIMER2); 
3086:  BSF    F9D.1
3088:  CLRF   16
308A:  BTFSC  FF2.7
308C:  BSF    16.7
308E:  BCF    FF2.7
....................     // Loop forever 
....................      while (1) 
....................      { 
....................       printf("yaw= %d  Pitch = %d  \n\r",  (int)Angle.yaw,(int) KalmanAnglePitch); 
3090:  MOVFF  58,48C
3094:  MOVFF  57,48B
3098:  MOVFF  56,48A
309C:  MOVFF  55,489
30A0:  CALL   2016
30A4:  BTFSC  16.7
30A6:  BSF    FF2.7
30A8:  MOVFF  01,46B
30AC:  CLRF   16
30AE:  BTFSC  FF2.7
30B0:  BSF    16.7
30B2:  BCF    FF2.7
30B4:  MOVFF  61,48C
30B8:  MOVFF  60,48B
30BC:  MOVFF  5F,48A
30C0:  MOVFF  5E,489
30C4:  CALL   2016
30C8:  BTFSC  16.7
30CA:  BSF    FF2.7
30CC:  MOVFF  01,46C
30D0:  MOVLW  DC
30D2:  MOVWF  FF6
30D4:  MOVLW  22
30D6:  MOVWF  FF7
30D8:  MOVLW  05
30DA:  MOVLB  4
30DC:  MOVWF  x6D
30DE:  MOVLB  0
30E0:  CALL   2680
30E4:  MOVFF  46B,46D
30E8:  MOVLW  18
30EA:  MOVLB  4
30EC:  MOVWF  x6E
30EE:  MOVLB  0
30F0:  RCALL  2DF6
30F2:  MOVLW  E3
30F4:  MOVWF  FF6
30F6:  MOVLW  22
30F8:  MOVWF  FF7
30FA:  MOVLW  0A
30FC:  MOVLB  4
30FE:  MOVWF  x6D
3100:  MOVLB  0
3102:  CALL   2680
3106:  MOVFF  46C,46D
310A:  MOVLW  18
310C:  MOVLB  4
310E:  MOVWF  x6E
3110:  MOVLB  0
3112:  RCALL  2DF6
3114:  MOVLW  EF
3116:  MOVWF  FF6
3118:  MOVLW  22
311A:  MOVWF  FF7
311C:  MOVLW  04
311E:  MOVLB  4
3120:  MOVWF  x6D
3122:  MOVLB  0
3124:  CALL   2680
3128:  BRA    3088
....................         
....................      } 
.................... } 
....................  
312A:  SLEEP 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #import(file="build/default/production/SSD1780OLED_program.o") 
.................... /*  
....................  * File:   SSD17890OLED.c 
....................  * Author: Mohamed 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
.................... #include"configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
....................  
.................... #list 
....................  
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
.................... #include"SSD1780OLED_config.h" 
.................... /*  
....................  * File:   SSD1780OLED_config.h 
....................  * Author: mohamed 
....................  * 
....................  * Created on January 3, 2024, 4:23 AM 
....................  */ 
....................  
.................... #ifndef SSD1780OLED_CONFIG_H 
.................... #define	SSD1780OLED_CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #define SSD1780OLED_Adress 0x78 
....................      
.................... #define SSD1780OLED_ControlByteCommand 0b00 
.................... #define SSD1780OLED_ControlByteData 0b01 
....................      
....................      
.................... #define SSD1780OLED_DisplayON 0xAF 
.................... #define SSD1780OLED_DisplayOFF 0xAE 
....................  
.................... #define SSD1780OLED_SetMultiplexRatio 0xA8 
....................  
.................... #define SSD1780OLED_SetDisplayOffset 0xD3 
....................  
....................  
.................... #define SSD1780OLED_SetDisplayStartLine 0x40       
....................  
....................      
.................... #define SSD1780OLED_SetSegmentRemap 0xA0       
....................      
.................... #define SSD1780OLED_SetCOMOutputScanDirection 0xC0 
....................      
.................... #define SSD1780OLED_SetCOMPinsHardwareConfiguration 0xDA 
....................      
.................... #define SSD1780OLED_SetContrastControl 0x81 
.................... #define SSD1780OLED_EntireDisplayON 0xA4 
....................  
.................... #define SSD1780OLED_SetNormalDisplayMode 0xA6    
....................      
.................... #define SSD1780OLED_SetDisplayClockDivideRatio 0xD5   
....................      
.................... #define SSD1780OLED_EnableChargePumpRegulator 0x8D     
....................  
....................      
....................      
.................... #define SSD1780OLED_LCDHEIGHT 64 
.................... #define SSD1780OLED_LCDWIDTH 128 
....................      
....................  
.................... #define SSD1780OLED_SetColumnAddress 0x21    
.................... #define SSD1780OLED_SetPageAddress 0x22   
....................     
....................   
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* SSD1780OLED_CONFIG_H */ 
....................  
....................  
.................... #include"SSD1780OLED_interface.h" 
.................... /*  
....................  * File:   SSD1780OLED_interface.h 
....................  * Author: mohamed 
....................  * 
....................  * Created on January 3, 2024, 4:23 AM 
....................  */ 
....................  
.................... #ifndef SSD1780OLED_INTERFACE_H 
.................... #define	SSD1780OLED_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... typedef enum {SendData,SendCommand}SendByte_T;     
....................  
.................... typedef enum {PageAddressing,HorizontalAddressing,VerticalAddressing}OledScreenAdressing_T;     
....................  
....................  
.................... void VOledInit();  
.................... #inline 
.................... uint8_t VOledSend(uint8_t ucSendByte,SendByte_T xByteType);     
.................... uint8_t VOledSendCommand(uint8_t ucCommand);     
.................... void VOledSendData(uint8_t ucData);     
.................... void VOledSetAddressingMode(OledScreenAdressing_T xScreenAdressing); 
.................... void VOledSetAddressSpace( 
....................                     uint16_t usColumnAddressStart,uint16_t usColumnAddressEnd, 
....................                     uint16_t usPageAddressStart,uint16_t usPageAddressEnd); 
.................... void VOledDrawPixel(uint8_t x, uint8_t y,uint8_t ucColor); 
.................... void VOledDisplay(); 
.................... void VOledFillScreen(uint8_t ucColor); 
.................... void VOled_DrawChar(uint16_t x, uint16_t y, uint8_t c, uint8_t size = 1); 
.................... #inline  
.................... void VOled_DrawStringFast(uint16_t x, uint16_t y, uint8_t* ptrString); 
.................... void VOled_Print(uint16_t x, uint16_t y, uint8_t* ptrString, uint8_t size = 1); 
.................... void VOled_writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, 
....................                              uint16_t color); 
.................... void VOledFillRect(int16_t x0, int16_t y0, int16_t x1, int16_t y1, 
....................         uint8_t ucColor); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* SSD1780OLED_INTERFACE_H */ 
....................  
....................  
....................  
.................... // the size of screen is 128*64  
.................... // to fill the screen you need 1024 loop 
....................  
.................... rom const char Font[] = { 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x5F, 0x00, 0x00, 
.................... 0x00, 0x07, 0x00, 0x07, 0x00, 
.................... 0x14, 0x7F, 0x14, 0x7F, 0x14, 
.................... 0x24, 0x2A, 0x7F, 0x2A, 0x12, 
.................... 0x23, 0x13, 0x08, 0x64, 0x62, 
.................... 0x36, 0x49, 0x56, 0x20, 0x50, 
.................... 0x00, 0x08, 0x07, 0x03, 0x00, 
.................... 0x00, 0x1C, 0x22, 0x41, 0x00, 
.................... 0x00, 0x41, 0x22, 0x1C, 0x00, 
.................... 0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 
.................... 0x08, 0x08, 0x3E, 0x08, 0x08, 
.................... 0x00, 0x80, 0x70, 0x30, 0x00, 
.................... 0x08, 0x08, 0x08, 0x08, 0x08, 
.................... 0x00, 0x00, 0x60, 0x60, 0x00, 
.................... 0x20, 0x10, 0x08, 0x04, 0x02, 
.................... 0x3E, 0x51, 0x49, 0x45, 0x3E, 
.................... 0x00, 0x42, 0x7F, 0x40, 0x00, 
.................... 0x72, 0x49, 0x49, 0x49, 0x46, 
.................... 0x21, 0x41, 0x49, 0x4D, 0x33, 
.................... 0x18, 0x14, 0x12, 0x7F, 0x10, 
.................... 0x27, 0x45, 0x45, 0x45, 0x39, 
.................... 0x3C, 0x4A, 0x49, 0x49, 0x31, 
.................... 0x41, 0x21, 0x11, 0x09, 0x07, 
.................... 0x36, 0x49, 0x49, 0x49, 0x36, 
.................... 0x46, 0x49, 0x49, 0x29, 0x1E, 
.................... 0x00, 0x00, 0x14, 0x00, 0x00, 
.................... 0x00, 0x40, 0x34, 0x00, 0x00, 
.................... 0x00, 0x08, 0x14, 0x22, 0x41, 
.................... 0x14, 0x14, 0x14, 0x14, 0x14, 
.................... 0x00, 0x41, 0x22, 0x14, 0x08, 
.................... 0x02, 0x01, 0x59, 0x09, 0x06, 
.................... 0x3E, 0x41, 0x5D, 0x59, 0x4E, 
.................... 0x7C, 0x12, 0x11, 0x12, 0x7C, 
.................... 0x7F, 0x49, 0x49, 0x49, 0x36, 
.................... 0x3E, 0x41, 0x41, 0x41, 0x22, 
.................... 0x7F, 0x41, 0x41, 0x41, 0x3E, 
.................... 0x7F, 0x49, 0x49, 0x49, 0x41, 
.................... 0x7F, 0x09, 0x09, 0x09, 0x01, 
.................... 0x3E, 0x41, 0x41, 0x51, 0x73, 
.................... 0x7F, 0x08, 0x08, 0x08, 0x7F, 
.................... 0x00, 0x41, 0x7F, 0x41, 0x00, 
.................... 0x20, 0x40, 0x41, 0x3F, 0x01, 
.................... 0x7F, 0x08, 0x14, 0x22, 0x41, 
.................... 0x7F, 0x40, 0x40, 0x40, 0x40, 
.................... 0x7F, 0x02, 0x1C, 0x02, 0x7F, 
.................... 0x7F, 0x04, 0x08, 0x10, 0x7F, 
.................... 0x3E, 0x41, 0x41, 0x41, 0x3E, 
.................... 0x7F, 0x09, 0x09, 0x09, 0x06, 
.................... 0x3E, 0x41, 0x51, 0x21, 0x5E, 
.................... 0x7F, 0x09, 0x19, 0x29, 0x46 
.................... }; 
.................... rom const char Font2[] = { 
.................... 0x26, 0x49, 0x49, 0x49, 0x32, 
.................... 0x03, 0x01, 0x7F, 0x01, 0x03, 
.................... 0x3F, 0x40, 0x40, 0x40, 0x3F, 
.................... 0x1F, 0x20, 0x40, 0x20, 0x1F, 
.................... 0x3F, 0x40, 0x38, 0x40, 0x3F, 
.................... 0x63, 0x14, 0x08, 0x14, 0x63, 
.................... 0x03, 0x04, 0x78, 0x04, 0x03, 
.................... 0x61, 0x59, 0x49, 0x4D, 0x43, 
.................... 0x00, 0x7F, 0x41, 0x41, 0x41, 
.................... 0x02, 0x04, 0x08, 0x10, 0x20, 
.................... 0x00, 0x41, 0x41, 0x41, 0x7F, 
.................... 0x04, 0x02, 0x01, 0x02, 0x04, 
.................... 0x40, 0x40, 0x40, 0x40, 0x40, 
.................... 0x00, 0x03, 0x07, 0x08, 0x00, 
.................... 0x20, 0x54, 0x54, 0x78, 0x40, 
.................... 0x7F, 0x28, 0x44, 0x44, 0x38, 
.................... 0x38, 0x44, 0x44, 0x44, 0x28, 
.................... 0x38, 0x44, 0x44, 0x28, 0x7F, 
.................... 0x38, 0x54, 0x54, 0x54, 0x18, 
.................... 0x00, 0x08, 0x7E, 0x09, 0x02, 
.................... 0x18, 0xA4, 0xA4, 0x9C, 0x78, 
.................... 0x7F, 0x08, 0x04, 0x04, 0x78, 
.................... 0x00, 0x44, 0x7D, 0x40, 0x00, 
.................... 0x20, 0x40, 0x40, 0x3D, 0x00, 
.................... 0x7F, 0x10, 0x28, 0x44, 0x00, 
.................... 0x00, 0x41, 0x7F, 0x40, 0x00, 
.................... 0x7C, 0x04, 0x78, 0x04, 0x78, 
.................... 0x7C, 0x08, 0x04, 0x04, 0x78, 
.................... 0x38, 0x44, 0x44, 0x44, 0x38, 
.................... 0xFC, 0x18, 0x24, 0x24, 0x18, 
.................... 0x18, 0x24, 0x24, 0x18, 0xFC, 
.................... 0x7C, 0x08, 0x04, 0x04, 0x08, 
.................... 0x48, 0x54, 0x54, 0x54, 0x24, 
.................... 0x04, 0x04, 0x3F, 0x44, 0x24, 
.................... 0x3C, 0x40, 0x40, 0x20, 0x7C, 
.................... 0x1C, 0x20, 0x40, 0x20, 0x1C, 
.................... 0x3C, 0x40, 0x30, 0x40, 0x3C, 
.................... 0x44, 0x28, 0x10, 0x28, 0x44, 
.................... 0x4C, 0x90, 0x90, 0x90, 0x7C, 
.................... 0x44, 0x64, 0x54, 0x4C, 0x44, 
.................... 0x00, 0x08, 0x36, 0x41, 0x00, 
.................... 0x00, 0x00, 0x77, 0x00, 0x00, 
.................... 0x00, 0x41, 0x36, 0x08, 0x00, 
.................... 0x02, 0x01, 0x02, 0x04, 0x02 
.................... }; 
....................  
.................... static uint8_t SSD1780OLED_buffer[SSD1780OLED_LCDHEIGHT * SSD1780OLED_LCDWIDTH / 8]; 
....................  
.................... #inline  
.................... uint8_t VOledSend(uint8_t ucSendByte,SendByte_T xByteType) 
.................... { 
....................     i2c_start(); 
....................     i2c_write(SSD1780OLED_Adress); 
....................      
....................     if(xByteType == SendData) 
....................     { 
....................         //i2c_write( ((long)SSD1780OLED_ControlByteData<<6) | 0x00); 
....................         i2c_write(0b01000000); 
....................     } 
....................     else 
....................     { 
....................         //i2c_write( ((long)SSD1780OLED_ControlByteCommand<<6) | 0x00); 
....................          i2c_write(0x00); 
....................     } 
....................      
....................     uint8_t ucError  = i2c_write(ucSendByte);  
....................     i2c_stop(); 
....................     return ucError;     
.................... } 
....................  
.................... uint8_t VOledSendCommand(uint8_t ucCommand) 
.................... { 
....................     return VOledSend(ucCommand,SendCommand); 
.................... } 
.................... void VOledSendData(uint8_t ucData) 
.................... { 
....................  
....................     VOledSend(ucData,SendData); 
....................  
.................... } 
....................  
.................... void VOledSetAddressingMode(OledScreenAdressing_T xScreenAdressing) 
.................... { 
....................     switch(xScreenAdressing) 
....................     { 
....................         case PageAddressing: 
....................             VOledSendCommand(0x20); 
....................             VOledSendCommand(0xA0); 
....................             break; 
....................         case HorizontalAddressing: 
....................             VOledSendCommand(0x20); 
....................             VOledSendCommand(0xA0); 
....................             break; 
....................         case VerticalAddressing: 
....................             VOledSendCommand(0x20); 
....................             VOledSendCommand(0xA0); 
....................             break; 
....................     } 
.................... } 
....................  
.................... void VOledInit() 
.................... { 
....................     VOledSendCommand(SSD1780OLED_SetMultiplexRatio);    
....................     VOledSendCommand(0x3F); // 63    
....................  
....................     VOledSendCommand(SSD1780OLED_SetDisplayOffset);    
....................     VOledSendCommand(0x00);    
....................  
....................     VOledSendCommand(SSD1780OLED_SetDisplayStartLine); 
....................  
....................     VOledSendCommand(SSD1780OLED_SetSegmentRemap); 
....................          
....................     VOledSendCommand(SSD1780OLED_SetCOMOutputScanDirection); 
....................      
....................     VOledSendCommand(SSD1780OLED_SetCOMPinsHardwareConfiguration);    
....................     VOledSendCommand(0x12);    
....................   
....................     VOledSendCommand(SSD1780OLED_SetContrastControl);    
....................     VOledSendCommand(0x7F);    
....................  
....................     VOledSendCommand(SSD1780OLED_EntireDisplayON);    
....................  
....................     VOledSendCommand(SSD1780OLED_SetNormalDisplayMode);    
....................  
....................   
....................     VOledSendCommand(SSD1780OLED_SetDisplayClockDivideRatio);    
....................     VOledSendCommand(0x80);    
....................  
....................      
....................     VOledSendCommand(SSD1780OLED_EnableChargePumpRegulator);    
....................     VOledSendCommand(0x14);    
....................      
....................     VOledSendCommand(SSD1780OLED_DisplayON);   
....................      
....................     VOledSetAddressingMode(HorizontalAddressing); 
.................... } 
....................  
....................  
....................  
.................... void VOledSetAddressSpace( 
....................                     uint16_t usColumnAddressStart,uint16_t usColumnAddressEnd, 
....................                     uint16_t usPageAddressStart,uint16_t usPageAddressEnd) 
.................... { 
....................      
....................     VOledSendCommand(SSD1780OLED_SetColumnAddress); 
....................     VOledSendCommand(usColumnAddressStart); 
....................     VOledSendCommand(usColumnAddressEnd); 
....................  
....................     VOledSendCommand(SSD1780OLED_SetPageAddress); 
....................     VOledSendCommand(usPageAddressStart); 
....................     VOledSendCommand(usPageAddressEnd); 
....................      
.................... } 
....................  
.................... void VOledDrawPixel(uint8_t x, uint8_t y,uint8_t ucColor) 
.................... { 
....................   if ((x >= SSD1780OLED_LCDWIDTH) || (y >= SSD1780OLED_LCDHEIGHT)) 
....................     return; 
....................   if (ucColor) 
....................     SSD1780OLED_buffer[x + (uint16_t)(y / 8) * SSD1780OLED_LCDWIDTH] |=  (1 << (y & 7)); 
....................   else 
....................     SSD1780OLED_buffer[x + (uint16_t)(y / 8) * SSD1780OLED_LCDWIDTH] &=  ~(1 << (y & 7)); 
....................    
.................... } 
.................... void VOledDisplay() 
.................... { 
....................     VOledSetAddressSpace(0,127,0,7); 
....................     for(uint32_t y = 0 ;y<(SSD1780OLED_LCDWIDTH*SSD1780OLED_LCDHEIGHT / 8);y++) 
....................     { 
....................         VOledSendData(SSD1780OLED_buffer[y]); 
....................     } 
....................         
.................... } 
....................  
.................... void VOledFillScreen(uint8_t ucColor) 
.................... { 
....................     if(ucColor == 0) 
....................     { 
....................         for(uint32_t y = 0 ;y<(SSD1780OLED_LCDWIDTH*SSD1780OLED_LCDHEIGHT / 8);y++) 
....................         { 
....................         SSD1780OLED_buffer[y] = 0x00; 
....................         }     
....................      
....................     } 
....................     else 
....................     { 
....................         for(uint32_t y = 0 ;y<(SSD1780OLED_LCDWIDTH*SSD1780OLED_LCDHEIGHT / 8);y++) 
....................         { 
....................         SSD1780OLED_buffer[y] = 0xFF; 
....................         }     
....................     } 
....................      
.................... } 
....................  
....................  
.................... void VOled_DrawChar(uint16_t x, uint16_t y, uint8_t c, uint8_t size = 1) 
.................... { 
....................   //SSD1306_TextSize(size); 
....................   //VOled_Print(c); 
.................... uint8_t i, j, line;     
....................  
.................... for(i = 0; i < 5; i++ )  
....................     { 
....................         if(c < 'S') 
....................           line = Font[(c - ' ') * 5 + i]; 
....................         else 
....................           line = Font2[(c - 'S') * 5 + i]; 
....................  
....................         for(j = 0; j < 7; j++, line >>= 1) { 
....................           if(line & 0x01) 
....................           { 
....................               VOledDrawPixel(x+i, y+j,0xFF); 
....................           } 
....................           else 
....................           { 
....................               VOledDrawPixel(x+i, y+j,0x00); 
....................           } 
....................         } 
....................     } 
....................   
.................... } 
....................  
.................... // no font size scaling  
.................... void VOled_DrawCharFast(uint16_t x, uint16_t y, uint8_t c) 
.................... { 
.................... if ((x >= SSD1780OLED_LCDWIDTH) || (y >= SSD1780OLED_LCDHEIGHT)) 
.................... return; 
....................  
....................  uint8_t i, j, line;     
....................     for(i = 0; i < 5; i++ )  
....................     { 
....................         if(c < 'S') 
....................           line = Font[(c - ' ') * 5 + i]; 
....................         else 
....................           line = Font2[(c - 'S') * 5 + i]; 
....................            
....................         SSD1780OLED_buffer[x+i + (uint16_t)((y+j) / 8) * SSD1780OLED_LCDWIDTH] = line;    
....................     } 
....................       
.................... } 
.................... #inline  
.................... void VOled_DrawStringFast(uint16_t x, uint16_t y, uint8_t* ptrString) 
.................... { 
....................     uint16_t uscount = 0; 
....................     while(ptrString[uscount] != '\0') 
....................     { 
....................         VOled_DrawCharFast(x,y,ptrString[uscount]); 
....................         uscount++; 
....................         x=(uscount*5); 
....................         if(x >= 127) 
....................         { 
....................             y +=7; 
....................             x = 0; 
....................         } 
....................     } 
.................... } 
....................  
.................... void VOled_Print(uint16_t x, uint16_t y, uint8_t* ptrString, uint8_t size = 1) 
.................... { 
....................     if(size == 1) 
....................     { 
....................         VOled_DrawStringFast(x,y,ptrString); 
....................     } 
.................... } 
....................  
....................  
....................  
.................... void VOled_writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, 
....................                              uint16_t color) { 
....................  
....................   int16_t steep = abs(y1 - y0) > abs(x1 - x0); 
....................   if (steep) { 
....................     int16_t temp = x0; 
....................     x0 = y0; 
....................     y0 = temp; 
....................      
....................     temp = x1; 
....................     x1 = y1; 
....................     y1 = temp; 
....................  
....................   } 
....................  
....................   if (x0 > x1) { 
....................        
....................      int16_t temp = x0; 
....................     x0 = x1; 
....................     x1 = temp; 
....................      
....................     temp = y0; 
....................     y0 = y1; 
....................     y1 = temp; 
....................   } 
....................  
....................   int16_t dx, dy; 
....................   dx = x1 - x0; 
....................   dy = abs(y1 - y0); 
....................  
....................   int16_t err = dx / 2; 
....................   int16_t ystep; 
....................  
....................   if (y0 < y1) { 
....................     ystep = 1; 
....................   } else { 
....................     ystep = -1; 
....................   } 
....................  
....................   for (; x0 <= x1; x0++) { 
....................     if (steep) { 
....................       VOledDrawPixel(y0, x0, color); 
....................     } else { 
....................       VOledDrawPixel(x0, y0, color); 
....................     } 
....................     err -= dy; 
....................     if (err < 0) { 
....................       y0 += ystep; 
....................       err += dx; 
....................     } 
....................   } 
.................... } 
.................... void VOledFillRect(int16_t x0, int16_t y0, int16_t x1, int16_t y1, 
....................         uint8_t ucColor) 
.................... { 
....................  
.................... for (x0 ; (x0 < x1) || (y0 >= SSD1780OLED_LCDWIDTH) ; x0++) 
.................... { 
....................      
....................     for (y0 ; (y0 < y1) || (y0 >= SSD1780OLED_LCDWIDTH) ;y0++) 
....................     { 
....................         VOledDrawPixel(x0,y0,ucColor); 
....................     }     
.................... } 
....................  
.................... } 
....................  
.................... #import(file="build/default/production/mpu9250_program.o") 
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
0096:  CLRF   FF7
0098:  ADDLW  A6
009A:  MOVWF  FF6
009C:  MOVLW  00
009E:  ADDWFC FF7,F
00A0:  TBLRD*+
00A2:  MOVF   FF5,W
00A4:  RETURN 0
00A6:  DATA 7F,00
00A8:  DATA 00,00
00AA:  DATA 00,00
00AC:  DATA 00,00
00AE:  DATA 00,00
00B0:  DATA 00,00
00B2:  DATA 00,00
00B4:  DATA 00,00
00B6:  DATA 7F,00
00B8:  DATA 00,00
00BA:  DATA 00,00
00BC:  DATA 00,00
00BE:  DATA 00,00
00C0:  DATA 00,00
00C2:  DATA 00,00
00C4:  DATA 00,00
00C6:  DATA 7F,00
00C8:  DATA 00,00
*
01B2:  MOVLW  8E
01B4:  MOVWF  00
01B6:  MOVFF  4B1,01
01BA:  MOVFF  4B0,02
01BE:  CLRF   03
01C0:  BTFSS  01.7
01C2:  BRA    01CE
01C4:  COMF   01,F
01C6:  COMF   02,F
01C8:  INCF   02,F
01CA:  BNZ   01CE
01CC:  INCF   01,F
01CE:  MOVF   01,F
01D0:  BNZ   01E4
01D2:  MOVFF  02,01
01D6:  CLRF   02
01D8:  MOVLW  08
01DA:  SUBWF  00,F
01DC:  MOVF   01,F
01DE:  BNZ   01E4
01E0:  CLRF   00
01E2:  BRA    0200
01E4:  BCF    FD8.0
01E6:  BTFSC  01.7
01E8:  BRA    01F2
01EA:  RLCF   02,F
01EC:  RLCF   01,F
01EE:  DECF   00,F
01F0:  BRA    01E4
01F2:  MOVLB  4
01F4:  BTFSS  xB1.7
01F6:  BRA    01FC
01F8:  MOVLB  0
01FA:  BRA    0200
01FC:  BCF    01.7
01FE:  MOVLB  0
0200:  RETURN 0
*
0E1C:  MOVFF  4BA,4C1
0E20:  MOVLB  4
0E22:  MOVF   xBE,W
0E24:  XORWF  xC1,F
0E26:  BTFSS  xC1.7
0E28:  BRA    0E34
0E2A:  BCF    FD8.2
0E2C:  BCF    FD8.0
0E2E:  BTFSC  xBA.7
0E30:  BSF    FD8.0
0E32:  BRA    0E92
0E34:  MOVFF  4BA,4C1
0E38:  MOVFF  4BD,4C2
0E3C:  MOVF   xB9,W
0E3E:  SUBWF  xC2,F
0E40:  BZ    0E4E
0E42:  BTFSS  xC1.7
0E44:  BRA    0E92
0E46:  MOVF   FD8,W
0E48:  XORLW  01
0E4A:  MOVWF  FD8
0E4C:  BRA    0E92
0E4E:  MOVFF  4BE,4C2
0E52:  MOVF   xBA,W
0E54:  SUBWF  xC2,F
0E56:  BZ    0E64
0E58:  BTFSS  xC1.7
0E5A:  BRA    0E92
0E5C:  MOVF   FD8,W
0E5E:  XORLW  01
0E60:  MOVWF  FD8
0E62:  BRA    0E92
0E64:  MOVFF  4BF,4C2
0E68:  MOVF   xBB,W
0E6A:  SUBWF  xC2,F
0E6C:  BZ    0E7A
0E6E:  BTFSS  xC1.7
0E70:  BRA    0E92
0E72:  MOVF   FD8,W
0E74:  XORLW  01
0E76:  MOVWF  FD8
0E78:  BRA    0E92
0E7A:  MOVFF  4C0,4C2
0E7E:  MOVF   xBC,W
0E80:  SUBWF  xC2,F
0E82:  BZ    0E90
0E84:  BTFSS  xC1.7
0E86:  BRA    0E92
0E88:  MOVF   FD8,W
0E8A:  XORLW  01
0E8C:  MOVWF  FD8
0E8E:  BRA    0E92
0E90:  BCF    FD8.0
0E92:  MOVLB  0
0E94:  RETURN 0
*
22F4:  DATA 4D,50
22F6:  DATA 55,39
22F8:  DATA 32,35
22FA:  DATA 30,20
22FC:  DATA 69,73
22FE:  DATA 20,6F
2300:  DATA 6E,6C
2302:  DATA 69,6E
2304:  DATA 65,2E
2306:  DATA 2E,2E
2308:  DATA 0A,0D
230A:  DATA 00,00
230C:  DATA 4D,50
230E:  DATA 55,39
2310:  DATA 32,35
2312:  DATA 30,20
2314:  DATA 69,73
2316:  DATA 20,6E
2318:  DATA 6F,74
231A:  DATA 20,6F
231C:  DATA 6E,6C
231E:  DATA 69,6E
2320:  DATA 65,2E
2322:  DATA 2E,2E
2324:  DATA 0A,0D
2326:  DATA 00,00
2328:  DATA 41,4B
232A:  DATA 38,39
232C:  DATA 36,33
232E:  DATA 20,69
2330:  DATA 73,20
2332:  DATA 6F,6E
2334:  DATA 6C,69
2336:  DATA 6E,65
2338:  DATA 2E,2E
233A:  DATA 2E,0A
233C:  DATA 0D,00
233E:  DATA 41,4B
2340:  DATA 38,39
2342:  DATA 36,33
2344:  DATA 20,69
2346:  DATA 73,20
2348:  DATA 6E,6F
234A:  DATA 74,20
234C:  DATA 6F,6E
234E:  DATA 6C,69
2350:  DATA 6E,65
2352:  DATA 2E,2E
2354:  DATA 2E,0A
2356:  DATA 0D,00
2358:  DATA 30,78
235A:  DATA 30,33
235C:  DATA 2D,3E
235E:  DATA 3E,20
2360:  DATA 43,4F
2362:  DATA 4E,46
2364:  DATA 49,47
2366:  DATA 3A,20
2368:  DATA 25,78
236A:  DATA 0A,0D
236C:  DATA 00,00
236E:  DATA 30,78
2370:  DATA 30,31
2372:  DATA 2D,3E
2374:  DATA 3E,20
2376:  DATA 50,57
2378:  DATA 52,5F
237A:  DATA 4D,47
237C:  DATA 4D,54
237E:  DATA 5F,31
2380:  DATA 3A,20
2382:  DATA 25,78
2384:  DATA 0A,0D
2386:  DATA 00,00
2388:  DATA 30,78
238A:  DATA 30,30
238C:  DATA 2D,3E
238E:  DATA 3E,20
2390:  DATA 50,57
2392:  DATA 52,5F
2394:  DATA 4D,47
2396:  DATA 4D,54
2398:  DATA 5F,32
239A:  DATA 3A,20
239C:  DATA 25,78
239E:  DATA 0A,0D
23A0:  DATA 00,00
23A2:  DATA 30,78
23A4:  DATA 30,32
23A6:  DATA 2D,3E
23A8:  DATA 3E,20
23AA:  DATA 49,4E
23AC:  DATA 54,5F
23AE:  DATA 50,49
23B0:  DATA 4E,5F
23B2:  DATA 43,46
23B4:  DATA 47,3A
23B6:  DATA 20,25
23B8:  DATA 78,0A
23BA:  DATA 0D,00
23BC:  DATA 30,78
23BE:  DATA 30,37
23C0:  DATA 31,2D
23C2:  DATA 3E,3E
23C4:  DATA 20,57
23C6:  DATA 48,4F
23C8:  DATA 5F,41
23CA:  DATA 4D,5F
23CC:  DATA 49,5F
23CE:  DATA 4D,50
23D0:  DATA 55,39
23D2:  DATA 32,35
23D4:  DATA 30,3A
23D6:  DATA 20,25
23D8:  DATA 78,0A
23DA:  DATA 0D,00
23DC:  DATA 30,34
23DE:  DATA 38,2D
23E0:  DATA 3E,3E
23E2:  DATA 20,20
23E4:  DATA 57,48
23E6:  DATA 4F,5F
23E8:  DATA 41,4D
23EA:  DATA 5F,49
23EC:  DATA 5F,41
23EE:  DATA 4B,38
23F0:  DATA 39,36
23F2:  DATA 33,3A
23F4:  DATA 20,25
23F6:  DATA 78,0A
23F8:  DATA 0D,00
23FA:  DATA 1B,5B
23FC:  DATA 33,33
23FE:  DATA 6D,47
2400:  DATA 79,72
2402:  DATA 6F,20
2404:  DATA 3A,20
2406:  DATA 58,20
2408:  DATA 3D,20
240A:  DATA 25,2E
240C:  DATA 35,66
240E:  DATA 2C,20
2410:  DATA 59,20
2412:  DATA 3D,20
2414:  DATA 25,2E
2416:  DATA 35,66
2418:  DATA 2C,20
241A:  DATA 5A,20
241C:  DATA 3D,20
241E:  DATA 25,2E
2420:  DATA 35,66
2422:  DATA 20,28
2424:  DATA 64,65
2426:  DATA 67,2F
2428:  DATA 73,29
242A:  DATA 20,20
242C:  DATA 20,09
242E:  DATA 1B,5B
2430:  DATA 30,6D
2432:  DATA 00,00
2434:  DATA 1B,5B
2436:  DATA 33,33
2438:  DATA 6D,4D
243A:  DATA 61,67
243C:  DATA 20,20
243E:  DATA 3A,20
2440:  DATA 58,20
2442:  DATA 3D,20
2444:  DATA 25,2E
2446:  DATA 35,66
2448:  DATA 2C,20
244A:  DATA 59,20
244C:  DATA 3D,20
244E:  DATA 25,2E
2450:  DATA 35,66
2452:  DATA 2C,20
2454:  DATA 5A,20
2456:  DATA 3D,20
2458:  DATA 25,2E
245A:  DATA 35,66
245C:  DATA 20,28
245E:  DATA 75,54
2460:  DATA 29,20
2462:  DATA 20,20
2464:  DATA 20,20
2466:  DATA 20,09
2468:  DATA 1B,5B
246A:  DATA 30,6D
246C:  DATA 00,00
246E:  DATA 1B,5B
2470:  DATA 33,33
2472:  DATA 6D,41
2474:  DATA 63,63
2476:  DATA 65,6C
2478:  DATA 3A,20
247A:  DATA 58,20
247C:  DATA 3D,20
247E:  DATA 25,2E
2480:  DATA 35,66
2482:  DATA 2C,20
2484:  DATA 59,20
2486:  DATA 3D,20
2488:  DATA 25,2E
248A:  DATA 35,66
248C:  DATA 2C,20
248E:  DATA 5A,20
2490:  DATA 3D,20
2492:  DATA 25,2E
2494:  DATA 35,66
2496:  DATA 20,28
2498:  DATA 67,29
249A:  DATA 20,20
249C:  DATA 20,20
249E:  DATA 20,0A
24A0:  DATA 0D,1B
24A2:  DATA 5B,30
24A4:  DATA 6D,00
*
26AA:  MOVLB  4
26AC:  BTFSC  x6D.7
26AE:  BRA    26D0
26B0:  MOVLW  0F
26B2:  MOVWF  00
26B4:  SWAPF  x6C,W
26B6:  ANDWF  00,F
26B8:  MOVLW  0A
26BA:  SUBWF  00,W
26BC:  BC    26C4
26BE:  MOVLW  30
26C0:  ADDWF  00,F
26C2:  BRA    26C8
26C4:  MOVF   x6D,W
26C6:  ADDWF  00,F
26C8:  MOVF   00,W
26CA:  BTFSS  F9E.4
26CC:  BRA    26CA
26CE:  MOVWF  FAD
26D0:  MOVLW  0F
26D2:  ANDWF  x6C,F
26D4:  MOVLW  0A
26D6:  SUBWF  x6C,W
26D8:  BC    26DE
26DA:  MOVLW  30
26DC:  BRA    26E2
26DE:  BCF    x6D.7
26E0:  MOVF   x6D,W
26E2:  ADDWF  x6C,F
26E4:  MOVF   x6C,W
26E6:  BTFSS  F9E.4
26E8:  BRA    26E6
26EA:  MOVWF  FAD
26EC:  MOVLB  0
26EE:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
.................... #include "mpu9250_config.h" 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_CONFIG_H 
.................... #define	MPU9250_CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_CONFIG_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // ±2 g 
.................... #define AFS_4G          0x08 // ±4 g 
.................... #define AFS_8G          0x10 // ±8 g 
.................... #define AFS_16G         0x18 // ±16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // ±250 dps 
.................... #define GFS_500         0x08 // ±500 dps 
.................... #define GFS_1000        0x10 // ±1000 dps 
.................... #define GFS_2000        0x18 // ±2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
.................... #include "mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
.................... #include "mpu9250_config.h" 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_CONFIG_H 
.................... #define	MPU9250_CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include "configure.h" 
....................  
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_CONFIG_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // ±2 g 
.................... #define AFS_4G          0x08 // ±4 g 
.................... #define AFS_8G          0x10 // ±8 g 
.................... #define AFS_16G         0x18 // ±16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // ±250 dps 
.................... #define GFS_500         0x08 // ±500 dps 
.................... #define GFS_1000        0x10 // ±1000 dps 
.................... #define GFS_2000        0x18 // ±2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
.................... #include "mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... #include "mpu9250_config.h" 
.................... #include "mpu9250_private.h" 
.................... #include "mpu9250_interface.h" 
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]); 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[],float magData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]); 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[],float magData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
.................... //#include "../MyMath.h" 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
0E96:  MOVFF  4AB,4BC
0E9A:  MOVFF  4AA,4BB
0E9E:  MOVFF  4A9,4BA
0EA2:  MOVFF  4A8,4B9
0EA6:  MOVLB  4
0EA8:  CLRF   xC0
0EAA:  CLRF   xBF
0EAC:  CLRF   xBE
0EAE:  CLRF   xBD
0EB0:  MOVLB  0
0EB2:  RCALL  0E1C
0EB4:  BC    0EB8
0EB6:  BNZ   0EC2
....................       return(0.0); 
0EB8:  CLRF   00
0EBA:  CLRF   01
0EBC:  CLRF   02
0EBE:  CLRF   03
0EC0:  BRA    0FB6
....................  
....................    y=x; 
0EC2:  MOVFF  4AB,4AF
0EC6:  MOVFF  4AA,4AE
0ECA:  MOVFF  4A9,4AD
0ECE:  MOVFF  4A8,4AC
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
0ED2:  MOVLW  04
0ED4:  MOVLB  4
0ED6:  MOVWF  xB5
0ED8:  MOVLW  AC
0EDA:  MOVWF  xB4
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
0EDC:  MOVFF  4B4,FE9
0EE0:  MOVFF  4B5,FEA
0EE4:  MOVF   FEF,W
0EE6:  CLRF   xB9
0EE8:  MOVWF  xB8
0EEA:  MOVLW  7F
0EEC:  ADDWF  xB8,F
0EEE:  MOVLW  00
0EF0:  ADDWFC xB9,F
0EF2:  BCF    FD8.0
0EF4:  RRCF   xB9,W
0EF6:  RRCF   xB8,W
0EF8:  MOVFF  4B5,FEA
0EFC:  MOVFF  4B4,FE9
0F00:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0F02:  MOVFF  4AF,4B3
0F06:  MOVFF  4AE,4B2
0F0A:  MOVFF  4AD,4B1
0F0E:  MOVFF  4AC,4B0
....................       y+=(x/y); 
0F12:  MOVFF  4AB,4C0
0F16:  MOVFF  4AA,4BF
0F1A:  MOVFF  4A9,4BE
0F1E:  MOVFF  4A8,4BD
0F22:  MOVFF  4AF,4C4
0F26:  MOVFF  4AE,4C3
0F2A:  MOVFF  4AD,4C2
0F2E:  MOVFF  4AC,4C1
0F32:  MOVLB  0
0F34:  CALL   0202
0F38:  BCF    FD8.1
0F3A:  MOVFF  4AF,4C0
0F3E:  MOVFF  4AE,4BF
0F42:  MOVFF  4AD,4BE
0F46:  MOVFF  4AC,4BD
0F4A:  MOVFF  03,4C4
0F4E:  MOVFF  02,4C3
0F52:  MOVFF  01,4C2
0F56:  MOVFF  00,4C1
0F5A:  CALL   04A2
0F5E:  MOVFF  03,4AF
0F62:  MOVFF  02,4AE
0F66:  MOVFF  01,4AD
0F6A:  MOVFF  00,4AC
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
0F6E:  MOVLB  4
0F70:  MOVFF  4B4,FE9
0F74:  MOVFF  4B5,FEA
0F78:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
0F7A:  MOVFF  4B3,4BC
0F7E:  MOVFF  4B2,4BB
0F82:  MOVFF  4B1,4BA
0F86:  MOVFF  4B0,4B9
0F8A:  MOVFF  4AF,4C0
0F8E:  MOVFF  4AE,4BF
0F92:  MOVFF  4AD,4BE
0F96:  MOVFF  4AC,4BD
0F9A:  MOVLB  0
0F9C:  RCALL  0E1C
0F9E:  BTFSC  FD8.2
0FA0:  BRA    0FA6
0FA2:  MOVLB  4
0FA4:  BRA    0F02
....................  
....................    return(res); 
0FA6:  MOVFF  4B0,00
0FAA:  MOVFF  4B1,01
0FAE:  MOVFF  4B2,02
0FB2:  MOVFF  4B3,03
0FB6:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
0FB8:  MOVLB  4
0FBA:  BCF    xB8.0
....................    flag = 0; 
0FBC:  BCF    xB8.1
....................    y = x; 
0FBE:  MOVFF  4AB,4AF
0FC2:  MOVFF  4AA,4AE
0FC6:  MOVFF  4A9,4AD
0FCA:  MOVFF  4A8,4AC
....................  
....................    if (x < 0) 
0FCE:  MOVFF  4AB,4BC
0FD2:  MOVFF  4AA,4BB
0FD6:  MOVFF  4A9,4BA
0FDA:  MOVFF  4A8,4B9
0FDE:  CLRF   xC0
0FE0:  CLRF   xBF
0FE2:  CLRF   xBE
0FE4:  CLRF   xBD
0FE6:  MOVLB  0
0FE8:  RCALL  0E1C
0FEA:  BNC   0FF8
....................    { 
....................       s = 1; 
0FEC:  MOVLB  4
0FEE:  BSF    xB8.0
....................       y = -y; 
0FF0:  MOVF   xAD,W
0FF2:  XORLW  80
0FF4:  MOVWF  xAD
0FF6:  MOVLB  0
....................    } 
....................  
....................    if (y > 1.0) 
0FF8:  MOVLB  4
0FFA:  CLRF   xBC
0FFC:  CLRF   xBB
0FFE:  CLRF   xBA
1000:  MOVLW  7F
1002:  MOVWF  xB9
1004:  MOVFF  4AF,4C0
1008:  MOVFF  4AE,4BF
100C:  MOVFF  4AD,4BE
1010:  MOVFF  4AC,4BD
1014:  MOVLB  0
1016:  RCALL  0E1C
1018:  BNC   1052
....................    { 
....................       y = 1.0/y; 
101A:  MOVLB  4
101C:  CLRF   xC0
101E:  CLRF   xBF
1020:  CLRF   xBE
1022:  MOVLW  7F
1024:  MOVWF  xBD
1026:  MOVFF  4AF,4C4
102A:  MOVFF  4AE,4C3
102E:  MOVFF  4AD,4C2
1032:  MOVFF  4AC,4C1
1036:  MOVLB  0
1038:  CALL   0202
103C:  MOVFF  03,4AF
1040:  MOVFF  02,4AE
1044:  MOVFF  01,4AD
1048:  MOVFF  00,4AC
....................       flag = 1; 
104C:  MOVLB  4
104E:  BSF    xB8.1
1050:  MOVLB  0
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
1052:  MOVLW  0A
1054:  MOVLB  4
1056:  MOVWF  xC0
1058:  MOVLW  89
105A:  MOVWF  xBF
105C:  MOVLW  34
105E:  MOVWF  xBE
1060:  MOVLW  7C
1062:  MOVWF  xBD
1064:  MOVFF  4AF,4C4
1068:  MOVFF  4AE,4C3
106C:  MOVFF  4AD,4C2
1070:  MOVFF  4AC,4C1
1074:  MOVLB  0
1076:  RCALL  0966
1078:  MOVFF  03,4BC
107C:  MOVFF  02,4BB
1080:  MOVFF  01,4BA
1084:  MOVFF  00,4B9
1088:  MOVFF  03,4C0
108C:  MOVFF  02,4BF
1090:  MOVFF  01,4BE
1094:  MOVFF  00,4BD
1098:  MOVFF  4AF,4C4
109C:  MOVFF  4AE,4C3
10A0:  MOVFF  4AD,4C2
10A4:  MOVFF  4AC,4C1
10A8:  RCALL  0966
10AA:  MOVFF  03,4BC
10AE:  MOVFF  02,4BB
10B2:  MOVFF  01,4BA
10B6:  MOVFF  00,4B9
10BA:  BCF    FD8.1
10BC:  MOVFF  03,4C0
10C0:  MOVFF  02,4BF
10C4:  MOVFF  01,4BE
10C8:  MOVFF  00,4BD
10CC:  MOVLW  7C
10CE:  MOVLB  4
10D0:  MOVWF  xC4
10D2:  MOVLW  79
10D4:  MOVWF  xC3
10D6:  MOVLW  35
10D8:  MOVWF  xC2
10DA:  MOVLW  81
10DC:  MOVWF  xC1
10DE:  MOVLB  0
10E0:  CALL   04A2
10E4:  MOVFF  03,4B3
10E8:  MOVFF  02,4B2
10EC:  MOVFF  01,4B1
10F0:  MOVFF  00,4B0
....................    res = res*y*y + pat[2]; 
10F4:  MOVFF  4B3,4C0
10F8:  MOVFF  4B2,4BF
10FC:  MOVFF  4B1,4BE
1100:  MOVFF  4B0,4BD
1104:  MOVFF  4AF,4C4
1108:  MOVFF  4AE,4C3
110C:  MOVFF  4AD,4C2
1110:  MOVFF  4AC,4C1
1114:  RCALL  0966
1116:  MOVFF  03,4BC
111A:  MOVFF  02,4BB
111E:  MOVFF  01,4BA
1122:  MOVFF  00,4B9
1126:  MOVFF  03,4C0
112A:  MOVFF  02,4BF
112E:  MOVFF  01,4BE
1132:  MOVFF  00,4BD
1136:  MOVFF  4AF,4C4
113A:  MOVFF  4AE,4C3
113E:  MOVFF  4AD,4C2
1142:  MOVFF  4AC,4C1
1146:  RCALL  0966
1148:  MOVFF  03,4BC
114C:  MOVFF  02,4BB
1150:  MOVFF  01,4BA
1154:  MOVFF  00,4B9
1158:  BCF    FD8.1
115A:  MOVFF  03,4C0
115E:  MOVFF  02,4BF
1162:  MOVFF  01,4BE
1166:  MOVFF  00,4BD
116A:  MOVLW  3F
116C:  MOVLB  4
116E:  MOVWF  xC4
1170:  MOVLW  02
1172:  MOVWF  xC3
1174:  MOVLW  33
1176:  MOVWF  xC2
1178:  MOVLW  83
117A:  MOVWF  xC1
117C:  MOVLB  0
117E:  CALL   04A2
1182:  MOVFF  03,4B3
1186:  MOVFF  02,4B2
118A:  MOVFF  01,4B1
118E:  MOVFF  00,4B0
....................    res = res*y*y + pat[3]; 
1192:  MOVFF  4B3,4C0
1196:  MOVFF  4B2,4BF
119A:  MOVFF  4B1,4BE
119E:  MOVFF  4B0,4BD
11A2:  MOVFF  4AF,4C4
11A6:  MOVFF  4AE,4C3
11AA:  MOVFF  4AD,4C2
11AE:  MOVFF  4AC,4C1
11B2:  CALL   0966
11B6:  MOVFF  03,4BC
11BA:  MOVFF  02,4BB
11BE:  MOVFF  01,4BA
11C2:  MOVFF  00,4B9
11C6:  MOVFF  03,4C0
11CA:  MOVFF  02,4BF
11CE:  MOVFF  01,4BE
11D2:  MOVFF  00,4BD
11D6:  MOVFF  4AF,4C4
11DA:  MOVFF  4AE,4C3
11DE:  MOVFF  4AD,4C2
11E2:  MOVFF  4AC,4C1
11E6:  CALL   0966
11EA:  MOVFF  03,4BC
11EE:  MOVFF  02,4BB
11F2:  MOVFF  01,4BA
11F6:  MOVFF  00,4B9
11FA:  BCF    FD8.1
11FC:  MOVFF  03,4C0
1200:  MOVFF  02,4BF
1204:  MOVFF  01,4BE
1208:  MOVFF  00,4BD
120C:  MOVLW  33
120E:  MOVLB  4
1210:  MOVWF  xC4
1212:  MOVLW  8C
1214:  MOVWF  xC3
1216:  MOVLW  1E
1218:  MOVWF  xC2
121A:  MOVLW  83
121C:  MOVWF  xC1
121E:  MOVLB  0
1220:  CALL   04A2
1224:  MOVFF  03,4B3
1228:  MOVFF  02,4B2
122C:  MOVFF  01,4B1
1230:  MOVFF  00,4B0
....................  
....................    r = qat[0]*y*y + qat[1]; 
1234:  MOVLB  4
1236:  CLRF   xC0
1238:  CLRF   xBF
123A:  CLRF   xBE
123C:  MOVLW  7F
123E:  MOVWF  xBD
1240:  MOVFF  4AF,4C4
1244:  MOVFF  4AE,4C3
1248:  MOVFF  4AD,4C2
124C:  MOVFF  4AC,4C1
1250:  MOVLB  0
1252:  CALL   0966
1256:  MOVFF  03,4BC
125A:  MOVFF  02,4BB
125E:  MOVFF  01,4BA
1262:  MOVFF  00,4B9
1266:  MOVFF  03,4C0
126A:  MOVFF  02,4BF
126E:  MOVFF  01,4BE
1272:  MOVFF  00,4BD
1276:  MOVFF  4AF,4C4
127A:  MOVFF  4AE,4C3
127E:  MOVFF  4AD,4C2
1282:  MOVFF  4AC,4C1
1286:  CALL   0966
128A:  MOVFF  03,4BC
128E:  MOVFF  02,4BB
1292:  MOVFF  01,4BA
1296:  MOVFF  00,4B9
129A:  BCF    FD8.1
129C:  MOVFF  03,4C0
12A0:  MOVFF  02,4BF
12A4:  MOVFF  01,4BE
12A8:  MOVFF  00,4BD
12AC:  MOVLW  1B
12AE:  MOVLB  4
12B0:  MOVWF  xC4
12B2:  MOVLW  E4
12B4:  MOVWF  xC3
12B6:  MOVLW  35
12B8:  MOVWF  xC2
12BA:  MOVLW  82
12BC:  MOVWF  xC1
12BE:  MOVLB  0
12C0:  CALL   04A2
12C4:  MOVFF  03,4B7
12C8:  MOVFF  02,4B6
12CC:  MOVFF  01,4B5
12D0:  MOVFF  00,4B4
....................    r = r*y*y + qat[2]; 
12D4:  MOVFF  4B7,4C0
12D8:  MOVFF  4B6,4BF
12DC:  MOVFF  4B5,4BE
12E0:  MOVFF  4B4,4BD
12E4:  MOVFF  4AF,4C4
12E8:  MOVFF  4AE,4C3
12EC:  MOVFF  4AD,4C2
12F0:  MOVFF  4AC,4C1
12F4:  CALL   0966
12F8:  MOVFF  03,4BC
12FC:  MOVFF  02,4BB
1300:  MOVFF  01,4BA
1304:  MOVFF  00,4B9
1308:  MOVFF  03,4C0
130C:  MOVFF  02,4BF
1310:  MOVFF  01,4BE
1314:  MOVFF  00,4BD
1318:  MOVFF  4AF,4C4
131C:  MOVFF  4AE,4C3
1320:  MOVFF  4AD,4C2
1324:  MOVFF  4AC,4C1
1328:  CALL   0966
132C:  MOVFF  03,4BC
1330:  MOVFF  02,4BB
1334:  MOVFF  01,4BA
1338:  MOVFF  00,4B9
133C:  BCF    FD8.1
133E:  MOVFF  03,4C0
1342:  MOVFF  02,4BF
1346:  MOVFF  01,4BE
134A:  MOVFF  00,4BD
134E:  MOVLW  A4
1350:  MOVLB  4
1352:  MOVWF  xC4
1354:  MOVLW  DB
1356:  MOVWF  xC3
1358:  MOVLW  67
135A:  MOVWF  xC2
135C:  MOVLW  83
135E:  MOVWF  xC1
1360:  MOVLB  0
1362:  CALL   04A2
1366:  MOVFF  03,4B7
136A:  MOVFF  02,4B6
136E:  MOVFF  01,4B5
1372:  MOVFF  00,4B4
....................    r = r*y*y + qat[3]; 
1376:  MOVFF  4B7,4C0
137A:  MOVFF  4B6,4BF
137E:  MOVFF  4B5,4BE
1382:  MOVFF  4B4,4BD
1386:  MOVFF  4AF,4C4
138A:  MOVFF  4AE,4C3
138E:  MOVFF  4AD,4C2
1392:  MOVFF  4AC,4C1
1396:  CALL   0966
139A:  MOVFF  03,4BC
139E:  MOVFF  02,4BB
13A2:  MOVFF  01,4BA
13A6:  MOVFF  00,4B9
13AA:  MOVFF  03,4C0
13AE:  MOVFF  02,4BF
13B2:  MOVFF  01,4BE
13B6:  MOVFF  00,4BD
13BA:  MOVFF  4AF,4C4
13BE:  MOVFF  4AE,4C3
13C2:  MOVFF  4AD,4C2
13C6:  MOVFF  4AC,4C1
13CA:  CALL   0966
13CE:  MOVFF  03,4BC
13D2:  MOVFF  02,4BB
13D6:  MOVFF  01,4BA
13DA:  MOVFF  00,4B9
13DE:  BCF    FD8.1
13E0:  MOVFF  03,4C0
13E4:  MOVFF  02,4BF
13E8:  MOVFF  01,4BE
13EC:  MOVFF  00,4BD
13F0:  MOVLW  33
13F2:  MOVLB  4
13F4:  MOVWF  xC4
13F6:  MOVLW  8C
13F8:  MOVWF  xC3
13FA:  MOVLW  1E
13FC:  MOVWF  xC2
13FE:  MOVLW  83
1400:  MOVWF  xC1
1402:  MOVLB  0
1404:  CALL   04A2
1408:  MOVFF  03,4B7
140C:  MOVFF  02,4B6
1410:  MOVFF  01,4B5
1414:  MOVFF  00,4B4
....................  
....................    res = y*res/r; 
1418:  MOVFF  4AF,4C0
141C:  MOVFF  4AE,4BF
1420:  MOVFF  4AD,4BE
1424:  MOVFF  4AC,4BD
1428:  MOVFF  4B3,4C4
142C:  MOVFF  4B2,4C3
1430:  MOVFF  4B1,4C2
1434:  MOVFF  4B0,4C1
1438:  CALL   0966
143C:  MOVFF  03,4BC
1440:  MOVFF  02,4BB
1444:  MOVFF  01,4BA
1448:  MOVFF  00,4B9
144C:  MOVFF  03,4C0
1450:  MOVFF  02,4BF
1454:  MOVFF  01,4BE
1458:  MOVFF  00,4BD
145C:  MOVFF  4B7,4C4
1460:  MOVFF  4B6,4C3
1464:  MOVFF  4B5,4C2
1468:  MOVFF  4B4,4C1
146C:  CALL   0202
1470:  MOVFF  03,4B3
1474:  MOVFF  02,4B2
1478:  MOVFF  01,4B1
147C:  MOVFF  00,4B0
....................  
....................  
....................    if (flag)                              // for |x| > 1 
1480:  MOVLB  4
1482:  BTFSS  xB8.1
1484:  BRA    14C0
....................       res = PI_DIV_BY_TWO - res; 
1486:  BSF    FD8.1
1488:  MOVLW  DB
148A:  MOVWF  xC0
148C:  MOVLW  0F
148E:  MOVWF  xBF
1490:  MOVLW  49
1492:  MOVWF  xBE
1494:  MOVLW  7F
1496:  MOVWF  xBD
1498:  MOVFF  4B3,4C4
149C:  MOVFF  4B2,4C3
14A0:  MOVFF  4B1,4C2
14A4:  MOVFF  4B0,4C1
14A8:  MOVLB  0
14AA:  CALL   04A2
14AE:  MOVFF  03,4B3
14B2:  MOVFF  02,4B2
14B6:  MOVFF  01,4B1
14BA:  MOVFF  00,4B0
14BE:  MOVLB  4
....................    if (s) 
14C0:  BTFSS  xB8.0
14C2:  BRA    14CA
....................       res = -res; 
14C4:  MOVF   xB1,W
14C6:  XORLW  80
14C8:  MOVWF  xB1
....................  
....................    return(res); 
14CA:  MOVFF  4B0,00
14CE:  MOVFF  4B1,01
14D2:  MOVFF  4B2,02
14D6:  MOVFF  4B3,03
14DA:  MOVLB  0
14DC:  RETURN 0
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... const float hard_iron[3] = {292.70500000000004,371.765,-263.95000000000005}; 
.................... const float soft_iron[3][3] =  
.................... {{1,0,0}, 
....................  {0,1,0}, 
....................  {0,0,1}}; 
....................  
.................... // Function to write a byte to a specific register of a device 
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) { 
....................     i2c_start(); 
*
24F0:  BSF    FC5.0
24F2:  BTFSC  FC5.0
24F4:  BRA    24F2
....................     i2c_write(deviceAddress << 1); 
24F6:  BCF    FD8.0
24F8:  MOVLB  4
24FA:  RLCF   x6C,W
24FC:  MOVWF  x70
24FE:  CLRF   16
2500:  BTFSC  FF2.7
2502:  BSF    16.7
2504:  BCF    FF2.7
2506:  MOVWF  xB9
2508:  MOVLB  0
250A:  CALL   00CA
250E:  BTFSC  16.7
2510:  BSF    FF2.7
2512:  CLRF   16
2514:  BTFSC  FF2.7
2516:  BSF    16.7
2518:  BCF    FF2.7
....................     i2c_write(registerAddress); 
251A:  MOVFF  46D,4B9
251E:  CALL   00CA
2522:  BTFSC  16.7
2524:  BSF    FF2.7
2526:  CLRF   16
2528:  BTFSC  FF2.7
252A:  BSF    16.7
252C:  BCF    FF2.7
....................     i2c_write(data); 
252E:  MOVFF  46E,4B9
2532:  CALL   00CA
2536:  BTFSC  16.7
2538:  BSF    FF2.7
....................     i2c_stop(); 
253A:  BSF    FC5.2
253C:  BTFSC  FC5.2
253E:  BRA    253C
2540:  RETURN 0
.................... } 
....................  
.................... // Function to read a byte from a specific register of a device 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) { 
....................     i2c_start(); 
*
0102:  BSF    FC5.0
0104:  BTFSC  FC5.0
0106:  BRA    0104
....................     i2c_write(deviceAddress << 1); 
0108:  BCF    FD8.0
010A:  MOVLB  4
010C:  RLCF   xB3,W
010E:  MOVWF  xB8
0110:  MOVWF  xB9
0112:  MOVLB  0
0114:  RCALL  00CA
....................     i2c_write(registerAddress); 
0116:  MOVFF  4B4,4B9
011A:  RCALL  00CA
....................     i2c_start(); 
011C:  BSF    FC5.1
011E:  BTFSC  FC5.1
0120:  BRA    011E
....................     i2c_write(deviceAddress << 1 | 0x01); 
0122:  BCF    FD8.0
0124:  MOVLB  4
0126:  RLCF   xB3,W
0128:  IORLW  01
012A:  MOVWF  xB8
012C:  MOVWF  xB9
012E:  MOVLB  0
0130:  RCALL  00CA
....................     *data = i2c_read(0); 
0132:  MOVFF  4B6,03
0136:  MOVLB  4
0138:  MOVFF  4B5,FE9
013C:  MOVFF  4B6,FEA
0140:  CLRF   00
0142:  MOVLB  0
0144:  RCALL  00E6
0146:  MOVFF  01,FEF
....................     i2c_stop(); 
014A:  BSF    FC5.2
014C:  BTFSC  FC5.2
014E:  BRA    014C
0150:  RETURN 0
.................... } 
....................  
.................... // Function to read a 16-bit value from two consecutive registers of a device 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
....................     uint8_t highByte, lowByte; 
....................     mpu9250_readByte(deviceAddress, registerLow, &lowByte); 
0152:  MOVFF  4AC,4B3
0156:  MOVFF  4AE,4B4
015A:  MOVLW  04
015C:  MOVLB  4
015E:  MOVWF  xB6
0160:  MOVLW  B2
0162:  MOVWF  xB5
0164:  MOVLB  0
0166:  RCALL  0102
....................     mpu9250_readByte(deviceAddress, registerHigh, &highByte); 
0168:  MOVFF  4AC,4B3
016C:  MOVFF  4AD,4B4
0170:  MOVLW  04
0172:  MOVLB  4
0174:  MOVWF  xB6
0176:  MOVLW  B1
0178:  MOVWF  xB5
017A:  MOVLB  0
017C:  RCALL  0102
....................  
....................         *data = make16(highByte,lowByte); 
017E:  MOVLB  4
0180:  MOVFF  4AF,FE9
0184:  MOVFF  4B0,FEA
0188:  MOVFF  4B1,FEC
018C:  MOVF   FED,F
018E:  MOVFF  4B2,FEF
0192:  MOVLB  0
0194:  RETURN 0
....................  
.................... } 
....................  
.................... // Function to read a 16-bit value from two consecutive gyro registers 
.................... void read_gyro_word(uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
....................     read_word(MPU9250_ADDRESS, registerHigh, registerLow, data); 
0196:  MOVLW  68
0198:  MOVLB  4
019A:  MOVWF  xAC
019C:  MOVFF  491,4AD
01A0:  MOVFF  492,4AE
01A4:  MOVFF  494,4B0
01A8:  MOVFF  493,4AF
01AC:  MOVLB  0
01AE:  RCALL  0152
01B0:  RETURN 0
.................... } 
.................... // Function to read a 16-bit value from two consecutive accelerometer registers 
.................... void read_accel_word(uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
....................     read_word(MPU9250_ADDRESS, registerHigh, registerLow, data); 
*
0486:  MOVLW  68
0488:  MOVLB  4
048A:  MOVWF  xAC
048C:  MOVFF  4A4,4AD
0490:  MOVFF  4A5,4AE
0494:  MOVFF  4A7,4B0
0498:  MOVFF  4A6,4AF
049C:  MOVLB  0
049E:  RCALL  0152
04A0:  RETURN 0
.................... } 
.................... // Function to read a 16-bit value from two consecutive magnetometer registers 
.................... void read_mag_word(uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
....................     read_word(AK8963_ADDRESS, registerHigh, registerLow, data); 
*
0914:  MOVLW  0C
0916:  MOVLB  4
0918:  MOVWF  xAC
091A:  MOVFF  4A8,4AD
091E:  MOVFF  4A9,4AE
0922:  MOVFF  4AB,4B0
0926:  MOVFF  4AA,4AF
092A:  MOVLB  0
092C:  RCALL  0152
092E:  RETURN 0
.................... } 
....................  
.................... // Function to initialize MPU9250 
.................... void mpu9250_init() { 
....................  
....................     mpu9250_writeByte(MPU9250_ADDRESS, CONFIG, CONFIG_VALUE);                    // Set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
*
2542:  MOVLW  68
2544:  MOVLB  4
2546:  MOVWF  x6C
2548:  MOVLW  1A
254A:  MOVWF  x6D
254C:  MOVLW  03
254E:  MOVWF  x6E
2550:  MOVLB  0
2552:  RCALL  24F0
....................     mpu9250_writeByte(MPU9250_ADDRESS, PWR_MGMT_1, PWR_MGMT_1_VALUE);            // Set the clock source to PLL with X axis gyroscope reference and disable sleep mode 
2554:  MOVLW  68
2556:  MOVLB  4
2558:  MOVWF  x6C
255A:  MOVLW  6B
255C:  MOVWF  x6D
255E:  MOVLW  01
2560:  MOVWF  x6E
2562:  MOVLB  0
2564:  RCALL  24F0
....................     mpu9250_writeByte(MPU9250_ADDRESS, PWR_MGMT_2, PWR_MGMT_2_VALUE);            // Enable all sensors and disable standby mode for accel and gyro only 
2566:  MOVLW  68
2568:  MOVLB  4
256A:  MOVWF  x6C
256C:  MOVLW  6C
256E:  MOVWF  x6D
2570:  CLRF   x6E
2572:  MOVLB  0
2574:  RCALL  24F0
....................     mpu9250_writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, AFS_8G);                    // Set the accelerometer range to ±8 g 
2576:  MOVLW  68
2578:  MOVLB  4
257A:  MOVWF  x6C
257C:  MOVLW  1C
257E:  MOVWF  x6D
2580:  MOVLW  10
2582:  MOVWF  x6E
2584:  MOVLB  0
2586:  RCALL  24F0
....................     mpu9250_writeByte(MPU9250_ADDRESS, GYRO_CONFIG, GFS_500);                    // Set the gyro range to ±500 dps 
2588:  MOVLW  68
258A:  MOVLB  4
258C:  MOVWF  x6C
258E:  MOVLW  1B
2590:  MOVWF  x6D
2592:  MOVLW  08
2594:  MOVWF  x6E
2596:  MOVLB  0
2598:  RCALL  24F0
....................  
....................  
....................     mpu9250_writeByte(MPU9250_ADDRESS, INT_PIN_CFG, INT_PIN_CFG_VALUE1);         // Enable the I2C bypass mode of the MPU-9250 
259A:  MOVLW  68
259C:  MOVLB  4
259E:  MOVWF  x6C
25A0:  MOVLW  37
25A2:  MOVWF  x6D
25A4:  MOVLW  02
25A6:  MOVWF  x6E
25A8:  MOVLB  0
25AA:  RCALL  24F0
....................     mpu9250_writeByte(MPU9250_ADDRESS,MPU9250_I2C_MST_CTRL, I2C_MST_CLK_400kHz); // Set bits 3:0 to 1101 for 400kHz I2C master clock speed 
25AC:  MOVLW  68
25AE:  MOVLB  4
25B0:  MOVWF  x6C
25B2:  MOVLW  24
25B4:  MOVWF  x6D
25B6:  MOVLW  0D
25B8:  MOVWF  x6E
25BA:  MOVLB  0
25BC:  RCALL  24F0
....................  
....................     mpu9250_writeByte(AK8963_ADDRESS, AK8963_CNTL2_Reg , 0x01);                  // Reset the AK8963 magnetometer 
25BE:  MOVLW  0C
25C0:  MOVLB  4
25C2:  MOVWF  x6C
25C4:  MOVLW  0B
25C6:  MOVWF  x6D
25C8:  MOVLW  01
25CA:  MOVWF  x6E
25CC:  MOVLB  0
25CE:  RCALL  24F0
....................     mpu9250_writeByte(AK8963_ADDRESS, AK8963_CNTL1_Reg, 0x12);                   // Set the magnetometer to 16 bit resolution, 100 Hz update rate 
25D0:  MOVLW  0C
25D2:  MOVLB  4
25D4:  MOVWF  x6C
25D6:  MOVLW  0A
25D8:  MOVWF  x6D
25DA:  MOVLW  12
25DC:  MOVWF  x6E
25DE:  MOVLB  0
25E0:  RCALL  24F0
....................  
....................     delay_ms(100); 
25E2:  MOVLW  64
25E4:  MOVLB  4
25E6:  MOVWF  x6F
25E8:  MOVLB  0
25EA:  RCALL  24A6
....................  
....................     uint8_t status = 0; 
25EC:  MOVLB  4
25EE:  CLRF   x6B
25F0:  CLRF   16
25F2:  BTFSC  FF2.7
25F4:  BSF    16.7
25F6:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, WHO_AM_I_MPU9250, &status); 
25F8:  MOVLW  68
25FA:  MOVWF  xB3
25FC:  MOVLW  75
25FE:  MOVWF  xB4
2600:  MOVLW  04
2602:  MOVWF  xB6
2604:  MOVLW  6B
2606:  MOVWF  xB5
2608:  MOVLB  0
260A:  CALL   0102
260E:  BTFSC  16.7
2610:  BSF    FF2.7
....................     if (status == MPU9250_ADDRESS_ID) { 
2612:  MOVLB  4
2614:  MOVF   x6B,W
2616:  SUBLW  71
2618:  BNZ   262A
....................         printf( "MPU9250 is online...\n\r" ); 
261A:  MOVLW  F4
261C:  MOVWF  FF6
261E:  MOVLW  22
2620:  MOVWF  FF7
2622:  MOVLB  0
2624:  RCALL  24CE
....................     } else { 
2626:  BRA    2636
2628:  MOVLB  4
....................         printf( "MPU9250 is not online...\n\r" ); 
262A:  MOVLW  0C
262C:  MOVWF  FF6
262E:  MOVLW  23
2630:  MOVWF  FF7
2632:  MOVLB  0
2634:  RCALL  24CE
2636:  CLRF   16
2638:  BTFSC  FF2.7
263A:  BSF    16.7
263C:  BCF    FF2.7
....................     } 
....................     mpu9250_readByte(AK8963_ADDRESS, WHO_AM_I_AK8963, &status); 
263E:  MOVLW  0C
2640:  MOVLB  4
2642:  MOVWF  xB3
2644:  CLRF   xB4
2646:  MOVLW  04
2648:  MOVWF  xB6
264A:  MOVLW  6B
264C:  MOVWF  xB5
264E:  MOVLB  0
2650:  CALL   0102
2654:  BTFSC  16.7
2656:  BSF    FF2.7
....................     if (status == AK8963_ADDRESS_ID) { 
2658:  MOVLB  4
265A:  MOVF   x6B,W
265C:  SUBLW  48
265E:  BNZ   2670
....................         printf( "AK8963 is online...\n\r" ); 
2660:  MOVLW  28
2662:  MOVWF  FF6
2664:  MOVLW  23
2666:  MOVWF  FF7
2668:  MOVLB  0
266A:  RCALL  24CE
....................     } else { 
266C:  BRA    267C
266E:  MOVLB  4
....................         printf( "AK8963 is not online...\n\r" ); 
2670:  MOVLW  3E
2672:  MOVWF  FF6
2674:  MOVLW  23
2676:  MOVWF  FF7
2678:  MOVLB  0
267A:  RCALL  24CE
....................     } 
267C:  GOTO   2F90 (RETURN)
....................  
.................... } 
....................  
.................... // Function to read and print the initial register values of the MPU9250 
.................... void mpu9250_print_initRegisters(void) { 
*
26F0:  MOVLB  4
26F2:  CLRF   x6B
26F4:  CLRF   16
26F6:  BTFSC  FF2.7
26F8:  BSF    16.7
26FA:  BCF    FF2.7
....................     uint8_t data = 0; 
....................     mpu9250_readByte(MPU9250_ADDRESS, CONFIG, &data); 
26FC:  MOVLW  68
26FE:  MOVWF  xB3
2700:  MOVLW  1A
2702:  MOVWF  xB4
2704:  MOVLW  04
2706:  MOVWF  xB6
2708:  MOVLW  6B
270A:  MOVWF  xB5
270C:  MOVLB  0
270E:  CALL   0102
2712:  BTFSC  16.7
2714:  BSF    FF2.7
....................     printf("0x03->> CONFIG: %x\n\r", data); 
2716:  MOVLW  58
2718:  MOVWF  FF6
271A:  MOVLW  23
271C:  MOVWF  FF7
271E:  MOVLW  10
2720:  MOVLB  4
2722:  MOVWF  x6D
2724:  MOVLB  0
2726:  RCALL  2680
2728:  MOVFF  46B,46C
272C:  MOVLW  57
272E:  MOVLB  4
2730:  MOVWF  x6D
2732:  MOVLB  0
2734:  RCALL  26AA
2736:  MOVLW  0A
2738:  BTFSS  F9E.4
273A:  BRA    2738
273C:  MOVWF  FAD
273E:  MOVLW  0D
2740:  BTFSS  F9E.4
2742:  BRA    2740
2744:  MOVWF  FAD
2746:  CLRF   16
2748:  BTFSC  FF2.7
274A:  BSF    16.7
274C:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, PWR_MGMT_1, &data); 
274E:  MOVLW  68
2750:  MOVLB  4
2752:  MOVWF  xB3
2754:  MOVLW  6B
2756:  MOVWF  xB4
2758:  MOVLW  04
275A:  MOVWF  xB6
275C:  MOVLW  6B
275E:  MOVWF  xB5
2760:  MOVLB  0
2762:  CALL   0102
2766:  BTFSC  16.7
2768:  BSF    FF2.7
....................     printf("0x01->> PWR_MGMT_1: %x\n\r", data); 
276A:  MOVLW  6E
276C:  MOVWF  FF6
276E:  MOVLW  23
2770:  MOVWF  FF7
2772:  MOVLW  14
2774:  MOVLB  4
2776:  MOVWF  x6D
2778:  MOVLB  0
277A:  RCALL  2680
277C:  MOVFF  46B,46C
2780:  MOVLW  57
2782:  MOVLB  4
2784:  MOVWF  x6D
2786:  MOVLB  0
2788:  RCALL  26AA
278A:  MOVLW  0A
278C:  BTFSS  F9E.4
278E:  BRA    278C
2790:  MOVWF  FAD
2792:  MOVLW  0D
2794:  BTFSS  F9E.4
2796:  BRA    2794
2798:  MOVWF  FAD
279A:  CLRF   16
279C:  BTFSC  FF2.7
279E:  BSF    16.7
27A0:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, PWR_MGMT_2, &data); 
27A2:  MOVLW  68
27A4:  MOVLB  4
27A6:  MOVWF  xB3
27A8:  MOVLW  6C
27AA:  MOVWF  xB4
27AC:  MOVLW  04
27AE:  MOVWF  xB6
27B0:  MOVLW  6B
27B2:  MOVWF  xB5
27B4:  MOVLB  0
27B6:  CALL   0102
27BA:  BTFSC  16.7
27BC:  BSF    FF2.7
....................     printf("0x00->> PWR_MGMT_2: %x\n\r", data); 
27BE:  MOVLW  88
27C0:  MOVWF  FF6
27C2:  MOVLW  23
27C4:  MOVWF  FF7
27C6:  MOVLW  14
27C8:  MOVLB  4
27CA:  MOVWF  x6D
27CC:  MOVLB  0
27CE:  RCALL  2680
27D0:  MOVFF  46B,46C
27D4:  MOVLW  57
27D6:  MOVLB  4
27D8:  MOVWF  x6D
27DA:  MOVLB  0
27DC:  RCALL  26AA
27DE:  MOVLW  0A
27E0:  BTFSS  F9E.4
27E2:  BRA    27E0
27E4:  MOVWF  FAD
27E6:  MOVLW  0D
27E8:  BTFSS  F9E.4
27EA:  BRA    27E8
27EC:  MOVWF  FAD
27EE:  CLRF   16
27F0:  BTFSC  FF2.7
27F2:  BSF    16.7
27F4:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, INT_PIN_CFG, &data); 
27F6:  MOVLW  68
27F8:  MOVLB  4
27FA:  MOVWF  xB3
27FC:  MOVLW  37
27FE:  MOVWF  xB4
2800:  MOVLW  04
2802:  MOVWF  xB6
2804:  MOVLW  6B
2806:  MOVWF  xB5
2808:  MOVLB  0
280A:  CALL   0102
280E:  BTFSC  16.7
2810:  BSF    FF2.7
....................     printf("0x02->> INT_PIN_CFG: %x\n\r", data); 
2812:  MOVLW  A2
2814:  MOVWF  FF6
2816:  MOVLW  23
2818:  MOVWF  FF7
281A:  MOVLW  15
281C:  MOVLB  4
281E:  MOVWF  x6D
2820:  MOVLB  0
2822:  RCALL  2680
2824:  MOVFF  46B,46C
2828:  MOVLW  57
282A:  MOVLB  4
282C:  MOVWF  x6D
282E:  MOVLB  0
2830:  RCALL  26AA
2832:  MOVLW  0A
2834:  BTFSS  F9E.4
2836:  BRA    2834
2838:  MOVWF  FAD
283A:  MOVLW  0D
283C:  BTFSS  F9E.4
283E:  BRA    283C
2840:  MOVWF  FAD
2842:  CLRF   16
2844:  BTFSC  FF2.7
2846:  BSF    16.7
2848:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, WHO_AM_I_MPU9250, &data); 
284A:  MOVLW  68
284C:  MOVLB  4
284E:  MOVWF  xB3
2850:  MOVLW  75
2852:  MOVWF  xB4
2854:  MOVLW  04
2856:  MOVWF  xB6
2858:  MOVLW  6B
285A:  MOVWF  xB5
285C:  MOVLB  0
285E:  CALL   0102
2862:  BTFSC  16.7
2864:  BSF    FF2.7
....................     printf("0x071->> WHO_AM_I_MPU9250: %x\n\r", data); 
2866:  MOVLW  BC
2868:  MOVWF  FF6
286A:  MOVLW  23
286C:  MOVWF  FF7
286E:  MOVLW  1B
2870:  MOVLB  4
2872:  MOVWF  x6D
2874:  MOVLB  0
2876:  RCALL  2680
2878:  MOVFF  46B,46C
287C:  MOVLW  57
287E:  MOVLB  4
2880:  MOVWF  x6D
2882:  MOVLB  0
2884:  RCALL  26AA
2886:  MOVLW  0A
2888:  BTFSS  F9E.4
288A:  BRA    2888
288C:  MOVWF  FAD
288E:  MOVLW  0D
2890:  BTFSS  F9E.4
2892:  BRA    2890
2894:  MOVWF  FAD
2896:  CLRF   16
2898:  BTFSC  FF2.7
289A:  BSF    16.7
289C:  BCF    FF2.7
....................     mpu9250_readByte(AK8963_ADDRESS, WHO_AM_I_AK8963, &data); 
289E:  MOVLW  0C
28A0:  MOVLB  4
28A2:  MOVWF  xB3
28A4:  CLRF   xB4
28A6:  MOVLW  04
28A8:  MOVWF  xB6
28AA:  MOVLW  6B
28AC:  MOVWF  xB5
28AE:  MOVLB  0
28B0:  CALL   0102
28B4:  BTFSC  16.7
28B6:  BSF    FF2.7
....................     printf("048->>  WHO_AM_I_AK8963: %x\n\r", data); 
28B8:  MOVLW  DC
28BA:  MOVWF  FF6
28BC:  MOVLW  23
28BE:  MOVWF  FF7
28C0:  MOVLW  19
28C2:  MOVLB  4
28C4:  MOVWF  x6D
28C6:  MOVLB  0
28C8:  RCALL  2680
28CA:  MOVFF  46B,46C
28CE:  MOVLW  57
28D0:  MOVLB  4
28D2:  MOVWF  x6D
28D4:  MOVLB  0
28D6:  RCALL  26AA
28D8:  MOVLW  0A
28DA:  BTFSS  F9E.4
28DC:  BRA    28DA
28DE:  MOVWF  FAD
28E0:  MOVLW  0D
28E2:  BTFSS  F9E.4
28E4:  BRA    28E2
28E6:  MOVWF  FAD
28E8:  GOTO   2F94 (RETURN)
.................... } 
....................  
.................... // Function to read gyro data and convert it to degrees per second 
.................... void mpu9250_read_gyro(float gyroData[]) { 
*
0360:  MOVLB  4
0362:  CLRF   x90
0364:  CLRF   x8F
....................     int16_t gyroX, gyroY, gyroZ = 0; 
....................     read_gyro_word(GYRO_XOUT_H, GYRO_XOUT_L, &gyroX); 
0366:  MOVLW  43
0368:  MOVWF  x91
036A:  MOVLW  44
036C:  MOVWF  x92
036E:  MOVLW  04
0370:  MOVWF  x94
0372:  MOVLW  8B
0374:  MOVWF  x93
0376:  MOVLB  0
0378:  RCALL  0196
....................     read_gyro_word(GYRO_YOUT_H, GYRO_YOUT_L, &gyroY); 
037A:  MOVLW  45
037C:  MOVLB  4
037E:  MOVWF  x91
0380:  MOVLW  46
0382:  MOVWF  x92
0384:  MOVLW  04
0386:  MOVWF  x94
0388:  MOVLW  8D
038A:  MOVWF  x93
038C:  MOVLB  0
038E:  RCALL  0196
....................     read_gyro_word(GYRO_ZOUT_H, GYRO_ZOUT_L, &gyroZ); 
0390:  MOVLW  47
0392:  MOVLB  4
0394:  MOVWF  x91
0396:  MOVLW  48
0398:  MOVWF  x92
039A:  MOVLW  04
039C:  MOVWF  x94
039E:  MOVLW  8F
03A0:  MOVWF  x93
03A2:  MOVLB  0
03A4:  RCALL  0196
....................     gyroData[0] = gyroX / GYRO_SCALE; 
03A6:  MOVFF  489,FE9
03AA:  MOVFF  48A,FEA
03AE:  MOVFF  48C,4B1
03B2:  MOVFF  48B,4B0
03B6:  MOVLB  0
03B8:  RCALL  01B2
03BA:  MOVFF  03,4C0
03BE:  MOVFF  02,4BF
03C2:  MOVFF  01,4BE
03C6:  MOVFF  00,4BD
03CA:  MOVLB  4
03CC:  CLRF   xC4
03CE:  CLRF   xC3
03D0:  MOVLW  03
03D2:  MOVWF  xC2
03D4:  MOVLW  85
03D6:  MOVWF  xC1
03D8:  MOVLB  0
03DA:  RCALL  0202
03DC:  MOVFF  00,FEF
03E0:  MOVFF  01,FEC
03E4:  MOVFF  02,FEC
03E8:  MOVFF  03,FEC
....................     gyroData[1] = gyroY / GYRO_SCALE; 
03EC:  MOVLW  04
03EE:  MOVLB  4
03F0:  ADDWF  x89,W
03F2:  MOVWF  FE9
03F4:  MOVLW  00
03F6:  ADDWFC x8A,W
03F8:  MOVWF  FEA
03FA:  MOVFF  48E,4B1
03FE:  MOVFF  48D,4B0
0402:  MOVLB  0
0404:  RCALL  01B2
0406:  MOVFF  03,4C0
040A:  MOVFF  02,4BF
040E:  MOVFF  01,4BE
0412:  MOVFF  00,4BD
0416:  MOVLB  4
0418:  CLRF   xC4
041A:  CLRF   xC3
041C:  MOVLW  03
041E:  MOVWF  xC2
0420:  MOVLW  85
0422:  MOVWF  xC1
0424:  MOVLB  0
0426:  RCALL  0202
0428:  MOVFF  00,FEF
042C:  MOVFF  01,FEC
0430:  MOVFF  02,FEC
0434:  MOVFF  03,FEC
....................     gyroData[2] = gyroZ / GYRO_SCALE; 
0438:  MOVLW  08
043A:  MOVLB  4
043C:  ADDWF  x89,W
043E:  MOVWF  FE9
0440:  MOVLW  00
0442:  ADDWFC x8A,W
0444:  MOVWF  FEA
0446:  MOVFF  490,4B1
044A:  MOVFF  48F,4B0
044E:  MOVLB  0
0450:  RCALL  01B2
0452:  MOVFF  03,4C0
0456:  MOVFF  02,4BF
045A:  MOVFF  01,4BE
045E:  MOVFF  00,4BD
0462:  MOVLB  4
0464:  CLRF   xC4
0466:  CLRF   xC3
0468:  MOVLW  03
046A:  MOVWF  xC2
046C:  MOVLW  85
046E:  MOVWF  xC1
0470:  MOVLB  0
0472:  RCALL  0202
0474:  MOVFF  00,FEF
0478:  MOVFF  01,FEC
047C:  MOVFF  02,FEC
0480:  MOVFF  03,FEC
0484:  RETURN 0
.................... } 
....................  
.................... // Function to read accelerometer data and convert it to g 
.................... void mpu9250_read_accelerometer(float accelData[] ) { 
*
071A:  MOVLB  4
071C:  CLRF   xA3
071E:  CLRF   xA2
....................     int16_t accelX, accelY, accelZ = 0; 
....................     read_accel_word(ACCEL_XOUT_H, ACCEL_XOUT_L, &accelX); 
0720:  MOVLW  3B
0722:  MOVWF  xA4
0724:  MOVLW  3C
0726:  MOVWF  xA5
0728:  MOVLW  04
072A:  MOVWF  xA7
072C:  MOVLW  9E
072E:  MOVWF  xA6
0730:  MOVLB  0
0732:  RCALL  0486
....................     read_accel_word(ACCEL_YOUT_H, ACCEL_YOUT_L, &accelY); 
0734:  MOVLW  3D
0736:  MOVLB  4
0738:  MOVWF  xA4
073A:  MOVLW  3E
073C:  MOVWF  xA5
073E:  MOVLW  04
0740:  MOVWF  xA7
0742:  MOVLW  A0
0744:  MOVWF  xA6
0746:  MOVLB  0
0748:  RCALL  0486
....................     read_accel_word(ACCEL_ZOUT_H, ACCEL_ZOUT_L, &accelZ); 
074A:  MOVLW  3F
074C:  MOVLB  4
074E:  MOVWF  xA4
0750:  MOVLW  40
0752:  MOVWF  xA5
0754:  MOVLW  04
0756:  MOVWF  xA7
0758:  MOVLW  A2
075A:  MOVWF  xA6
075C:  MOVLB  0
075E:  RCALL  0486
....................     accelData[0] = (accelX / ACCEL_SCALE) +ACCEL_X_OFFSET; 
0760:  MOVFF  49C,FE9
0764:  MOVFF  49D,FEA
0768:  MOVFF  49F,4B1
076C:  MOVFF  49E,4B0
0770:  MOVLB  0
0772:  RCALL  01B2
0774:  MOVFF  03,4C0
0778:  MOVFF  02,4BF
077C:  MOVFF  01,4BE
0780:  MOVFF  00,4BD
0784:  MOVLB  4
0786:  CLRF   xC4
0788:  CLRF   xC3
078A:  CLRF   xC2
078C:  MOVLW  8B
078E:  MOVWF  xC1
0790:  MOVLB  0
0792:  RCALL  0202
0794:  MOVFF  03,4A9
0798:  MOVFF  02,4A8
079C:  MOVFF  01,4A7
07A0:  MOVFF  00,4A6
07A4:  MOVFF  FEA,4AB
07A8:  MOVFF  FE9,4AA
07AC:  BCF    FD8.1
07AE:  MOVFF  03,4C0
07B2:  MOVFF  02,4BF
07B6:  MOVFF  01,4BE
07BA:  MOVFF  00,4BD
07BE:  MOVLW  0A
07C0:  MOVLB  4
07C2:  MOVWF  xC4
07C4:  MOVLW  D7
07C6:  MOVWF  xC3
07C8:  MOVLW  23
07CA:  MOVWF  xC2
07CC:  MOVLW  77
07CE:  MOVWF  xC1
07D0:  MOVLB  0
07D2:  RCALL  04A2
07D4:  MOVFF  4AB,FEA
07D8:  MOVFF  4AA,FE9
07DC:  MOVFF  00,FEF
07E0:  MOVFF  01,FEC
07E4:  MOVFF  02,FEC
07E8:  MOVFF  03,FEC
....................     accelData[1] = (accelY / ACCEL_SCALE) -ACCEL_Y_OFFSET; 
07EC:  MOVLW  04
07EE:  MOVLB  4
07F0:  ADDWF  x9C,W
07F2:  MOVWF  FE9
07F4:  MOVLW  00
07F6:  ADDWFC x9D,W
07F8:  MOVWF  FEA
07FA:  MOVFF  4A1,4B1
07FE:  MOVFF  4A0,4B0
0802:  MOVLB  0
0804:  RCALL  01B2
0806:  MOVFF  03,4C0
080A:  MOVFF  02,4BF
080E:  MOVFF  01,4BE
0812:  MOVFF  00,4BD
0816:  MOVLB  4
0818:  CLRF   xC4
081A:  CLRF   xC3
081C:  CLRF   xC2
081E:  MOVLW  8B
0820:  MOVWF  xC1
0822:  MOVLB  0
0824:  RCALL  0202
0826:  MOVFF  03,4A9
082A:  MOVFF  02,4A8
082E:  MOVFF  01,4A7
0832:  MOVFF  00,4A6
0836:  MOVFF  FEA,4AB
083A:  MOVFF  FE9,4AA
083E:  BSF    FD8.1
0840:  MOVFF  03,4C0
0844:  MOVFF  02,4BF
0848:  MOVFF  01,4BE
084C:  MOVFF  00,4BD
0850:  MOVLW  FA
0852:  MOVLB  4
0854:  MOVWF  xC4
0856:  MOVLW  ED
0858:  MOVWF  xC3
085A:  MOVLW  6B
085C:  MOVWF  xC2
085E:  MOVLW  78
0860:  MOVWF  xC1
0862:  MOVLB  0
0864:  RCALL  04A2
0866:  MOVFF  4AB,FEA
086A:  MOVFF  4AA,FE9
086E:  MOVFF  00,FEF
0872:  MOVFF  01,FEC
0876:  MOVFF  02,FEC
087A:  MOVFF  03,FEC
....................     accelData[2] = (accelZ / ACCEL_SCALE) +ACCEL_Z_OFFSET; 
087E:  MOVLW  08
0880:  MOVLB  4
0882:  ADDWF  x9C,W
0884:  MOVWF  FE9
0886:  MOVLW  00
0888:  ADDWFC x9D,W
088A:  MOVWF  FEA
088C:  MOVFF  4A3,4B1
0890:  MOVFF  4A2,4B0
0894:  MOVLB  0
0896:  RCALL  01B2
0898:  MOVFF  03,4C0
089C:  MOVFF  02,4BF
08A0:  MOVFF  01,4BE
08A4:  MOVFF  00,4BD
08A8:  MOVLB  4
08AA:  CLRF   xC4
08AC:  CLRF   xC3
08AE:  CLRF   xC2
08B0:  MOVLW  8B
08B2:  MOVWF  xC1
08B4:  MOVLB  0
08B6:  RCALL  0202
08B8:  MOVFF  03,4A9
08BC:  MOVFF  02,4A8
08C0:  MOVFF  01,4A7
08C4:  MOVFF  00,4A6
08C8:  MOVFF  FEA,4AB
08CC:  MOVFF  FE9,4AA
08D0:  BCF    FD8.1
08D2:  MOVFF  03,4C0
08D6:  MOVFF  02,4BF
08DA:  MOVFF  01,4BE
08DE:  MOVFF  00,4BD
08E2:  MOVLW  79
08E4:  MOVLB  4
08E6:  MOVWF  xC4
08E8:  MOVLW  01
08EA:  MOVWF  xC3
08EC:  MOVLW  76
08EE:  MOVWF  xC2
08F0:  MOVLW  7A
08F2:  MOVWF  xC1
08F4:  MOVLB  0
08F6:  RCALL  04A2
08F8:  MOVFF  4AB,FEA
08FC:  MOVFF  4AA,FE9
0900:  MOVFF  00,FEF
0904:  MOVFF  01,FEC
0908:  MOVFF  02,FEC
090C:  MOVFF  03,FEC
0910:  GOTO   14EA (RETURN)
.................... } 
....................  
.................... //Function to read magnetometer data and convert it to uT 
.................... void mpu9250_read_magnometer(float magData[]) { 
*
0A5C:  MOVLB  4
0A5E:  CLRF   xA3
0A60:  CLRF   xA2
0A62:  MOVLW  F0
0A64:  MOVWF  xA7
....................  
....................     int16_t magX, magY, magZ = 0; 
....................     uint8_t x_axis , y_axis , z_axis ; 
....................     uint8_t status = 0xF0; 
....................  
....................     mpu9250_readByte( MPU9250_ADDRESS,AK8963_ASAX , &x_axis ); 
0A66:  MOVLW  68
0A68:  MOVWF  xB3
0A6A:  MOVLW  10
0A6C:  MOVWF  xB4
0A6E:  MOVLW  04
0A70:  MOVWF  xB6
0A72:  MOVLW  A4
0A74:  MOVWF  xB5
0A76:  MOVLB  0
0A78:  CALL   0102
....................     mpu9250_readByte( MPU9250_ADDRESS,AK8963_ASAY , &y_axis ); 
0A7C:  MOVLW  68
0A7E:  MOVLB  4
0A80:  MOVWF  xB3
0A82:  MOVLW  11
0A84:  MOVWF  xB4
0A86:  MOVLW  04
0A88:  MOVWF  xB6
0A8A:  MOVLW  A5
0A8C:  MOVWF  xB5
0A8E:  MOVLB  0
0A90:  CALL   0102
....................     mpu9250_readByte( MPU9250_ADDRESS,AK8963_ASAZ , &z_axis ); 
0A94:  MOVLW  68
0A96:  MOVLB  4
0A98:  MOVWF  xB3
0A9A:  MOVLW  12
0A9C:  MOVWF  xB4
0A9E:  MOVLW  04
0AA0:  MOVWF  xB6
0AA2:  MOVLW  A6
0AA4:  MOVWF  xB5
0AA6:  MOVLB  0
0AA8:  CALL   0102
....................  
....................      
....................      
....................     // Check if the data is ready polling ST1 
....................     while(status & 0x01  == 0x01) 
0AAC:  MOVLB  4
0AAE:  BTFSS  xA7.0
0AB0:  BRA    0ACC
....................     { 
....................         mpu9250_readByte(AK8963_ADDRESS, AK8963_ST1_REG, &status); 
0AB2:  MOVLW  0C
0AB4:  MOVWF  xB3
0AB6:  MOVLW  02
0AB8:  MOVWF  xB4
0ABA:  MOVLW  04
0ABC:  MOVWF  xB6
0ABE:  MOVLW  A7
0AC0:  MOVWF  xB5
0AC2:  MOVLB  0
0AC4:  CALL   0102
0AC8:  BRA    0AAC
0ACA:  MOVLB  4
....................      
....................     } 
....................      
....................     read_mag_word(MAG_XOUT_H, MAG_XOUT_L, &magX); 
0ACC:  MOVLW  04
0ACE:  MOVWF  xA8
0AD0:  MOVLW  03
0AD2:  MOVWF  xA9
0AD4:  MOVLW  04
0AD6:  MOVWF  xAB
0AD8:  MOVLW  9E
0ADA:  MOVWF  xAA
0ADC:  MOVLB  0
0ADE:  RCALL  0914
....................         read_mag_word(MAG_YOUT_H, MAG_YOUT_L, &magY); 
0AE0:  MOVLW  06
0AE2:  MOVLB  4
0AE4:  MOVWF  xA8
0AE6:  MOVLW  05
0AE8:  MOVWF  xA9
0AEA:  MOVLW  04
0AEC:  MOVWF  xAB
0AEE:  MOVLW  A0
0AF0:  MOVWF  xAA
0AF2:  MOVLB  0
0AF4:  RCALL  0914
....................         read_mag_word(MAG_ZOUT_H, MAG_ZOUT_L, &magZ); 
0AF6:  MOVLW  08
0AF8:  MOVLB  4
0AFA:  MOVWF  xA8
0AFC:  MOVLW  07
0AFE:  MOVWF  xA9
0B00:  MOVLW  04
0B02:  MOVWF  xAB
0B04:  MOVLW  A2
0B06:  MOVWF  xAA
0B08:  MOVLB  0
0B0A:  RCALL  0914
....................         // Convert the magnetometer data to uT 
....................         magData[0] = magX *((x_axis-128)*0.5 /128 +1); 
0B0C:  MOVLB  4
0B0E:  MOVFF  49C,FE9
0B12:  MOVFF  49D,FEA
0B16:  MOVLW  80
0B18:  SUBWF  xA4,W
0B1A:  CLRF   xAC
0B1C:  MOVWF  xAB
0B1E:  MOVLB  0
0B20:  RCALL  0930
0B22:  MOVFF  03,4C0
0B26:  MOVFF  02,4BF
0B2A:  MOVFF  01,4BE
0B2E:  MOVFF  00,4BD
0B32:  MOVLB  4
0B34:  CLRF   xC4
0B36:  CLRF   xC3
0B38:  CLRF   xC2
0B3A:  MOVLW  7E
0B3C:  MOVWF  xC1
0B3E:  MOVLB  0
0B40:  RCALL  0966
0B42:  MOVFF  03,4AD
0B46:  MOVFF  02,4AC
0B4A:  MOVFF  01,4AB
0B4E:  MOVFF  00,4AA
0B52:  MOVFF  03,4C0
0B56:  MOVFF  02,4BF
0B5A:  MOVFF  01,4BE
0B5E:  MOVFF  00,4BD
0B62:  MOVLB  4
0B64:  CLRF   xC4
0B66:  CLRF   xC3
0B68:  CLRF   xC2
0B6A:  MOVLW  86
0B6C:  MOVWF  xC1
0B6E:  MOVLB  0
0B70:  CALL   0202
0B74:  MOVFF  03,4AD
0B78:  MOVFF  02,4AC
0B7C:  MOVFF  01,4AB
0B80:  MOVFF  00,4AA
0B84:  MOVFF  FEA,4AF
0B88:  MOVFF  FE9,4AE
0B8C:  BCF    FD8.1
0B8E:  MOVFF  03,4C0
0B92:  MOVFF  02,4BF
0B96:  MOVFF  01,4BE
0B9A:  MOVFF  00,4BD
0B9E:  MOVLB  4
0BA0:  CLRF   xC4
0BA2:  CLRF   xC3
0BA4:  CLRF   xC2
0BA6:  MOVLW  7F
0BA8:  MOVWF  xC1
0BAA:  MOVLB  0
0BAC:  RCALL  04A2
0BAE:  MOVFF  4AF,FEA
0BB2:  MOVFF  4AE,FE9
0BB6:  MOVFF  03,4AD
0BBA:  MOVFF  02,4AC
0BBE:  MOVFF  01,4AB
0BC2:  MOVFF  00,4AA
0BC6:  MOVFF  49F,4B1
0BCA:  MOVFF  49E,4B0
0BCE:  CALL   01B2
0BD2:  MOVFF  03,4C0
0BD6:  MOVFF  02,4BF
0BDA:  MOVFF  01,4BE
0BDE:  MOVFF  00,4BD
0BE2:  MOVFF  4AD,4C4
0BE6:  MOVFF  4AC,4C3
0BEA:  MOVFF  4AB,4C2
0BEE:  MOVFF  4AA,4C1
0BF2:  RCALL  0966
0BF4:  MOVFF  00,FEF
0BF8:  MOVFF  01,FEC
0BFC:  MOVFF  02,FEC
0C00:  MOVFF  03,FEC
....................         magData[1] = magY *((y_axis-128)*0.5 /128 +1) ; 
0C04:  MOVLW  04
0C06:  MOVLB  4
0C08:  ADDWF  x9C,W
0C0A:  MOVWF  FE9
0C0C:  MOVLW  00
0C0E:  ADDWFC x9D,W
0C10:  MOVWF  FEA
0C12:  MOVLW  80
0C14:  SUBWF  xA5,W
0C16:  CLRF   xAC
0C18:  MOVWF  xAB
0C1A:  MOVLB  0
0C1C:  RCALL  0930
0C1E:  MOVFF  03,4C0
0C22:  MOVFF  02,4BF
0C26:  MOVFF  01,4BE
0C2A:  MOVFF  00,4BD
0C2E:  MOVLB  4
0C30:  CLRF   xC4
0C32:  CLRF   xC3
0C34:  CLRF   xC2
0C36:  MOVLW  7E
0C38:  MOVWF  xC1
0C3A:  MOVLB  0
0C3C:  RCALL  0966
0C3E:  MOVFF  03,4AD
0C42:  MOVFF  02,4AC
0C46:  MOVFF  01,4AB
0C4A:  MOVFF  00,4AA
0C4E:  MOVFF  03,4C0
0C52:  MOVFF  02,4BF
0C56:  MOVFF  01,4BE
0C5A:  MOVFF  00,4BD
0C5E:  MOVLB  4
0C60:  CLRF   xC4
0C62:  CLRF   xC3
0C64:  CLRF   xC2
0C66:  MOVLW  86
0C68:  MOVWF  xC1
0C6A:  MOVLB  0
0C6C:  CALL   0202
0C70:  MOVFF  03,4AD
0C74:  MOVFF  02,4AC
0C78:  MOVFF  01,4AB
0C7C:  MOVFF  00,4AA
0C80:  MOVFF  FEA,4AF
0C84:  MOVFF  FE9,4AE
0C88:  BCF    FD8.1
0C8A:  MOVFF  03,4C0
0C8E:  MOVFF  02,4BF
0C92:  MOVFF  01,4BE
0C96:  MOVFF  00,4BD
0C9A:  MOVLB  4
0C9C:  CLRF   xC4
0C9E:  CLRF   xC3
0CA0:  CLRF   xC2
0CA2:  MOVLW  7F
0CA4:  MOVWF  xC1
0CA6:  MOVLB  0
0CA8:  CALL   04A2
0CAC:  MOVFF  4AF,FEA
0CB0:  MOVFF  4AE,FE9
0CB4:  MOVFF  03,4AD
0CB8:  MOVFF  02,4AC
0CBC:  MOVFF  01,4AB
0CC0:  MOVFF  00,4AA
0CC4:  MOVFF  4A1,4B1
0CC8:  MOVFF  4A0,4B0
0CCC:  CALL   01B2
0CD0:  MOVFF  03,4C0
0CD4:  MOVFF  02,4BF
0CD8:  MOVFF  01,4BE
0CDC:  MOVFF  00,4BD
0CE0:  MOVFF  4AD,4C4
0CE4:  MOVFF  4AC,4C3
0CE8:  MOVFF  4AB,4C2
0CEC:  MOVFF  4AA,4C1
0CF0:  RCALL  0966
0CF2:  MOVFF  00,FEF
0CF6:  MOVFF  01,FEC
0CFA:  MOVFF  02,FEC
0CFE:  MOVFF  03,FEC
....................         magData[2] =  magZ *((z_axis-128)*0.5 /128 +1) ; 
0D02:  MOVLW  08
0D04:  MOVLB  4
0D06:  ADDWF  x9C,W
0D08:  MOVWF  FE9
0D0A:  MOVLW  00
0D0C:  ADDWFC x9D,W
0D0E:  MOVWF  FEA
0D10:  MOVLW  80
0D12:  SUBWF  xA6,W
0D14:  CLRF   xAC
0D16:  MOVWF  xAB
0D18:  MOVLB  0
0D1A:  RCALL  0930
0D1C:  MOVFF  03,4C0
0D20:  MOVFF  02,4BF
0D24:  MOVFF  01,4BE
0D28:  MOVFF  00,4BD
0D2C:  MOVLB  4
0D2E:  CLRF   xC4
0D30:  CLRF   xC3
0D32:  CLRF   xC2
0D34:  MOVLW  7E
0D36:  MOVWF  xC1
0D38:  MOVLB  0
0D3A:  RCALL  0966
0D3C:  MOVFF  03,4AD
0D40:  MOVFF  02,4AC
0D44:  MOVFF  01,4AB
0D48:  MOVFF  00,4AA
0D4C:  MOVFF  03,4C0
0D50:  MOVFF  02,4BF
0D54:  MOVFF  01,4BE
0D58:  MOVFF  00,4BD
0D5C:  MOVLB  4
0D5E:  CLRF   xC4
0D60:  CLRF   xC3
0D62:  CLRF   xC2
0D64:  MOVLW  86
0D66:  MOVWF  xC1
0D68:  MOVLB  0
0D6A:  CALL   0202
0D6E:  MOVFF  03,4AD
0D72:  MOVFF  02,4AC
0D76:  MOVFF  01,4AB
0D7A:  MOVFF  00,4AA
0D7E:  MOVFF  FEA,4AF
0D82:  MOVFF  FE9,4AE
0D86:  BCF    FD8.1
0D88:  MOVFF  03,4C0
0D8C:  MOVFF  02,4BF
0D90:  MOVFF  01,4BE
0D94:  MOVFF  00,4BD
0D98:  MOVLB  4
0D9A:  CLRF   xC4
0D9C:  CLRF   xC3
0D9E:  CLRF   xC2
0DA0:  MOVLW  7F
0DA2:  MOVWF  xC1
0DA4:  MOVLB  0
0DA6:  CALL   04A2
0DAA:  MOVFF  4AF,FEA
0DAE:  MOVFF  4AE,FE9
0DB2:  MOVFF  03,4AD
0DB6:  MOVFF  02,4AC
0DBA:  MOVFF  01,4AB
0DBE:  MOVFF  00,4AA
0DC2:  MOVFF  4A3,4B1
0DC6:  MOVFF  4A2,4B0
0DCA:  CALL   01B2
0DCE:  MOVFF  03,4C0
0DD2:  MOVFF  02,4BF
0DD6:  MOVFF  01,4BE
0DDA:  MOVFF  00,4BD
0DDE:  MOVFF  4AD,4C4
0DE2:  MOVFF  4AC,4C3
0DE6:  MOVFF  4AB,4C2
0DEA:  MOVFF  4AA,4C1
0DEE:  RCALL  0966
0DF0:  MOVFF  00,FEF
0DF4:  MOVFF  01,FEC
0DF8:  MOVFF  02,FEC
0DFC:  MOVFF  03,FEC
....................     mpu9250_readByte(AK8963_ADDRESS, AK8963_ST2_REG, &status); 
0E00:  MOVLW  0C
0E02:  MOVLB  4
0E04:  MOVWF  xB3
0E06:  MOVLW  09
0E08:  MOVWF  xB4
0E0A:  MOVLW  04
0E0C:  MOVWF  xB6
0E0E:  MOVLW  A7
0E10:  MOVWF  xB5
0E12:  MOVLB  0
0E14:  CALL   0102
0E18:  GOTO   14F6 (RETURN)
....................      
....................  
.................... } 
....................  
.................... void mpu9250_print_module_values() { 
....................  
....................     // Read the gyro values 
....................     mpu9250_read_gyro(gyro); 
....................     mpu9250_read_magnometer(mag); 
....................     mpu9250_read_accelerometer(accel); 
....................  
....................     // Read the mag values 
....................     printf(ANSI_COLOR_YELLOW"Gyro : X = %.5f, Y = %.5f, Z = %.5f (deg/s)   \t"ANSI_COLOR_RESET, gyro[0], gyro[1], gyro[2]); 
....................     printf(ANSI_COLOR_YELLOW"Mag  : X = %.5f, Y = %.5f, Z = %.5f (uT)      \t"ANSI_COLOR_RESET,  mag[0],  mag[1],  mag[2]); 
....................     printf(ANSI_COLOR_YELLOW"Accel: X = %.5f, Y = %.5f, Z = %.5f (g)     \n\r"ANSI_COLOR_RESET,accel[0],accel[1],accel[2]); 
....................      
.................... } 
....................  
....................  
....................  
.................... // Function to calibrate the accelerometer 
.................... void mpu9250_gyro_calibration( RateCalibration_t *RateCalibration ) 
.................... { 
....................  
....................     for (uint16_t RateCalibrationNumber=0; RateCalibrationNumber<2000; RateCalibrationNumber ++) { 
*
28EC:  MOVLB  4
28EE:  CLRF   x6E
28F0:  CLRF   x6D
28F2:  MOVF   x6E,W
28F4:  SUBLW  07
28F6:  BTFSS  FD8.0
28F8:  BRA    2A52
28FA:  BNZ   2904
28FC:  MOVF   x6D,W
28FE:  SUBLW  CF
2900:  BTFSS  FD8.0
2902:  BRA    2A52
2904:  CLRF   16
2906:  BTFSC  FF2.7
2908:  BSF    16.7
290A:  BCF    FF2.7
....................         mpu9250_read_gyro(gyro); 
290C:  CLRF   x8A
290E:  MOVLW  1D
2910:  MOVWF  x89
2912:  MOVLB  0
2914:  CALL   0360
2918:  BTFSC  16.7
291A:  BSF    FF2.7
....................         RateCalibration->roll += gyro[0];     //calculate average value of gyro in x axis 
291C:  MOVLW  04
291E:  MOVLB  4
2920:  ADDWF  x6B,W
2922:  MOVWF  FE9
2924:  MOVLW  00
2926:  ADDWFC x6C,W
2928:  MOVWF  FEA
292A:  MOVFF  FEA,476
292E:  MOVFF  FE9,475
2932:  BCF    FD8.1
2934:  CLRF   16
2936:  BTFSC  FF2.7
2938:  BSF    16.7
293A:  BCF    FF2.7
293C:  MOVFF  FEF,4BD
2940:  MOVFF  FEC,4BE
2944:  MOVFF  FEC,4BF
2948:  MOVFF  FEC,4C0
294C:  MOVFF  20,4C4
2950:  MOVFF  1F,4C3
2954:  MOVFF  1E,4C2
2958:  MOVFF  1D,4C1
295C:  MOVLB  0
295E:  CALL   04A2
2962:  BTFSC  16.7
2964:  BSF    FF2.7
2966:  MOVFF  476,FEA
296A:  MOVFF  475,FE9
296E:  MOVFF  00,FEF
2972:  MOVFF  01,FEC
2976:  MOVFF  02,FEC
297A:  MOVFF  03,FEC
....................         RateCalibration->pitch  += gyro[1];     //calculate average value of gyro in y axis 
297E:  MOVLB  4
2980:  MOVFF  46B,FE9
2984:  MOVFF  46C,FEA
2988:  MOVFF  FEA,476
298C:  MOVFF  FE9,475
2990:  BCF    FD8.1
2992:  CLRF   16
2994:  BTFSC  FF2.7
2996:  BSF    16.7
2998:  BCF    FF2.7
299A:  MOVFF  FEF,4BD
299E:  MOVFF  FEC,4BE
29A2:  MOVFF  FEC,4BF
29A6:  MOVFF  FEC,4C0
29AA:  MOVFF  24,4C4
29AE:  MOVFF  23,4C3
29B2:  MOVFF  22,4C2
29B6:  MOVFF  21,4C1
29BA:  MOVLB  0
29BC:  CALL   04A2
29C0:  BTFSC  16.7
29C2:  BSF    FF2.7
29C4:  MOVFF  476,FEA
29C8:  MOVFF  475,FE9
29CC:  MOVFF  00,FEF
29D0:  MOVFF  01,FEC
29D4:  MOVFF  02,FEC
29D8:  MOVFF  03,FEC
....................         RateCalibration->yaw   += gyro[2];     //calculate average value of gyro in z axis 
29DC:  MOVLW  08
29DE:  MOVLB  4
29E0:  ADDWF  x6B,W
29E2:  MOVWF  FE9
29E4:  MOVLW  00
29E6:  ADDWFC x6C,W
29E8:  MOVWF  FEA
29EA:  MOVFF  FEA,476
29EE:  MOVFF  FE9,475
29F2:  BCF    FD8.1
29F4:  CLRF   16
29F6:  BTFSC  FF2.7
29F8:  BSF    16.7
29FA:  BCF    FF2.7
29FC:  MOVFF  FEF,4BD
2A00:  MOVFF  FEC,4BE
2A04:  MOVFF  FEC,4BF
2A08:  MOVFF  FEC,4C0
2A0C:  MOVFF  28,4C4
2A10:  MOVFF  27,4C3
2A14:  MOVFF  26,4C2
2A18:  MOVFF  25,4C1
2A1C:  MOVLB  0
2A1E:  CALL   04A2
2A22:  BTFSC  16.7
2A24:  BSF    FF2.7
2A26:  MOVFF  476,FEA
2A2A:  MOVFF  475,FE9
2A2E:  MOVFF  00,FEF
2A32:  MOVFF  01,FEC
2A36:  MOVFF  02,FEC
2A3A:  MOVFF  03,FEC
....................  
....................         delay_ms(1) ; 
2A3E:  MOVLW  01
2A40:  MOVLB  4
2A42:  MOVWF  x6F
2A44:  MOVLB  0
2A46:  RCALL  24A6
2A48:  MOVLB  4
2A4A:  INCF   x6D,F
2A4C:  BTFSC  FD8.2
2A4E:  INCF   x6E,F
2A50:  BRA    28F2
....................     } 
....................     RateCalibration->roll /= 2000;     //calculate average value of gyro in x axis 
2A52:  MOVLW  04
2A54:  ADDWF  x6B,W
2A56:  MOVWF  FE9
2A58:  MOVLW  00
2A5A:  ADDWFC x6C,W
2A5C:  MOVWF  FEA
2A5E:  CLRF   16
2A60:  BTFSC  FF2.7
2A62:  BSF    16.7
2A64:  BCF    FF2.7
2A66:  MOVFF  FEF,4BD
2A6A:  MOVFF  FEC,4BE
2A6E:  MOVFF  FEC,4BF
2A72:  MOVFF  FEC,4C0
2A76:  MOVF   FED,F
2A78:  MOVF   FED,F
2A7A:  MOVF   FED,F
2A7C:  CLRF   xC4
2A7E:  CLRF   xC3
2A80:  MOVLW  7A
2A82:  MOVWF  xC2
2A84:  MOVLW  89
2A86:  MOVWF  xC1
2A88:  MOVLB  0
2A8A:  CALL   0202
2A8E:  BTFSC  16.7
2A90:  BSF    FF2.7
2A92:  MOVFF  00,FEF
2A96:  MOVFF  01,FEC
2A9A:  MOVFF  02,FEC
2A9E:  MOVFF  03,FEC
....................     RateCalibration->pitch  /= 2000;     //calculate average value of gyro in y axis 
2AA2:  MOVLB  4
2AA4:  MOVFF  46B,FE9
2AA8:  MOVFF  46C,FEA
2AAC:  CLRF   16
2AAE:  BTFSC  FF2.7
2AB0:  BSF    16.7
2AB2:  BCF    FF2.7
2AB4:  MOVFF  FEF,4BD
2AB8:  MOVFF  FEC,4BE
2ABC:  MOVFF  FEC,4BF
2AC0:  MOVFF  FEC,4C0
2AC4:  MOVF   FED,F
2AC6:  MOVF   FED,F
2AC8:  MOVF   FED,F
2ACA:  CLRF   xC4
2ACC:  CLRF   xC3
2ACE:  MOVLW  7A
2AD0:  MOVWF  xC2
2AD2:  MOVLW  89
2AD4:  MOVWF  xC1
2AD6:  MOVLB  0
2AD8:  CALL   0202
2ADC:  BTFSC  16.7
2ADE:  BSF    FF2.7
2AE0:  MOVFF  00,FEF
2AE4:  MOVFF  01,FEC
2AE8:  MOVFF  02,FEC
2AEC:  MOVFF  03,FEC
....................     RateCalibration->yaw   /= 2000;     //calculate average value of gyro in z axis 
2AF0:  MOVLW  08
2AF2:  MOVLB  4
2AF4:  ADDWF  x6B,W
2AF6:  MOVWF  FE9
2AF8:  MOVLW  00
2AFA:  ADDWFC x6C,W
2AFC:  MOVWF  FEA
2AFE:  CLRF   16
2B00:  BTFSC  FF2.7
2B02:  BSF    16.7
2B04:  BCF    FF2.7
2B06:  MOVFF  FEF,4BD
2B0A:  MOVFF  FEC,4BE
2B0E:  MOVFF  FEC,4BF
2B12:  MOVFF  FEC,4C0
2B16:  MOVF   FED,F
2B18:  MOVF   FED,F
2B1A:  MOVF   FED,F
2B1C:  CLRF   xC4
2B1E:  CLRF   xC3
2B20:  MOVLW  7A
2B22:  MOVWF  xC2
2B24:  MOVLW  89
2B26:  MOVWF  xC1
2B28:  MOVLB  0
2B2A:  CALL   0202
2B2E:  BTFSC  16.7
2B30:  BSF    FF2.7
2B32:  MOVFF  00,FEF
2B36:  MOVFF  01,FEC
2B3A:  MOVFF  02,FEC
2B3E:  MOVFF  03,FEC
2B42:  GOTO   2FC0 (RETURN)
....................  
....................  
.................... } 
....................  
....................  
.................... // Function to calculate the yaw, pitch and roll angles 
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[],float magData[]) 
.................... { 
....................  
....................         // Read the accelerometer and magnetometer values 
....................         mpu9250_read_accelerometer(accelData); 
*
14DE:  MOVFF  48C,49D
14E2:  MOVFF  48B,49C
14E6:  GOTO   071A
....................         mpu9250_read_magnometer(magData); 
14EA:  MOVFF  48E,49D
14EE:  MOVFF  48D,49C
14F2:  GOTO   0A5C
....................         float hi_cal [3]; 
....................          
....................         hi_cal[0] =  magData[0] - hard_iron[0];        
14F6:  MOVLB  4
14F8:  MOVFF  48D,FE9
14FC:  MOVFF  48E,FEA
1500:  MOVFF  FEF,49C
1504:  MOVFF  FEC,49D
1508:  MOVFF  FEC,49E
150C:  MOVFF  FEC,49F
1510:  MOVFF  FEA,4A1
1514:  MOVFF  FE9,4A0
1518:  BSF    FD8.1
151A:  MOVFF  49F,4C0
151E:  MOVFF  49E,4BF
1522:  MOVFF  49D,4BE
1526:  MOVFF  49C,4BD
152A:  MOVLW  3D
152C:  MOVWF  xC4
152E:  MOVLW  5A
1530:  MOVWF  xC3
1532:  MOVLW  12
1534:  MOVWF  xC2
1536:  MOVLW  87
1538:  MOVWF  xC1
153A:  MOVLB  0
153C:  CALL   04A2
1540:  MOVFF  4A1,FEA
1544:  MOVFF  4A0,FE9
1548:  MOVFF  03,492
154C:  MOVFF  02,491
1550:  MOVFF  01,490
1554:  MOVFF  00,48F
....................         hi_cal[1] =  magData[1] - hard_iron[1];        
1558:  MOVLW  04
155A:  MOVLB  4
155C:  ADDWF  x8D,W
155E:  MOVWF  FE9
1560:  MOVLW  00
1562:  ADDWFC x8E,W
1564:  MOVWF  FEA
1566:  MOVFF  FEF,49C
156A:  MOVFF  FEC,49D
156E:  MOVFF  FEC,49E
1572:  MOVFF  FEC,49F
1576:  MOVFF  FEA,4A1
157A:  MOVFF  FE9,4A0
157E:  BSF    FD8.1
1580:  MOVFF  49F,4C0
1584:  MOVFF  49E,4BF
1588:  MOVFF  49D,4BE
158C:  MOVFF  49C,4BD
1590:  MOVLW  EC
1592:  MOVWF  xC4
1594:  MOVLW  E1
1596:  MOVWF  xC3
1598:  MOVLW  39
159A:  MOVWF  xC2
159C:  MOVLW  87
159E:  MOVWF  xC1
15A0:  MOVLB  0
15A2:  CALL   04A2
15A6:  MOVFF  4A1,FEA
15AA:  MOVFF  4A0,FE9
15AE:  MOVFF  03,496
15B2:  MOVFF  02,495
15B6:  MOVFF  01,494
15BA:  MOVFF  00,493
....................         hi_cal[2] =  magData[2] - hard_iron[2];        
15BE:  MOVLW  08
15C0:  MOVLB  4
15C2:  ADDWF  x8D,W
15C4:  MOVWF  FE9
15C6:  MOVLW  00
15C8:  ADDWFC x8E,W
15CA:  MOVWF  FEA
15CC:  MOVFF  FEF,49C
15D0:  MOVFF  FEC,49D
15D4:  MOVFF  FEC,49E
15D8:  MOVFF  FEC,49F
15DC:  MOVFF  FEA,4A1
15E0:  MOVFF  FE9,4A0
15E4:  BSF    FD8.1
15E6:  MOVFF  49F,4C0
15EA:  MOVFF  49E,4BF
15EE:  MOVFF  49D,4BE
15F2:  MOVFF  49C,4BD
15F6:  MOVLW  9A
15F8:  MOVWF  xC4
15FA:  MOVLW  F9
15FC:  MOVWF  xC3
15FE:  MOVLW  83
1600:  MOVWF  xC2
1602:  MOVLW  87
1604:  MOVWF  xC1
1606:  MOVLB  0
1608:  CALL   04A2
160C:  MOVFF  4A1,FEA
1610:  MOVFF  4A0,FE9
1614:  MOVFF  03,49A
1618:  MOVFF  02,499
161C:  MOVFF  01,498
1620:  MOVFF  00,497
....................          
....................         for(uint8_t i = 0 ;i<3;i++) 
1624:  MOVLB  4
1626:  CLRF   x9B
1628:  MOVF   x9B,W
162A:  SUBLW  02
162C:  BTFSS  FD8.0
162E:  BRA    1824
....................         { 
....................             magData[i] = (soft_iron[i][0] * hi_cal[0])+ 
....................                          (soft_iron[i][1] * hi_cal[1])+ 
....................                          (soft_iron[i][2] * hi_cal[2]); 
1630:  MOVF   x9B,W
1632:  MULLW  04
1634:  MOVF   FF3,W
1636:  CLRF   03
1638:  ADDWF  x8D,W
163A:  MOVWF  FE9
163C:  MOVF   x8E,W
163E:  ADDWFC 03,W
1640:  MOVWF  FEA
1642:  MOVF   x9B,W
1644:  MULLW  0C
1646:  MOVF   FF3,W
1648:  CLRF   x9F
164A:  MOVWF  x9E
164C:  MOVFF  49F,03
1650:  MOVF   x9E,W
1652:  MOVFF  FF2,4A0
1656:  BCF    FF2.7
1658:  MOVLB  0
165A:  CALL   0096
165E:  MOVWF  00
1660:  TBLRD*+
1662:  MOVFF  FF5,01
1666:  TBLRD*+
1668:  MOVFF  FF5,02
166C:  TBLRD*+
166E:  MOVFF  FF5,03
1672:  MOVLB  4
1674:  BTFSC  xA0.7
1676:  BSF    FF2.7
1678:  MOVWF  xA0
167A:  MOVFF  03,4A1
167E:  CLRF   xA2
1680:  CLRF   xA3
1682:  MOVFF  4A3,4C0
1686:  MOVFF  4A2,4BF
168A:  MOVFF  03,4BE
168E:  MOVWF  xBD
1690:  MOVFF  492,4C4
1694:  MOVFF  491,4C3
1698:  MOVFF  490,4C2
169C:  MOVFF  48F,4C1
16A0:  MOVLB  0
16A2:  CALL   0966
16A6:  MOVFF  03,4A3
16AA:  MOVFF  02,4A2
16AE:  MOVFF  01,4A1
16B2:  MOVFF  00,4A0
16B6:  MOVLB  4
16B8:  MOVF   x9B,W
16BA:  MULLW  0C
16BC:  MOVF   FF3,W
16BE:  CLRF   xA5
16C0:  MOVWF  xA4
16C2:  MOVLW  04
16C4:  ADDWF  xA4,W
16C6:  MOVWF  01
16C8:  MOVLW  00
16CA:  ADDWFC xA5,W
16CC:  MOVWF  03
16CE:  MOVF   01,W
16D0:  MOVFF  FF2,4A4
16D4:  BCF    FF2.7
16D6:  MOVLB  0
16D8:  CALL   0096
16DC:  MOVWF  00
16DE:  TBLRD*+
16E0:  MOVFF  FF5,01
16E4:  TBLRD*+
16E6:  MOVFF  FF5,02
16EA:  TBLRD*+
16EC:  MOVFF  FF5,03
16F0:  MOVLB  4
16F2:  BTFSC  xA4.7
16F4:  BSF    FF2.7
16F6:  MOVWF  xA4
16F8:  MOVFF  03,4A5
16FC:  CLRF   xA6
16FE:  CLRF   xA7
1700:  MOVFF  4A7,4C0
1704:  MOVFF  4A6,4BF
1708:  MOVFF  03,4BE
170C:  MOVWF  xBD
170E:  MOVFF  496,4C4
1712:  MOVFF  495,4C3
1716:  MOVFF  494,4C2
171A:  MOVFF  493,4C1
171E:  MOVLB  0
1720:  CALL   0966
1724:  MOVFF  FEA,4A5
1728:  MOVFF  FE9,4A4
172C:  BCF    FD8.1
172E:  MOVFF  4A3,4C0
1732:  MOVFF  4A2,4BF
1736:  MOVFF  4A1,4BE
173A:  MOVFF  4A0,4BD
173E:  MOVFF  03,4C4
1742:  MOVFF  02,4C3
1746:  MOVFF  01,4C2
174A:  MOVFF  00,4C1
174E:  CALL   04A2
1752:  MOVFF  4A5,FEA
1756:  MOVFF  4A4,FE9
175A:  MOVFF  03,4A3
175E:  MOVFF  02,4A2
1762:  MOVFF  01,4A1
1766:  MOVFF  00,4A0
176A:  MOVLB  4
176C:  MOVF   x9B,W
176E:  MULLW  0C
1770:  MOVF   FF3,W
1772:  CLRF   xA7
1774:  MOVWF  xA6
1776:  MOVLW  08
1778:  ADDWF  xA6,W
177A:  MOVWF  01
177C:  MOVLW  00
177E:  ADDWFC xA7,W
1780:  MOVWF  03
1782:  MOVF   01,W
1784:  MOVFF  FF2,4A6
1788:  BCF    FF2.7
178A:  MOVLB  0
178C:  CALL   0096
1790:  MOVWF  00
1792:  TBLRD*+
1794:  MOVFF  FF5,01
1798:  TBLRD*+
179A:  MOVFF  FF5,02
179E:  TBLRD*+
17A0:  MOVFF  FF5,03
17A4:  MOVLB  4
17A6:  BTFSC  xA6.7
17A8:  BSF    FF2.7
17AA:  MOVWF  xA6
17AC:  MOVFF  03,4A7
17B0:  CLRF   xA8
17B2:  CLRF   xA9
17B4:  MOVFF  4A9,4C0
17B8:  MOVFF  4A8,4BF
17BC:  MOVFF  03,4BE
17C0:  MOVWF  xBD
17C2:  MOVFF  49A,4C4
17C6:  MOVFF  499,4C3
17CA:  MOVFF  498,4C2
17CE:  MOVFF  497,4C1
17D2:  MOVLB  0
17D4:  CALL   0966
17D8:  MOVFF  FEA,4A7
17DC:  MOVFF  FE9,4A6
17E0:  BCF    FD8.1
17E2:  MOVFF  4A3,4C0
17E6:  MOVFF  4A2,4BF
17EA:  MOVFF  4A1,4BE
17EE:  MOVFF  4A0,4BD
17F2:  MOVFF  03,4C4
17F6:  MOVFF  02,4C3
17FA:  MOVFF  01,4C2
17FE:  MOVFF  00,4C1
1802:  CALL   04A2
1806:  MOVFF  4A7,FEA
180A:  MOVFF  4A6,FE9
180E:  MOVFF  00,FEF
1812:  MOVFF  01,FEC
1816:  MOVFF  02,FEC
181A:  MOVFF  03,FEC
181E:  MOVLB  4
1820:  INCF   x9B,F
1822:  BRA    1628
....................         } 
....................          
....................         // Calculate the roll angle 
....................         Angle->roll = atan( accelData[1] / sqrt(  (float)(accelData[0] * accelData[0] + accelData[2] * accelData[2]) )) * 180.0 / PI; 
1824:  MOVLW  04
1826:  ADDWF  x89,W
1828:  MOVWF  01
182A:  MOVLW  00
182C:  ADDWFC x8A,W
182E:  MOVWF  03
1830:  MOVFF  01,49C
1834:  MOVWF  x9D
1836:  MOVLW  04
1838:  ADDWF  x8B,W
183A:  MOVWF  FE9
183C:  MOVLW  00
183E:  ADDWFC x8C,W
1840:  MOVWF  FEA
1842:  MOVFF  FEF,49E
1846:  MOVFF  FEC,49F
184A:  MOVFF  FEC,4A0
184E:  MOVFF  FEC,4A1
1852:  MOVFF  48B,FE9
1856:  MOVFF  48C,FEA
185A:  MOVFF  FEF,4A2
185E:  MOVFF  FEC,4A3
1862:  MOVFF  FEC,4A4
1866:  MOVFF  FEC,4A5
186A:  MOVFF  48B,FE9
186E:  MOVFF  48C,FEA
1872:  MOVFF  FEF,00
1876:  MOVFF  FEC,01
187A:  MOVFF  FEC,02
187E:  MOVFF  FEC,03
1882:  MOVFF  4A5,4C0
1886:  MOVFF  4A4,4BF
188A:  MOVFF  4A3,4BE
188E:  MOVFF  4A2,4BD
1892:  MOVFF  03,4C4
1896:  MOVFF  02,4C3
189A:  MOVFF  01,4C2
189E:  MOVFF  00,4C1
18A2:  MOVLB  0
18A4:  CALL   0966
18A8:  MOVFF  03,4A5
18AC:  MOVFF  02,4A4
18B0:  MOVFF  01,4A3
18B4:  MOVFF  00,4A2
18B8:  MOVLW  08
18BA:  MOVLB  4
18BC:  ADDWF  x8B,W
18BE:  MOVWF  FE9
18C0:  MOVLW  00
18C2:  ADDWFC x8C,W
18C4:  MOVWF  FEA
18C6:  MOVFF  FEF,4A6
18CA:  MOVFF  FEC,4A7
18CE:  MOVFF  FEC,4A8
18D2:  MOVFF  FEC,4A9
18D6:  MOVLW  08
18D8:  ADDWF  x8B,W
18DA:  MOVWF  FE9
18DC:  MOVLW  00
18DE:  ADDWFC x8C,W
18E0:  MOVWF  FEA
18E2:  MOVFF  FEF,00
18E6:  MOVFF  FEC,01
18EA:  MOVFF  FEC,02
18EE:  MOVFF  FEC,03
18F2:  MOVFF  4A9,4C0
18F6:  MOVFF  4A8,4BF
18FA:  MOVFF  4A7,4BE
18FE:  MOVFF  4A6,4BD
1902:  MOVFF  03,4C4
1906:  MOVFF  02,4C3
190A:  MOVFF  01,4C2
190E:  MOVFF  00,4C1
1912:  MOVLB  0
1914:  CALL   0966
1918:  MOVFF  FEA,4A7
191C:  MOVFF  FE9,4A6
1920:  BCF    FD8.1
1922:  MOVFF  4A5,4C0
1926:  MOVFF  4A4,4BF
192A:  MOVFF  4A3,4BE
192E:  MOVFF  4A2,4BD
1932:  MOVFF  03,4C4
1936:  MOVFF  02,4C3
193A:  MOVFF  01,4C2
193E:  MOVFF  00,4C1
1942:  CALL   04A2
1946:  MOVFF  4A7,FEA
194A:  MOVFF  4A6,FE9
194E:  MOVFF  03,4A5
1952:  MOVFF  02,4A4
1956:  MOVFF  01,4A3
195A:  MOVFF  00,4A2
195E:  MOVFF  03,4AB
1962:  MOVFF  02,4AA
1966:  MOVFF  01,4A9
196A:  MOVFF  00,4A8
196E:  CALL   0E96
1972:  MOVFF  4A1,4C0
1976:  MOVFF  4A0,4BF
197A:  MOVFF  49F,4BE
197E:  MOVFF  49E,4BD
1982:  MOVFF  03,4C4
1986:  MOVFF  02,4C3
198A:  MOVFF  01,4C2
198E:  MOVFF  00,4C1
1992:  CALL   0202
1996:  MOVFF  03,4A1
199A:  MOVFF  02,4A0
199E:  MOVFF  01,49F
19A2:  MOVFF  00,49E
19A6:  MOVFF  03,4AB
19AA:  MOVFF  02,4AA
19AE:  MOVFF  01,4A9
19B2:  MOVFF  00,4A8
19B6:  CALL   0FB8
19BA:  MOVFF  03,4A1
19BE:  MOVFF  02,4A0
19C2:  MOVFF  01,49F
19C6:  MOVFF  00,49E
19CA:  MOVFF  03,4C0
19CE:  MOVFF  02,4BF
19D2:  MOVFF  01,4BE
19D6:  MOVFF  00,4BD
19DA:  MOVLB  4
19DC:  CLRF   xC4
19DE:  CLRF   xC3
19E0:  MOVLW  34
19E2:  MOVWF  xC2
19E4:  MOVLW  86
19E6:  MOVWF  xC1
19E8:  MOVLB  0
19EA:  CALL   0966
19EE:  MOVFF  03,4A1
19F2:  MOVFF  02,4A0
19F6:  MOVFF  01,49F
19FA:  MOVFF  00,49E
19FE:  MOVFF  03,4C0
1A02:  MOVFF  02,4BF
1A06:  MOVFF  01,4BE
1A0A:  MOVFF  00,4BD
1A0E:  MOVLW  DB
1A10:  MOVLB  4
1A12:  MOVWF  xC4
1A14:  MOVLW  0F
1A16:  MOVWF  xC3
1A18:  MOVLW  49
1A1A:  MOVWF  xC2
1A1C:  MOVLW  80
1A1E:  MOVWF  xC1
1A20:  MOVLB  0
1A22:  CALL   0202
1A26:  MOVFF  49D,FEA
1A2A:  MOVFF  49C,FE9
1A2E:  MOVFF  00,FEF
1A32:  MOVFF  01,FEC
1A36:  MOVFF  02,FEC
1A3A:  MOVFF  03,FEC
....................         // Calculate the pitch angle 
....................         Angle->pitch = atan( accelData[0] / sqrt( (float) (accelData[1] * accelData[1] + accelData[2] * accelData[2]) )) * (-180.0) / PI; 
1A3E:  MOVLB  4
1A40:  MOVFF  489,49C
1A44:  MOVFF  48A,49D
1A48:  MOVFF  48B,FE9
1A4C:  MOVFF  48C,FEA
1A50:  MOVFF  FEF,49E
1A54:  MOVFF  FEC,49F
1A58:  MOVFF  FEC,4A0
1A5C:  MOVFF  FEC,4A1
1A60:  MOVLW  04
1A62:  ADDWF  x8B,W
1A64:  MOVWF  FE9
1A66:  MOVLW  00
1A68:  ADDWFC x8C,W
1A6A:  MOVWF  FEA
1A6C:  MOVFF  FEF,4A2
1A70:  MOVFF  FEC,4A3
1A74:  MOVFF  FEC,4A4
1A78:  MOVFF  FEC,4A5
1A7C:  MOVLW  04
1A7E:  ADDWF  x8B,W
1A80:  MOVWF  FE9
1A82:  MOVLW  00
1A84:  ADDWFC x8C,W
1A86:  MOVWF  FEA
1A88:  MOVFF  FEF,00
1A8C:  MOVFF  FEC,01
1A90:  MOVFF  FEC,02
1A94:  MOVFF  FEC,03
1A98:  MOVFF  4A5,4C0
1A9C:  MOVFF  4A4,4BF
1AA0:  MOVFF  4A3,4BE
1AA4:  MOVFF  4A2,4BD
1AA8:  MOVFF  03,4C4
1AAC:  MOVFF  02,4C3
1AB0:  MOVFF  01,4C2
1AB4:  MOVFF  00,4C1
1AB8:  MOVLB  0
1ABA:  CALL   0966
1ABE:  MOVFF  03,4A5
1AC2:  MOVFF  02,4A4
1AC6:  MOVFF  01,4A3
1ACA:  MOVFF  00,4A2
1ACE:  MOVLW  08
1AD0:  MOVLB  4
1AD2:  ADDWF  x8B,W
1AD4:  MOVWF  FE9
1AD6:  MOVLW  00
1AD8:  ADDWFC x8C,W
1ADA:  MOVWF  FEA
1ADC:  MOVFF  FEF,4A6
1AE0:  MOVFF  FEC,4A7
1AE4:  MOVFF  FEC,4A8
1AE8:  MOVFF  FEC,4A9
1AEC:  MOVLW  08
1AEE:  ADDWF  x8B,W
1AF0:  MOVWF  FE9
1AF2:  MOVLW  00
1AF4:  ADDWFC x8C,W
1AF6:  MOVWF  FEA
1AF8:  MOVFF  FEF,00
1AFC:  MOVFF  FEC,01
1B00:  MOVFF  FEC,02
1B04:  MOVFF  FEC,03
1B08:  MOVFF  4A9,4C0
1B0C:  MOVFF  4A8,4BF
1B10:  MOVFF  4A7,4BE
1B14:  MOVFF  4A6,4BD
1B18:  MOVFF  03,4C4
1B1C:  MOVFF  02,4C3
1B20:  MOVFF  01,4C2
1B24:  MOVFF  00,4C1
1B28:  MOVLB  0
1B2A:  CALL   0966
1B2E:  MOVFF  FEA,4A7
1B32:  MOVFF  FE9,4A6
1B36:  BCF    FD8.1
1B38:  MOVFF  4A5,4C0
1B3C:  MOVFF  4A4,4BF
1B40:  MOVFF  4A3,4BE
1B44:  MOVFF  4A2,4BD
1B48:  MOVFF  03,4C4
1B4C:  MOVFF  02,4C3
1B50:  MOVFF  01,4C2
1B54:  MOVFF  00,4C1
1B58:  CALL   04A2
1B5C:  MOVFF  4A7,FEA
1B60:  MOVFF  4A6,FE9
1B64:  MOVFF  03,4A5
1B68:  MOVFF  02,4A4
1B6C:  MOVFF  01,4A3
1B70:  MOVFF  00,4A2
1B74:  MOVFF  03,4AB
1B78:  MOVFF  02,4AA
1B7C:  MOVFF  01,4A9
1B80:  MOVFF  00,4A8
1B84:  CALL   0E96
1B88:  MOVFF  4A1,4C0
1B8C:  MOVFF  4A0,4BF
1B90:  MOVFF  49F,4BE
1B94:  MOVFF  49E,4BD
1B98:  MOVFF  03,4C4
1B9C:  MOVFF  02,4C3
1BA0:  MOVFF  01,4C2
1BA4:  MOVFF  00,4C1
1BA8:  CALL   0202
1BAC:  MOVFF  03,4A1
1BB0:  MOVFF  02,4A0
1BB4:  MOVFF  01,49F
1BB8:  MOVFF  00,49E
1BBC:  MOVFF  03,4AB
1BC0:  MOVFF  02,4AA
1BC4:  MOVFF  01,4A9
1BC8:  MOVFF  00,4A8
1BCC:  CALL   0FB8
1BD0:  MOVFF  03,4A1
1BD4:  MOVFF  02,4A0
1BD8:  MOVFF  01,49F
1BDC:  MOVFF  00,49E
1BE0:  MOVFF  03,4C0
1BE4:  MOVFF  02,4BF
1BE8:  MOVFF  01,4BE
1BEC:  MOVFF  00,4BD
1BF0:  MOVLB  4
1BF2:  CLRF   xC4
1BF4:  CLRF   xC3
1BF6:  MOVLW  B4
1BF8:  MOVWF  xC2
1BFA:  MOVLW  86
1BFC:  MOVWF  xC1
1BFE:  MOVLB  0
1C00:  CALL   0966
1C04:  MOVFF  03,4A1
1C08:  MOVFF  02,4A0
1C0C:  MOVFF  01,49F
1C10:  MOVFF  00,49E
1C14:  MOVFF  03,4C0
1C18:  MOVFF  02,4BF
1C1C:  MOVFF  01,4BE
1C20:  MOVFF  00,4BD
1C24:  MOVLW  DB
1C26:  MOVLB  4
1C28:  MOVWF  xC4
1C2A:  MOVLW  0F
1C2C:  MOVWF  xC3
1C2E:  MOVLW  49
1C30:  MOVWF  xC2
1C32:  MOVLW  80
1C34:  MOVWF  xC1
1C36:  MOVLB  0
1C38:  CALL   0202
1C3C:  MOVFF  49D,FEA
1C40:  MOVFF  49C,FE9
1C44:  MOVFF  00,FEF
1C48:  MOVFF  01,FEC
1C4C:  MOVFF  02,FEC
1C50:  MOVFF  03,FEC
....................         Angle->yaw = 1* atan((float)magData[0] / (float)magData[1]) * 180 / PI; 
1C54:  MOVLW  08
1C56:  MOVLB  4
1C58:  ADDWF  x89,W
1C5A:  MOVWF  01
1C5C:  MOVLW  00
1C5E:  ADDWFC x8A,W
1C60:  MOVFF  01,49C
1C64:  MOVWF  x9D
1C66:  MOVFF  48D,FE9
1C6A:  MOVFF  48E,FEA
1C6E:  MOVFF  FEF,00
1C72:  MOVFF  FEC,01
1C76:  MOVFF  FEC,02
1C7A:  MOVFF  FEC,03
1C7E:  MOVFF  03,4A1
1C82:  MOVFF  02,4A0
1C86:  MOVFF  01,49F
1C8A:  MOVFF  00,49E
1C8E:  MOVLW  04
1C90:  ADDWF  x8D,W
1C92:  MOVWF  FE9
1C94:  MOVLW  00
1C96:  ADDWFC x8E,W
1C98:  MOVWF  FEA
1C9A:  MOVFF  FEF,00
1C9E:  MOVFF  FEC,01
1CA2:  MOVFF  FEC,02
1CA6:  MOVFF  FEC,03
1CAA:  MOVFF  4A1,4C0
1CAE:  MOVFF  4A0,4BF
1CB2:  MOVFF  49F,4BE
1CB6:  MOVFF  49E,4BD
1CBA:  MOVFF  03,4C4
1CBE:  MOVFF  02,4C3
1CC2:  MOVFF  01,4C2
1CC6:  MOVFF  00,4C1
1CCA:  MOVLB  0
1CCC:  CALL   0202
1CD0:  MOVFF  03,4A1
1CD4:  MOVFF  02,4A0
1CD8:  MOVFF  01,49F
1CDC:  MOVFF  00,49E
1CE0:  MOVFF  03,4AB
1CE4:  MOVFF  02,4AA
1CE8:  MOVFF  01,4A9
1CEC:  MOVFF  00,4A8
1CF0:  CALL   0FB8
1CF4:  MOVLB  4
1CF6:  CLRF   xC0
1CF8:  CLRF   xBF
1CFA:  CLRF   xBE
1CFC:  MOVLW  7F
1CFE:  MOVWF  xBD
1D00:  MOVFF  03,4C4
1D04:  MOVFF  02,4C3
1D08:  MOVFF  01,4C2
1D0C:  MOVFF  00,4C1
1D10:  MOVLB  0
1D12:  CALL   0966
1D16:  MOVFF  03,4A1
1D1A:  MOVFF  02,4A0
1D1E:  MOVFF  01,49F
1D22:  MOVFF  00,49E
1D26:  MOVFF  03,4C0
1D2A:  MOVFF  02,4BF
1D2E:  MOVFF  01,4BE
1D32:  MOVFF  00,4BD
1D36:  MOVLB  4
1D38:  CLRF   xC4
1D3A:  CLRF   xC3
1D3C:  MOVLW  34
1D3E:  MOVWF  xC2
1D40:  MOVLW  86
1D42:  MOVWF  xC1
1D44:  MOVLB  0
1D46:  CALL   0966
1D4A:  MOVFF  03,4A1
1D4E:  MOVFF  02,4A0
1D52:  MOVFF  01,49F
1D56:  MOVFF  00,49E
1D5A:  MOVFF  03,4C0
1D5E:  MOVFF  02,4BF
1D62:  MOVFF  01,4BE
1D66:  MOVFF  00,4BD
1D6A:  MOVLW  DB
1D6C:  MOVLB  4
1D6E:  MOVWF  xC4
1D70:  MOVLW  0F
1D72:  MOVWF  xC3
1D74:  MOVLW  49
1D76:  MOVWF  xC2
1D78:  MOVLW  80
1D7A:  MOVWF  xC1
1D7C:  MOVLB  0
1D7E:  CALL   0202
1D82:  MOVFF  49D,FEA
1D86:  MOVFF  49C,FE9
1D8A:  MOVFF  00,FEF
1D8E:  MOVFF  01,FEC
1D92:  MOVFF  02,FEC
1D96:  MOVFF  03,FEC
1D9A:  GOTO   207A (RETURN)
....................          
....................          
....................         //Angle->roll = atan(0.1);Angle->pitch= 1; 
....................  
.................... } 
....................  
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]) 
.................... { 
....................   KalmanState=KalmanState+0.0192*KalmanInput; 
1D9E:  MOVLW  52
1DA0:  MOVLB  4
1DA2:  MOVWF  xC0
1DA4:  MOVLW  49
1DA6:  MOVWF  xBF
1DA8:  MOVLW  1D
1DAA:  MOVWF  xBE
1DAC:  MOVLW  79
1DAE:  MOVWF  xBD
1DB0:  MOVFF  49C,4C4
1DB4:  MOVFF  49B,4C3
1DB8:  MOVFF  49A,4C2
1DBC:  MOVFF  499,4C1
1DC0:  MOVLB  0
1DC2:  CALL   0966
1DC6:  BCF    FD8.1
1DC8:  MOVFF  494,4C0
1DCC:  MOVFF  493,4BF
1DD0:  MOVFF  492,4BE
1DD4:  MOVFF  491,4BD
1DD8:  MOVFF  03,4C4
1DDC:  MOVFF  02,4C3
1DE0:  MOVFF  01,4C2
1DE4:  MOVFF  00,4C1
1DE8:  CALL   04A2
1DEC:  MOVFF  03,494
1DF0:  MOVFF  02,493
1DF4:  MOVFF  01,492
1DF8:  MOVFF  00,491
....................   KalmanUncertainty=KalmanUncertainty + 0.0192 * 0.0192 * 4 * 4; 
1DFC:  BCF    FD8.1
1DFE:  MOVFF  498,4C0
1E02:  MOVFF  497,4BF
1E06:  MOVFF  496,4BE
1E0A:  MOVFF  495,4BD
1E0E:  MOVLW  07
1E10:  MOVLB  4
1E12:  MOVWF  xC4
1E14:  MOVLW  46
1E16:  MOVWF  xC3
1E18:  MOVLW  41
1E1A:  MOVWF  xC2
1E1C:  MOVLW  77
1E1E:  MOVWF  xC1
1E20:  MOVLB  0
1E22:  CALL   04A2
1E26:  MOVFF  03,498
1E2A:  MOVFF  02,497
1E2E:  MOVFF  01,496
1E32:  MOVFF  00,495
....................   float KalmanGain=KalmanUncertainty * 1/(1*KalmanUncertainty + 3 * 3); 
1E36:  MOVFF  498,4C0
1E3A:  MOVFF  497,4BF
1E3E:  MOVFF  496,4BE
1E42:  MOVFF  495,4BD
1E46:  MOVLB  4
1E48:  CLRF   xC4
1E4A:  CLRF   xC3
1E4C:  CLRF   xC2
1E4E:  MOVLW  7F
1E50:  MOVWF  xC1
1E52:  MOVLB  0
1E54:  CALL   0966
1E58:  MOVFF  03,4AA
1E5C:  MOVFF  02,4A9
1E60:  MOVFF  01,4A8
1E64:  MOVFF  00,4A7
1E68:  MOVLB  4
1E6A:  CLRF   xC0
1E6C:  CLRF   xBF
1E6E:  CLRF   xBE
1E70:  MOVLW  7F
1E72:  MOVWF  xBD
1E74:  MOVFF  498,4C4
1E78:  MOVFF  497,4C3
1E7C:  MOVFF  496,4C2
1E80:  MOVFF  495,4C1
1E84:  MOVLB  0
1E86:  CALL   0966
1E8A:  MOVFF  03,4AE
1E8E:  MOVFF  02,4AD
1E92:  MOVFF  01,4AC
1E96:  MOVFF  00,4AB
1E9A:  BCF    FD8.1
1E9C:  MOVFF  03,4C0
1EA0:  MOVFF  02,4BF
1EA4:  MOVFF  01,4BE
1EA8:  MOVFF  00,4BD
1EAC:  MOVLB  4
1EAE:  CLRF   xC4
1EB0:  CLRF   xC3
1EB2:  MOVLW  10
1EB4:  MOVWF  xC2
1EB6:  MOVLW  82
1EB8:  MOVWF  xC1
1EBA:  MOVLB  0
1EBC:  CALL   04A2
1EC0:  MOVFF  4AA,4C0
1EC4:  MOVFF  4A9,4BF
1EC8:  MOVFF  4A8,4BE
1ECC:  MOVFF  4A7,4BD
1ED0:  MOVFF  03,4C4
1ED4:  MOVFF  02,4C3
1ED8:  MOVFF  01,4C2
1EDC:  MOVFF  00,4C1
1EE0:  CALL   0202
1EE4:  MOVFF  03,4A6
1EE8:  MOVFF  02,4A5
1EEC:  MOVFF  01,4A4
1EF0:  MOVFF  00,4A3
....................   KalmanState=KalmanState+KalmanGain * (KalmanMeasurement-KalmanState); 
1EF4:  BSF    FD8.1
1EF6:  MOVFF  4A0,4C0
1EFA:  MOVFF  49F,4BF
1EFE:  MOVFF  49E,4BE
1F02:  MOVFF  49D,4BD
1F06:  MOVFF  494,4C4
1F0A:  MOVFF  493,4C3
1F0E:  MOVFF  492,4C2
1F12:  MOVFF  491,4C1
1F16:  CALL   04A2
1F1A:  MOVFF  4A6,4C0
1F1E:  MOVFF  4A5,4BF
1F22:  MOVFF  4A4,4BE
1F26:  MOVFF  4A3,4BD
1F2A:  MOVFF  03,4C4
1F2E:  MOVFF  02,4C3
1F32:  MOVFF  01,4C2
1F36:  MOVFF  00,4C1
1F3A:  CALL   0966
1F3E:  BCF    FD8.1
1F40:  MOVFF  494,4C0
1F44:  MOVFF  493,4BF
1F48:  MOVFF  492,4BE
1F4C:  MOVFF  491,4BD
1F50:  MOVFF  03,4C4
1F54:  MOVFF  02,4C3
1F58:  MOVFF  01,4C2
1F5C:  MOVFF  00,4C1
1F60:  CALL   04A2
1F64:  MOVFF  03,494
1F68:  MOVFF  02,493
1F6C:  MOVFF  01,492
1F70:  MOVFF  00,491
....................   KalmanUncertainty=(1-KalmanGain) * KalmanUncertainty; 
1F74:  BSF    FD8.1
1F76:  MOVLB  4
1F78:  CLRF   xC0
1F7A:  CLRF   xBF
1F7C:  CLRF   xBE
1F7E:  MOVLW  7F
1F80:  MOVWF  xBD
1F82:  MOVFF  4A6,4C4
1F86:  MOVFF  4A5,4C3
1F8A:  MOVFF  4A4,4C2
1F8E:  MOVFF  4A3,4C1
1F92:  MOVLB  0
1F94:  CALL   04A2
1F98:  MOVFF  03,4AA
1F9C:  MOVFF  02,4A9
1FA0:  MOVFF  01,4A8
1FA4:  MOVFF  00,4A7
1FA8:  MOVFF  03,4C0
1FAC:  MOVFF  02,4BF
1FB0:  MOVFF  01,4BE
1FB4:  MOVFF  00,4BD
1FB8:  MOVFF  498,4C4
1FBC:  MOVFF  497,4C3
1FC0:  MOVFF  496,4C2
1FC4:  MOVFF  495,4C1
1FC8:  CALL   0966
1FCC:  MOVFF  03,498
1FD0:  MOVFF  02,497
1FD4:  MOVFF  01,496
1FD8:  MOVFF  00,495
....................     Kalman1DOutput[0]=KalmanState; 
1FDC:  MOVLB  4
1FDE:  MOVFF  4A1,FE9
1FE2:  MOVFF  4A2,FEA
1FE6:  MOVFF  491,FEF
1FEA:  MOVFF  492,FEC
1FEE:  MOVFF  493,FEC
1FF2:  MOVFF  494,FEC
....................     Kalman1DOutput[1]=KalmanUncertainty; 
1FF6:  MOVLW  04
1FF8:  ADDWF  xA1,W
1FFA:  MOVWF  FE9
1FFC:  MOVLW  00
1FFE:  ADDWFC xA2,W
2000:  MOVWF  FEA
2002:  MOVFF  495,FEF
2006:  MOVFF  496,FEC
200A:  MOVFF  497,FEC
200E:  MOVFF  498,FEC
2012:  MOVLB  0
2014:  RETURN 0
.................... } 
....................  
.................... // Calculate the roll angle 
....................  
....................  
.................... // Calculate the pitch angle 
....................  
....................  

Configuration Fuses:
   Word  1: CC27   PLL12 CPUDIV1 USBDIV HS FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8500   CCP2C1 NOPBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
