CCS PCH C Compiler, Version 5.015, 5967               26-Jan-24 18:52

               Filename:   D:\PIC\projects\MagnetometerCalibration .X\dist\default\production\MagnetometerCalibration_.X.production.lst

               ROM used:   11572 bytes (35%)
                           Largest free fragment is 21192
               RAM used:   90 (4%) at main() level
                           191 (9%) worst case
               Stack used: 13 locations (6 in main + 7 for interrupts)
               Stack size: 31

*
0000:  GOTO   2B88
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.1
004A:  GOTO   0054
004E:  BTFSC  F9E.1
0050:  GOTO   1FBC
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #import(file="build/default/production/main.o") 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
....................  
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
01DA:  MOVF   xAF,W
01DC:  BTFSC  FD8.2
01DE:  BRA    032A
01E0:  MOVWF  xBB
01E2:  MOVF   xB3,W
01E4:  BTFSC  FD8.2
01E6:  BRA    032A
01E8:  SUBWF  xBB,F
01EA:  BNC   01F6
01EC:  MOVLW  7F
01EE:  ADDWF  xBB,F
01F0:  BTFSC  FD8.0
01F2:  BRA    032A
01F4:  BRA    0202
01F6:  MOVLW  81
01F8:  SUBWF  xBB,F
01FA:  BTFSS  FD8.0
01FC:  BRA    032A
01FE:  BTFSC  FD8.2
0200:  BRA    032A
0202:  MOVFF  BB,00
0206:  CLRF   01
0208:  CLRF   02
020A:  CLRF   03
020C:  CLRF   xBA
020E:  MOVFF  B0,B9
0212:  BSF    xB9.7
0214:  MOVFF  B1,B8
0218:  MOVFF  B2,B7
021C:  MOVLW  19
021E:  MOVWF  xBB
0220:  MOVF   xB6,W
0222:  SUBWF  xB7,F
0224:  BC    0240
0226:  MOVLW  01
0228:  SUBWF  xB8,F
022A:  BC    0240
022C:  SUBWF  xB9,F
022E:  BC    0240
0230:  SUBWF  xBA,F
0232:  BC    0240
0234:  INCF   xBA,F
0236:  INCF   xB9,F
0238:  INCF   xB8,F
023A:  MOVF   xB6,W
023C:  ADDWF  xB7,F
023E:  BRA    0290
0240:  MOVF   xB5,W
0242:  SUBWF  xB8,F
0244:  BC    026A
0246:  MOVLW  01
0248:  SUBWF  xB9,F
024A:  BC    026A
024C:  SUBWF  xBA,F
024E:  BC    026A
0250:  INCF   xBA,F
0252:  INCF   xB9,F
0254:  MOVF   xB5,W
0256:  ADDWF  xB8,F
0258:  MOVF   xB6,W
025A:  ADDWF  xB7,F
025C:  BNC   0290
025E:  INCF   xB8,F
0260:  BNZ   0290
0262:  INCF   xB9,F
0264:  BNZ   0290
0266:  INCF   xBA,F
0268:  BRA    0290
026A:  MOVF   xB4,W
026C:  IORLW  80
026E:  SUBWF  xB9,F
0270:  BC    028E
0272:  MOVLW  01
0274:  SUBWF  xBA,F
0276:  BC    028E
0278:  INCF   xBA,F
027A:  MOVF   xB4,W
027C:  IORLW  80
027E:  ADDWF  xB9,F
0280:  MOVF   xB5,W
0282:  ADDWF  xB8,F
0284:  BNC   0258
0286:  INCF   xB9,F
0288:  BNZ   0258
028A:  INCF   xBA,F
028C:  BRA    0258
028E:  BSF    03.0
0290:  DECFSZ xBB,F
0292:  BRA    0296
0294:  BRA    02AC
0296:  BCF    FD8.0
0298:  RLCF   xB7,F
029A:  RLCF   xB8,F
029C:  RLCF   xB9,F
029E:  RLCF   xBA,F
02A0:  BCF    FD8.0
02A2:  RLCF   03,F
02A4:  RLCF   02,F
02A6:  RLCF   01,F
02A8:  RLCF   xBC,F
02AA:  BRA    0220
02AC:  BTFSS  xBC.0
02AE:  BRA    02BC
02B0:  BCF    FD8.0
02B2:  RRCF   01,F
02B4:  RRCF   02,F
02B6:  RRCF   03,F
02B8:  RRCF   xBC,F
02BA:  BRA    02C0
02BC:  DECF   00,F
02BE:  BZ    032A
02C0:  BTFSC  xBC.7
02C2:  BRA    0300
02C4:  BCF    FD8.0
02C6:  RLCF   xB7,F
02C8:  RLCF   xB8,F
02CA:  RLCF   xB9,F
02CC:  RLCF   xBA,F
02CE:  MOVF   xB6,W
02D0:  SUBWF  xB7,F
02D2:  BC    02E2
02D4:  MOVLW  01
02D6:  SUBWF  xB8,F
02D8:  BC    02E2
02DA:  SUBWF  xB9,F
02DC:  BC    02E2
02DE:  SUBWF  xBA,F
02E0:  BNC   0316
02E2:  MOVF   xB5,W
02E4:  SUBWF  xB8,F
02E6:  BC    02F2
02E8:  MOVLW  01
02EA:  SUBWF  xB9,F
02EC:  BC    02F2
02EE:  SUBWF  xBA,F
02F0:  BNC   0316
02F2:  MOVF   xB4,W
02F4:  IORLW  80
02F6:  SUBWF  xB9,F
02F8:  BC    0300
02FA:  MOVLW  01
02FC:  SUBWF  xBA,F
02FE:  BNC   0316
0300:  INCF   03,F
0302:  BNZ   0316
0304:  INCF   02,F
0306:  BNZ   0316
0308:  INCF   01,F
030A:  BNZ   0316
030C:  INCF   00,F
030E:  BZ    032A
0310:  RRCF   01,F
0312:  RRCF   02,F
0314:  RRCF   03,F
0316:  MOVFF  B0,BB
031A:  MOVF   xB4,W
031C:  XORWF  xBB,F
031E:  BTFSS  xBB.7
0320:  BRA    0326
0322:  BSF    01.7
0324:  BRA    0332
0326:  BCF    01.7
0328:  BRA    0332
032A:  CLRF   00
032C:  CLRF   01
032E:  CLRF   02
0330:  CLRF   03
0332:  RETURN 0
*
044A:  MOVLW  80
044C:  BTFSC  FD8.1
044E:  XORWF  xB4,F
0450:  CLRF   xB9
0452:  CLRF   xBA
0454:  MOVFF  B0,B8
0458:  MOVF   xB4,W
045A:  XORWF  xB8,F
045C:  MOVF   xAF,W
045E:  BTFSC  FD8.2
0460:  BRA    061A
0462:  MOVWF  xB7
0464:  MOVWF  00
0466:  MOVF   xB3,W
0468:  BTFSC  FD8.2
046A:  BRA    062C
046C:  SUBWF  xB7,F
046E:  BTFSC  FD8.2
0470:  BRA    0574
0472:  BNC   04EE
0474:  MOVFF  B4,BD
0478:  BSF    xBD.7
047A:  MOVFF  B5,BC
047E:  MOVFF  B6,BB
0482:  CLRF   xBA
0484:  BCF    FD8.0
0486:  RRCF   xBD,F
0488:  RRCF   xBC,F
048A:  RRCF   xBB,F
048C:  RRCF   xBA,F
048E:  DECFSZ xB7,F
0490:  BRA    0482
0492:  BTFSS  xB8.7
0494:  BRA    049C
0496:  BSF    xB9.0
0498:  BRA    0654
049A:  BCF    xB9.0
049C:  BCF    xB7.0
049E:  BSF    xB9.4
04A0:  CLRF   FEA
04A2:  MOVLW  B2
04A4:  MOVWF  FE9
04A6:  BRA    067A
04A8:  BCF    xB9.4
04AA:  BTFSC  xB8.7
04AC:  BRA    04C2
04AE:  BTFSS  xB7.0
04B0:  BRA    04D8
04B2:  RRCF   xBD,F
04B4:  RRCF   xBC,F
04B6:  RRCF   xBB,F
04B8:  RRCF   xBA,F
04BA:  INCF   00,F
04BC:  BTFSC  FD8.2
04BE:  BRA    064A
04C0:  BRA    04D8
04C2:  BTFSC  xBD.7
04C4:  BRA    04DE
04C6:  BCF    FD8.0
04C8:  RLCF   xBA,F
04CA:  RLCF   xBB,F
04CC:  RLCF   xBC,F
04CE:  RLCF   xBD,F
04D0:  DECF   00,F
04D2:  BTFSC  FD8.2
04D4:  BRA    064A
04D6:  BRA    04C2
04D8:  BSF    xB9.6
04DA:  BRA    05B2
04DC:  BCF    xB9.6
04DE:  MOVFF  B0,B8
04E2:  BTFSS  xB0.7
04E4:  BRA    04EA
04E6:  BSF    xBD.7
04E8:  BRA    063C
04EA:  BCF    xBD.7
04EC:  BRA    063C
04EE:  MOVFF  B3,B7
04F2:  MOVFF  B3,00
04F6:  MOVF   xAF,W
04F8:  SUBWF  xB7,F
04FA:  MOVFF  B0,BD
04FE:  BSF    xBD.7
0500:  MOVFF  B1,BC
0504:  MOVFF  B2,BB
0508:  CLRF   xBA
050A:  BCF    FD8.0
050C:  RRCF   xBD,F
050E:  RRCF   xBC,F
0510:  RRCF   xBB,F
0512:  RRCF   xBA,F
0514:  DECFSZ xB7,F
0516:  BRA    0508
0518:  BTFSS  xB8.7
051A:  BRA    0522
051C:  BSF    xB9.1
051E:  BRA    0654
0520:  BCF    xB9.1
0522:  BCF    xB7.0
0524:  BSF    xB9.5
0526:  CLRF   FEA
0528:  MOVLW  B6
052A:  MOVWF  FE9
052C:  BRA    067A
052E:  BCF    xB9.5
0530:  BTFSC  xB8.7
0532:  BRA    0548
0534:  BTFSS  xB7.0
0536:  BRA    055E
0538:  RRCF   xBD,F
053A:  RRCF   xBC,F
053C:  RRCF   xBB,F
053E:  RRCF   xBA,F
0540:  INCF   00,F
0542:  BTFSC  FD8.2
0544:  BRA    064A
0546:  BRA    055E
0548:  BTFSC  xBD.7
054A:  BRA    0564
054C:  BCF    FD8.0
054E:  RLCF   xBA,F
0550:  RLCF   xBB,F
0552:  RLCF   xBC,F
0554:  RLCF   xBD,F
0556:  DECF   00,F
0558:  BTFSC  FD8.2
055A:  BRA    064A
055C:  BRA    0548
055E:  BSF    xB9.7
0560:  BRA    05B2
0562:  BCF    xB9.7
0564:  MOVFF  B4,B8
0568:  BTFSS  xB4.7
056A:  BRA    0570
056C:  BSF    xBD.7
056E:  BRA    063C
0570:  BCF    xBD.7
0572:  BRA    063C
0574:  MOVFF  B4,BD
0578:  BSF    xBD.7
057A:  MOVFF  B5,BC
057E:  MOVFF  B6,BB
0582:  BTFSS  xB8.7
0584:  BRA    058E
0586:  BCF    xBD.7
0588:  BSF    xB9.2
058A:  BRA    0654
058C:  BCF    xB9.2
058E:  CLRF   xBA
0590:  BCF    xB7.0
0592:  CLRF   FEA
0594:  MOVLW  B2
0596:  MOVWF  FE9
0598:  BRA    067A
059A:  BTFSC  xB8.7
059C:  BRA    05D6
059E:  MOVFF  B0,B8
05A2:  BTFSS  xB7.0
05A4:  BRA    05B2
05A6:  RRCF   xBD,F
05A8:  RRCF   xBC,F
05AA:  RRCF   xBB,F
05AC:  RRCF   xBA,F
05AE:  INCF   00,F
05B0:  BZ    064A
05B2:  BTFSS  xBA.7
05B4:  BRA    05CC
05B6:  INCF   xBB,F
05B8:  BNZ   05CC
05BA:  INCF   xBC,F
05BC:  BNZ   05CC
05BE:  INCF   xBD,F
05C0:  BNZ   05CC
05C2:  RRCF   xBD,F
05C4:  RRCF   xBC,F
05C6:  RRCF   xBB,F
05C8:  INCF   00,F
05CA:  BZ    064A
05CC:  BTFSC  xB9.6
05CE:  BRA    04DC
05D0:  BTFSC  xB9.7
05D2:  BRA    0562
05D4:  BRA    060E
05D6:  MOVLW  80
05D8:  XORWF  xBD,F
05DA:  BTFSS  xBD.7
05DC:  BRA    05E6
05DE:  BRA    0654
05E0:  MOVFF  B4,B8
05E4:  BRA    05FA
05E6:  MOVFF  B0,B8
05EA:  MOVF   xBD,F
05EC:  BNZ   05FA
05EE:  MOVF   xBC,F
05F0:  BNZ   05FA
05F2:  MOVF   xBB,F
05F4:  BNZ   05FA
05F6:  CLRF   00
05F8:  BRA    063C
05FA:  BTFSC  xBD.7
05FC:  BRA    060E
05FE:  BCF    FD8.0
0600:  RLCF   xBA,F
0602:  RLCF   xBB,F
0604:  RLCF   xBC,F
0606:  RLCF   xBD,F
0608:  DECFSZ 00,F
060A:  BRA    05FA
060C:  BRA    064A
060E:  BTFSS  xB8.7
0610:  BRA    0616
0612:  BSF    xBD.7
0614:  BRA    063C
0616:  BCF    xBD.7
0618:  BRA    063C
061A:  MOVFF  B3,00
061E:  MOVFF  B4,BD
0622:  MOVFF  B5,BC
0626:  MOVFF  B6,BB
062A:  BRA    063C
062C:  MOVFF  AF,00
0630:  MOVFF  B0,BD
0634:  MOVFF  B1,BC
0638:  MOVFF  B2,BB
063C:  MOVFF  BD,01
0640:  MOVFF  BC,02
0644:  MOVFF  BB,03
0648:  BRA    06B2
064A:  CLRF   00
064C:  CLRF   01
064E:  CLRF   02
0650:  CLRF   03
0652:  BRA    06B2
0654:  CLRF   xBA
0656:  COMF   xBB,F
0658:  COMF   xBC,F
065A:  COMF   xBD,F
065C:  COMF   xBA,F
065E:  INCF   xBA,F
0660:  BNZ   066C
0662:  INCF   xBB,F
0664:  BNZ   066C
0666:  INCF   xBC,F
0668:  BNZ   066C
066A:  INCF   xBD,F
066C:  BTFSC  xB9.0
066E:  BRA    049A
0670:  BTFSC  xB9.1
0672:  BRA    0520
0674:  BTFSC  xB9.2
0676:  BRA    058C
0678:  BRA    05E0
067A:  MOVF   FEF,W
067C:  ADDWF  xBB,F
067E:  BNC   068A
0680:  INCF   xBC,F
0682:  BNZ   068A
0684:  INCF   xBD,F
0686:  BTFSC  FD8.2
0688:  BSF    xB7.0
068A:  MOVF   FED,F
068C:  MOVF   FEF,W
068E:  ADDWF  xBC,F
0690:  BNC   0698
0692:  INCF   xBD,F
0694:  BTFSC  FD8.2
0696:  BSF    xB7.0
0698:  MOVF   FED,F
069A:  MOVF   FEF,W
069C:  BTFSC  FEF.7
069E:  BRA    06A2
06A0:  XORLW  80
06A2:  ADDWF  xBD,F
06A4:  BTFSC  FD8.0
06A6:  BSF    xB7.0
06A8:  BTFSC  xB9.4
06AA:  BRA    04A8
06AC:  BTFSC  xB9.5
06AE:  BRA    052E
06B0:  BRA    059A
06B2:  RETURN 0
*
0892:  MOVLW  8E
0894:  MOVWF  00
0896:  MOVFF  9E,01
089A:  MOVFF  9D,02
089E:  CLRF   03
08A0:  MOVF   01,F
08A2:  BNZ   08B6
08A4:  MOVFF  02,01
08A8:  CLRF   02
08AA:  MOVLW  08
08AC:  SUBWF  00,F
08AE:  MOVF   01,F
08B0:  BNZ   08B6
08B2:  CLRF   00
08B4:  BRA    08C6
08B6:  BCF    FD8.0
08B8:  BTFSC  01.7
08BA:  BRA    08C4
08BC:  RLCF   02,F
08BE:  RLCF   01,F
08C0:  DECF   00,F
08C2:  BRA    08B6
08C4:  BCF    01.7
08C6:  RETURN 0
08C8:  MOVF   xAF,W
08CA:  BTFSC  FD8.2
08CC:  BRA    09B0
08CE:  MOVWF  00
08D0:  MOVF   xB3,W
08D2:  BTFSC  FD8.2
08D4:  BRA    09B0
08D6:  ADDWF  00,F
08D8:  BNC   08E2
08DA:  MOVLW  81
08DC:  ADDWF  00,F
08DE:  BC    09B0
08E0:  BRA    08EA
08E2:  MOVLW  7F
08E4:  SUBWF  00,F
08E6:  BNC   09B0
08E8:  BZ    09B0
08EA:  MOVFF  B0,B7
08EE:  MOVF   xB4,W
08F0:  XORWF  xB7,F
08F2:  BSF    xB0.7
08F4:  BSF    xB4.7
08F6:  MOVF   xB2,W
08F8:  MULWF  xB6
08FA:  MOVFF  FF4,B9
08FE:  MOVF   xB1,W
0900:  MULWF  xB5
0902:  MOVFF  FF4,03
0906:  MOVFF  FF3,B8
090A:  MULWF  xB6
090C:  MOVF   FF3,W
090E:  ADDWF  xB9,F
0910:  MOVF   FF4,W
0912:  ADDWFC xB8,F
0914:  MOVLW  00
0916:  ADDWFC 03,F
0918:  MOVF   xB2,W
091A:  MULWF  xB5
091C:  MOVF   FF3,W
091E:  ADDWF  xB9,F
0920:  MOVF   FF4,W
0922:  ADDWFC xB8,F
0924:  MOVLW  00
0926:  CLRF   02
0928:  ADDWFC 03,F
092A:  ADDWFC 02,F
092C:  MOVF   xB0,W
092E:  MULWF  xB6
0930:  MOVF   FF3,W
0932:  ADDWF  xB8,F
0934:  MOVF   FF4,W
0936:  ADDWFC 03,F
0938:  MOVLW  00
093A:  ADDWFC 02,F
093C:  MOVF   xB0,W
093E:  MULWF  xB5
0940:  MOVF   FF3,W
0942:  ADDWF  03,F
0944:  MOVF   FF4,W
0946:  ADDWFC 02,F
0948:  MOVLW  00
094A:  CLRF   01
094C:  ADDWFC 01,F
094E:  MOVF   xB2,W
0950:  MULWF  xB4
0952:  MOVF   FF3,W
0954:  ADDWF  xB8,F
0956:  MOVF   FF4,W
0958:  ADDWFC 03,F
095A:  MOVLW  00
095C:  ADDWFC 02,F
095E:  ADDWFC 01,F
0960:  MOVF   xB1,W
0962:  MULWF  xB4
0964:  MOVF   FF3,W
0966:  ADDWF  03,F
0968:  MOVF   FF4,W
096A:  ADDWFC 02,F
096C:  MOVLW  00
096E:  ADDWFC 01,F
0970:  MOVF   xB0,W
0972:  MULWF  xB4
0974:  MOVF   FF3,W
0976:  ADDWF  02,F
0978:  MOVF   FF4,W
097A:  ADDWFC 01,F
097C:  INCF   00,F
097E:  BTFSC  01.7
0980:  BRA    098C
0982:  RLCF   xB8,F
0984:  RLCF   03,F
0986:  RLCF   02,F
0988:  RLCF   01,F
098A:  DECF   00,F
098C:  MOVLW  00
098E:  BTFSS  xB8.7
0990:  BRA    09A6
0992:  INCF   03,F
0994:  ADDWFC 02,F
0996:  ADDWFC 01,F
0998:  MOVF   01,W
099A:  BNZ   09A6
099C:  MOVF   02,W
099E:  BNZ   09A6
09A0:  MOVF   03,W
09A2:  BNZ   09A6
09A4:  INCF   00,F
09A6:  BTFSC  xB7.7
09A8:  BSF    01.7
09AA:  BTFSS  xB7.7
09AC:  BCF    01.7
09AE:  BRA    09B8
09B0:  CLRF   00
09B2:  CLRF   01
09B4:  CLRF   02
09B6:  CLRF   03
09B8:  RETURN 0
*
1BFA:  MOVLW  8E
1BFC:  MOVWF  00
1BFE:  MOVF   x79,W
1C00:  SUBWF  00,F
1C02:  MOVFF  7A,02
1C06:  MOVFF  7B,01
1C0A:  BSF    02.7
1C0C:  MOVF   00,F
1C0E:  BZ    1C22
1C10:  BCF    FD8.0
1C12:  MOVF   02,F
1C14:  BNZ   1C1A
1C16:  MOVF   01,F
1C18:  BZ    1C22
1C1A:  RRCF   02,F
1C1C:  RRCF   01,F
1C1E:  DECFSZ 00,F
1C20:  BRA    1C10
1C22:  BTFSS  x7A.7
1C24:  BRA    1C30
1C26:  COMF   01,F
1C28:  COMF   02,F
1C2A:  INCF   01,F
1C2C:  BTFSC  FD8.2
1C2E:  INCF   02,F
1C30:  RETURN 0
1C32:  TBLRD*+
1C34:  MOVFF  FF6,7B
1C38:  MOVFF  FF7,7C
1C3C:  MOVF   FF5,W
1C3E:  BTFSS  F9E.4
1C40:  BRA    1C3E
1C42:  MOVWF  FAD
1C44:  MOVFF  7B,FF6
1C48:  MOVFF  7C,FF7
1C4C:  DECFSZ x7A,F
1C4E:  BRA    1C32
1C50:  RETURN 0
1C52:  MOVF   x81,W
1C54:  CLRF   01
1C56:  SUBWF  x80,W
1C58:  BC    1C60
1C5A:  MOVFF  80,00
1C5E:  BRA    1C78
1C60:  CLRF   00
1C62:  MOVLW  08
1C64:  MOVWF  x82
1C66:  RLCF   x80,F
1C68:  RLCF   00,F
1C6A:  MOVF   x81,W
1C6C:  SUBWF  00,W
1C6E:  BTFSC  FD8.0
1C70:  MOVWF  00
1C72:  RLCF   01,F
1C74:  DECFSZ x82,F
1C76:  BRA    1C66
1C78:  RETURN 0
1C7A:  MOVLW  20
1C7C:  BTFSS  x7B.4
1C7E:  MOVLW  30
1C80:  MOVWF  x7C
1C82:  MOVFF  7A,00
1C86:  BTFSS  x7A.7
1C88:  BRA    1C9A
1C8A:  COMF   00,F
1C8C:  INCF   00,F
1C8E:  MOVFF  00,7A
1C92:  MOVLW  2D
1C94:  MOVWF  x7C
1C96:  BSF    x7B.7
1C98:  BSF    x7B.0
1C9A:  MOVF   01,W
1C9C:  MOVFF  7A,80
1CA0:  MOVLW  64
1CA2:  MOVWF  x81
1CA4:  RCALL  1C52
1CA6:  MOVFF  00,7A
1CAA:  MOVLW  30
1CAC:  ADDWF  01,W
1CAE:  MOVWF  x7D
1CB0:  MOVFF  7A,80
1CB4:  MOVLW  0A
1CB6:  MOVWF  x81
1CB8:  RCALL  1C52
1CBA:  MOVLW  30
1CBC:  ADDWF  00,W
1CBE:  MOVWF  x7F
1CC0:  MOVLW  30
1CC2:  ADDWF  01,W
1CC4:  MOVWF  x7E
1CC6:  MOVFF  7C,00
1CCA:  MOVLW  30
1CCC:  SUBWF  x7D,W
1CCE:  BZ    1CD8
1CD0:  BSF    x7B.1
1CD2:  BTFSC  x7B.7
1CD4:  BSF    x7B.2
1CD6:  BRA    1CFC
1CD8:  MOVFF  7C,7D
1CDC:  MOVLW  20
1CDE:  MOVWF  x7C
1CE0:  MOVLW  30
1CE2:  SUBWF  x7E,W
1CE4:  BZ    1CEE
1CE6:  BSF    x7B.0
1CE8:  BTFSC  x7B.7
1CEA:  BSF    x7B.1
1CEC:  BRA    1CFC
1CEE:  BTFSS  FD8.2
1CF0:  BSF    x7B.0
1CF2:  BNZ   1CFC
1CF4:  MOVFF  7D,7E
1CF8:  MOVLW  20
1CFA:  MOVWF  x7D
1CFC:  BTFSC  x7B.2
1CFE:  BRA    1D0A
1D00:  BTFSC  x7B.1
1D02:  BRA    1D12
1D04:  BTFSC  x7B.0
1D06:  BRA    1D1A
1D08:  BRA    1D22
1D0A:  MOVF   x7C,W
1D0C:  BTFSS  F9E.4
1D0E:  BRA    1D0C
1D10:  MOVWF  FAD
1D12:  MOVF   x7D,W
1D14:  BTFSS  F9E.4
1D16:  BRA    1D14
1D18:  MOVWF  FAD
1D1A:  MOVF   x7E,W
1D1C:  BTFSS  F9E.4
1D1E:  BRA    1D1C
1D20:  MOVWF  FAD
1D22:  MOVF   x7F,W
1D24:  BTFSS  F9E.4
1D26:  BRA    1D24
1D28:  MOVWF  FAD
1D2A:  RETURN 0
1D2C:  MOVF   x84,W
1D2E:  SUBLW  B6
1D30:  MOVWF  x84
1D32:  CLRF   03
1D34:  MOVFF  85,88
1D38:  BSF    x85.7
1D3A:  BCF    FD8.0
1D3C:  RRCF   x85,F
1D3E:  RRCF   x86,F
1D40:  RRCF   x87,F
1D42:  RRCF   03,F
1D44:  RRCF   02,F
1D46:  RRCF   01,F
1D48:  RRCF   00,F
1D4A:  DECFSZ x84,F
1D4C:  BRA    1D3A
1D4E:  BTFSS  x88.7
1D50:  BRA    1D68
1D52:  COMF   00,F
1D54:  COMF   01,F
1D56:  COMF   02,F
1D58:  COMF   03,F
1D5A:  INCF   00,F
1D5C:  BTFSC  FD8.2
1D5E:  INCF   01,F
1D60:  BTFSC  FD8.2
1D62:  INCF   02,F
1D64:  BTFSC  FD8.2
1D66:  INCF   03,F
1D68:  RETURN 0
1D6A:  BTFSC  FD8.1
1D6C:  BRA    1D74
1D6E:  CLRF   FEA
1D70:  MOVLW  8C
1D72:  MOVWF  FE9
1D74:  CLRF   00
1D76:  CLRF   01
1D78:  CLRF   02
1D7A:  CLRF   03
1D7C:  CLRF   x8C
1D7E:  CLRF   x8D
1D80:  CLRF   x8E
1D82:  CLRF   x8F
1D84:  MOVF   x8B,W
1D86:  IORWF  x8A,W
1D88:  IORWF  x89,W
1D8A:  IORWF  x88,W
1D8C:  BZ    1DE6
1D8E:  MOVLW  20
1D90:  MOVWF  x90
1D92:  BCF    FD8.0
1D94:  RLCF   x84,F
1D96:  RLCF   x85,F
1D98:  RLCF   x86,F
1D9A:  RLCF   x87,F
1D9C:  RLCF   x8C,F
1D9E:  RLCF   x8D,F
1DA0:  RLCF   x8E,F
1DA2:  RLCF   x8F,F
1DA4:  MOVF   x8B,W
1DA6:  SUBWF  x8F,W
1DA8:  BNZ   1DBA
1DAA:  MOVF   x8A,W
1DAC:  SUBWF  x8E,W
1DAE:  BNZ   1DBA
1DB0:  MOVF   x89,W
1DB2:  SUBWF  x8D,W
1DB4:  BNZ   1DBA
1DB6:  MOVF   x88,W
1DB8:  SUBWF  x8C,W
1DBA:  BNC   1DDA
1DBC:  MOVF   x88,W
1DBE:  SUBWF  x8C,F
1DC0:  MOVF   x89,W
1DC2:  BTFSS  FD8.0
1DC4:  INCFSZ x89,W
1DC6:  SUBWF  x8D,F
1DC8:  MOVF   x8A,W
1DCA:  BTFSS  FD8.0
1DCC:  INCFSZ x8A,W
1DCE:  SUBWF  x8E,F
1DD0:  MOVF   x8B,W
1DD2:  BTFSS  FD8.0
1DD4:  INCFSZ x8B,W
1DD6:  SUBWF  x8F,F
1DD8:  BSF    FD8.0
1DDA:  RLCF   00,F
1DDC:  RLCF   01,F
1DDE:  RLCF   02,F
1DE0:  RLCF   03,F
1DE2:  DECFSZ x90,F
1DE4:  BRA    1D92
1DE6:  MOVFF  8C,FEF
1DEA:  MOVFF  8D,FEC
1DEE:  MOVFF  8E,FEC
1DF2:  MOVFF  8F,FEC
1DF6:  RETURN 0
1DF8:  MOVF   FE9,W
1DFA:  MOVWF  x7C
1DFC:  MOVF   x7B,W
1DFE:  MOVWF  x7E
1E00:  BZ    1E36
1E02:  MOVFF  7A,B2
1E06:  MOVFF  79,B1
1E0A:  MOVFF  78,B0
1E0E:  MOVFF  77,AF
1E12:  CLRF   xB6
1E14:  CLRF   xB5
1E16:  MOVLW  20
1E18:  MOVWF  xB4
1E1A:  MOVLW  82
1E1C:  MOVWF  xB3
1E1E:  CALL   08C8
1E22:  MOVFF  03,7A
1E26:  MOVFF  02,79
1E2A:  MOVFF  01,78
1E2E:  MOVFF  00,77
1E32:  DECFSZ x7E,F
1E34:  BRA    1E02
1E36:  MOVLW  7E
1E38:  MOVWF  00
1E3A:  CLRF   01
1E3C:  BTFSC  x78.7
1E3E:  BSF    01.7
1E40:  CLRF   02
1E42:  CLRF   03
1E44:  BCF    FD8.1
1E46:  MOVFF  7A,B2
1E4A:  MOVFF  79,B1
1E4E:  MOVFF  78,B0
1E52:  MOVFF  77,AF
1E56:  MOVFF  03,B6
1E5A:  MOVFF  02,B5
1E5E:  MOVFF  01,B4
1E62:  MOVWF  xB3
1E64:  CALL   044A
1E68:  MOVFF  03,7A
1E6C:  MOVFF  02,79
1E70:  MOVFF  01,78
1E74:  MOVFF  00,77
1E78:  MOVFF  7A,87
1E7C:  MOVFF  79,86
1E80:  MOVFF  78,85
1E84:  MOVFF  77,84
1E88:  RCALL  1D2C
1E8A:  MOVFF  03,7A
1E8E:  MOVFF  02,79
1E92:  MOVFF  01,78
1E96:  MOVFF  00,77
1E9A:  BTFSS  x7A.7
1E9C:  BRA    1EB8
1E9E:  DECF   x7C,F
1EA0:  BSF    x7C.5
1EA2:  COMF   x77,F
1EA4:  COMF   x78,F
1EA6:  COMF   x79,F
1EA8:  COMF   x7A,F
1EAA:  INCF   x77,F
1EAC:  BTFSC  FD8.2
1EAE:  INCF   x78,F
1EB0:  BTFSC  FD8.2
1EB2:  INCF   x79,F
1EB4:  BTFSC  FD8.2
1EB6:  INCF   x7A,F
1EB8:  MOVLW  3B
1EBA:  MOVWF  x83
1EBC:  MOVLW  9A
1EBE:  MOVWF  x82
1EC0:  MOVLW  CA
1EC2:  MOVWF  x81
1EC4:  CLRF   x80
1EC6:  MOVLW  0A
1EC8:  MOVWF  x7E
1ECA:  MOVF   x7B,W
1ECC:  BTFSC  FD8.2
1ECE:  INCF   x7C,F
1ED0:  BSF    FD8.1
1ED2:  CLRF   FEA
1ED4:  MOVLW  77
1ED6:  MOVWF  FE9
1ED8:  MOVFF  7A,87
1EDC:  MOVFF  79,86
1EE0:  MOVFF  78,85
1EE4:  MOVFF  77,84
1EE8:  MOVFF  83,8B
1EEC:  MOVFF  82,8A
1EF0:  MOVFF  81,89
1EF4:  MOVFF  80,88
1EF8:  RCALL  1D6A
1EFA:  MOVF   01,W
1EFC:  MOVF   00,F
1EFE:  BNZ   1F1E
1F00:  INCF   x7B,W
1F02:  SUBWF  x7E,W
1F04:  BZ    1F1E
1F06:  MOVF   x7C,W
1F08:  BZ    1F22
1F0A:  ANDLW  0F
1F0C:  SUBWF  x7E,W
1F0E:  BZ    1F12
1F10:  BC    1F88
1F12:  BTFSC  x7C.7
1F14:  BRA    1F88
1F16:  BTFSC  x7C.6
1F18:  BRA    1F22
1F1A:  MOVLW  20
1F1C:  BRA    1F7E
1F1E:  MOVLW  20
1F20:  ANDWF  x7C,F
1F22:  BTFSS  x7C.5
1F24:  BRA    1F40
1F26:  BCF    x7C.5
1F28:  MOVF   x7B,W
1F2A:  BTFSS  FD8.2
1F2C:  DECF   x7C,F
1F2E:  MOVF   00,W
1F30:  MOVWF  x7C
1F32:  MOVLW  2D
1F34:  BTFSS  F9E.4
1F36:  BRA    1F34
1F38:  MOVWF  FAD
1F3A:  MOVF   x7C,W
1F3C:  MOVWF  00
1F3E:  CLRF   x7C
1F40:  MOVF   x7B,W
1F42:  SUBWF  x7E,W
1F44:  BNZ   1F5C
1F46:  MOVF   00,W
1F48:  MOVWF  x7C
1F4A:  MOVLW  2E
1F4C:  BTFSS  F9E.4
1F4E:  BRA    1F4C
1F50:  MOVWF  FAD
1F52:  MOVF   x7C,W
1F54:  MOVWF  00
1F56:  MOVLW  20
1F58:  ANDWF  x7C,F
1F5A:  MOVLW  00
1F5C:  MOVLW  30
1F5E:  BTFSS  x7C.5
1F60:  BRA    1F7E
1F62:  BCF    x7C.5
1F64:  MOVF   x7B,W
1F66:  BTFSS  FD8.2
1F68:  DECF   x7C,F
1F6A:  MOVF   00,W
1F6C:  MOVWF  x7C
1F6E:  MOVLW  2D
1F70:  BTFSS  F9E.4
1F72:  BRA    1F70
1F74:  MOVWF  FAD
1F76:  MOVF   x7C,W
1F78:  MOVWF  00
1F7A:  CLRF   x7C
1F7C:  MOVLW  30
1F7E:  ADDWF  00,F
1F80:  MOVF   00,W
1F82:  BTFSS  F9E.4
1F84:  BRA    1F82
1F86:  MOVWF  FAD
1F88:  BCF    FD8.1
1F8A:  MOVFF  83,87
1F8E:  MOVFF  82,86
1F92:  MOVFF  81,85
1F96:  MOVFF  80,84
1F9A:  CLRF   x8B
1F9C:  CLRF   x8A
1F9E:  CLRF   x89
1FA0:  MOVLW  0A
1FA2:  MOVWF  x88
1FA4:  RCALL  1D6A
1FA6:  MOVFF  03,83
1FAA:  MOVFF  02,82
1FAE:  MOVFF  01,81
1FB2:  MOVFF  00,80
1FB6:  DECFSZ x7E,F
1FB8:  BRA    1ED0
1FBA:  RETURN 0
*
2100:  DATA 52,61
2102:  DATA 77,3A
2104:  DATA 30,2C
2106:  DATA 30,2C
2108:  DATA 30,2C
210A:  DATA 30,2C
210C:  DATA 30,2C
210E:  DATA 30,2C
2110:  DATA 25,64
2112:  DATA 2C,25
2114:  DATA 64,2C
2116:  DATA 25,64
2118:  DATA 0A,00
211A:  DATA 55,6E
211C:  DATA 69,3A
211E:  DATA 30,2E
2120:  DATA 30,30
2122:  DATA 2C,30
2124:  DATA 2E,30
2126:  DATA 30,2C
2128:  DATA 30,2E
212A:  DATA 30,30
212C:  DATA 2C,30
212E:  DATA 2E,30
2130:  DATA 30,2C
2132:  DATA 30,2E
2134:  DATA 30,30
2136:  DATA 2C,30
2138:  DATA 2E,30
213A:  DATA 30,2C
213C:  DATA 25,67
213E:  DATA 2C,25
2140:  DATA 67,2C
2142:  DATA 25,67
2144:  DATA 20,0A
2146:  DATA 00,00
2148:  DATA 1B,5B
214A:  DATA 33,33
214C:  DATA 6D,73
214E:  DATA 74,61
2150:  DATA 72,74
2152:  DATA 20,6F
2154:  DATA 66,20
2156:  DATA 69,6E
2158:  DATA 69,74
215A:  DATA 20,20
215C:  DATA 0A,0D
215E:  DATA 1B,5B
2160:  DATA 30,6D
2162:  DATA 00,00
2164:  DATA 43,61
2166:  DATA 6C,69
2168:  DATA 62,72
216A:  DATA 61,74
216C:  DATA 69,6F
216E:  DATA 6E,20
2170:  DATA 6F,66
2172:  DATA 20,47
2174:  DATA 79,72
2176:  DATA 6F,20
2178:  DATA 69,73
217A:  DATA 20,73
217C:  DATA 74,61
217E:  DATA 72,74
2180:  DATA 65,64
2182:  DATA 20,64
2184:  DATA 6F,6E
2186:  DATA 27,74
2188:  DATA 20,6D
218A:  DATA 6F,76
218C:  DATA 65,20
218E:  DATA 74,68
2190:  DATA 65,20
2192:  DATA 73,65
2194:  DATA 6E,73
2196:  DATA 6F,72
2198:  DATA 0A,0D
219A:  DATA 00,00
219C:  DATA 43,61
219E:  DATA 6C,69
21A0:  DATA 62,72
21A2:  DATA 61,74
21A4:  DATA 69,6F
21A6:  DATA 6E,20
21A8:  DATA 6F,66
21AA:  DATA 20,47
21AC:  DATA 79,72
21AE:  DATA 6F,20
21B0:  DATA 69,73
21B2:  DATA 20,66
21B4:  DATA 69,6E
21B6:  DATA 69,73
21B8:  DATA 68,65
21BA:  DATA 64,0A
21BC:  DATA 0D,00
21BE:  DATA 52,61
21C0:  DATA 74,65
21C2:  DATA 43,61
21C4:  DATA 6C,69
21C6:  DATA 62,72
21C8:  DATA 61,74
21CA:  DATA 69,6F
21CC:  DATA 6E,50
21CE:  DATA 69,74
21D0:  DATA 63,68
21D2:  DATA 20,3D
21D4:  DATA 20,25
21D6:  DATA 2E,35
21D8:  DATA 66,20
21DA:  DATA 2C,20
21DC:  DATA 52,61
21DE:  DATA 74,65
21E0:  DATA 43,61
21E2:  DATA 6C,69
21E4:  DATA 62,72
21E6:  DATA 61,74
21E8:  DATA 69,6F
21EA:  DATA 6E,52
21EC:  DATA 6F,6C
21EE:  DATA 6C,20
21F0:  DATA 3D,20
21F2:  DATA 25,2E
21F4:  DATA 35,66
21F6:  DATA 20,2C
21F8:  DATA 20,52
21FA:  DATA 61,74
21FC:  DATA 65,43
21FE:  DATA 61,6C
2200:  DATA 69,62
2202:  DATA 72,61
2204:  DATA 74,69
2206:  DATA 6F,6E
2208:  DATA 59,61
220A:  DATA 77,20
220C:  DATA 3D,20
220E:  DATA 25,2E
2210:  DATA 35,66
2212:  DATA 20,0A
2214:  DATA 0D,00
*
23EE:  TBLRD*+
23F0:  MOVF   FF5,F
23F2:  BZ    240E
23F4:  MOVFF  FF6,5A
23F8:  MOVFF  FF7,5B
23FC:  MOVF   FF5,W
23FE:  BTFSS  F9E.4
2400:  BRA    23FE
2402:  MOVWF  FAD
2404:  MOVFF  5A,FF6
2408:  MOVFF  5B,FF7
240C:  BRA    23EE
240E:  RETURN 0
*
29D0:  MOVF   FE9,W
29D2:  MOVWF  5E
29D4:  MOVF   5D,W
29D6:  MOVWF  x60
29D8:  BZ    2A1A
29DA:  CLRF   16
29DC:  BTFSC  FF2.7
29DE:  BSF    16.7
29E0:  BCF    FF2.7
29E2:  MOVFF  5C,B2
29E6:  MOVFF  5B,B1
29EA:  MOVFF  5A,B0
29EE:  MOVFF  59,AF
29F2:  CLRF   xB6
29F4:  CLRF   xB5
29F6:  MOVLW  20
29F8:  MOVWF  xB4
29FA:  MOVLW  82
29FC:  MOVWF  xB3
29FE:  CALL   08C8
2A02:  BTFSC  16.7
2A04:  BSF    FF2.7
2A06:  MOVFF  03,5C
2A0A:  MOVFF  02,5B
2A0E:  MOVFF  01,5A
2A12:  MOVFF  00,59
2A16:  DECFSZ x60,F
2A18:  BRA    29DA
2A1A:  CLRF   16
2A1C:  BTFSC  FF2.7
2A1E:  BSF    16.7
2A20:  BCF    FF2.7
2A22:  MOVFF  5C,87
2A26:  MOVFF  5B,86
2A2A:  MOVFF  5A,85
2A2E:  MOVFF  59,84
2A32:  CALL   1D2C
2A36:  BTFSC  16.7
2A38:  BSF    FF2.7
2A3A:  MOVFF  03,5C
2A3E:  MOVFF  02,5B
2A42:  MOVFF  01,5A
2A46:  MOVFF  00,59
2A4A:  BTFSS  5C.7
2A4C:  BRA    2A68
2A4E:  DECF   5E,F
2A50:  BSF    5E.5
2A52:  COMF   59,F
2A54:  COMF   5A,F
2A56:  COMF   5B,F
2A58:  COMF   5C,F
2A5A:  INCF   59,F
2A5C:  BTFSC  FD8.2
2A5E:  INCF   5A,F
2A60:  BTFSC  FD8.2
2A62:  INCF   5B,F
2A64:  BTFSC  FD8.2
2A66:  INCF   5C,F
2A68:  MOVLW  3B
2A6A:  MOVWF  x65
2A6C:  MOVLW  9A
2A6E:  MOVWF  x64
2A70:  MOVLW  CA
2A72:  MOVWF  x63
2A74:  CLRF   x62
2A76:  MOVLW  0A
2A78:  MOVWF  x60
2A7A:  MOVF   5D,W
2A7C:  BTFSC  FD8.2
2A7E:  INCF   5E,F
2A80:  BSF    FD8.1
2A82:  CLRF   FEA
2A84:  MOVLW  59
2A86:  MOVWF  FE9
2A88:  CLRF   16
2A8A:  BTFSC  FF2.7
2A8C:  BSF    16.7
2A8E:  BCF    FF2.7
2A90:  MOVFF  5C,87
2A94:  MOVFF  5B,86
2A98:  MOVFF  5A,85
2A9C:  MOVFF  59,84
2AA0:  MOVFF  65,8B
2AA4:  MOVFF  64,8A
2AA8:  MOVFF  63,89
2AAC:  MOVFF  62,88
2AB0:  CALL   1D6A
2AB4:  BTFSC  16.7
2AB6:  BSF    FF2.7
2AB8:  MOVF   01,W
2ABA:  MOVF   00,F
2ABC:  BNZ   2ADC
2ABE:  INCF   5D,W
2AC0:  SUBWF  x60,W
2AC2:  BZ    2ADC
2AC4:  MOVF   5E,W
2AC6:  BZ    2AE0
2AC8:  ANDLW  0F
2ACA:  SUBWF  x60,W
2ACC:  BZ    2AD0
2ACE:  BC    2B46
2AD0:  BTFSC  5E.7
2AD2:  BRA    2B46
2AD4:  BTFSC  5E.6
2AD6:  BRA    2AE0
2AD8:  MOVLW  20
2ADA:  BRA    2B3C
2ADC:  MOVLW  20
2ADE:  ANDWF  5E,F
2AE0:  BTFSS  5E.5
2AE2:  BRA    2AFE
2AE4:  BCF    5E.5
2AE6:  MOVF   5D,W
2AE8:  BTFSS  FD8.2
2AEA:  DECF   5E,F
2AEC:  MOVF   00,W
2AEE:  MOVWF  5E
2AF0:  MOVLW  2D
2AF2:  BTFSS  F9E.4
2AF4:  BRA    2AF2
2AF6:  MOVWF  FAD
2AF8:  MOVF   5E,W
2AFA:  MOVWF  00
2AFC:  CLRF   5E
2AFE:  MOVF   5D,W
2B00:  SUBWF  x60,W
2B02:  BNZ   2B1A
2B04:  MOVF   00,W
2B06:  MOVWF  5E
2B08:  MOVLW  2E
2B0A:  BTFSS  F9E.4
2B0C:  BRA    2B0A
2B0E:  MOVWF  FAD
2B10:  MOVF   5E,W
2B12:  MOVWF  00
2B14:  MOVLW  20
2B16:  ANDWF  5E,F
2B18:  MOVLW  00
2B1A:  MOVLW  30
2B1C:  BTFSS  5E.5
2B1E:  BRA    2B3C
2B20:  BCF    5E.5
2B22:  MOVF   5D,W
2B24:  BTFSS  FD8.2
2B26:  DECF   5E,F
2B28:  MOVF   00,W
2B2A:  MOVWF  5E
2B2C:  MOVLW  2D
2B2E:  BTFSS  F9E.4
2B30:  BRA    2B2E
2B32:  MOVWF  FAD
2B34:  MOVF   5E,W
2B36:  MOVWF  00
2B38:  CLRF   5E
2B3A:  MOVLW  30
2B3C:  ADDWF  00,F
2B3E:  MOVF   00,W
2B40:  BTFSS  F9E.4
2B42:  BRA    2B40
2B44:  MOVWF  FAD
2B46:  BCF    FD8.1
2B48:  CLRF   16
2B4A:  BTFSC  FF2.7
2B4C:  BSF    16.7
2B4E:  BCF    FF2.7
2B50:  MOVFF  65,87
2B54:  MOVFF  64,86
2B58:  MOVFF  63,85
2B5C:  MOVFF  62,84
2B60:  CLRF   x8B
2B62:  CLRF   x8A
2B64:  CLRF   x89
2B66:  MOVLW  0A
2B68:  MOVWF  x88
2B6A:  CALL   1D6A
2B6E:  BTFSC  16.7
2B70:  BSF    FF2.7
2B72:  MOVFF  03,65
2B76:  MOVFF  02,64
2B7A:  MOVFF  01,63
2B7E:  MOVFF  00,62
2B82:  DECFSZ x60,F
2B84:  BRA    2A80
2B86:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
*
23C8:  CLRF   FEA
23CA:  MOVLW  5D
23CC:  MOVWF  FE9
23CE:  MOVF   FEF,W
23D0:  BZ    23EC
23D2:  MOVLW  02
23D4:  MOVWF  01
23D6:  CLRF   00
23D8:  DECFSZ 00,F
23DA:  BRA    23D8
23DC:  DECFSZ 01,F
23DE:  BRA    23D6
23E0:  MOVLW  97
23E2:  MOVWF  00
23E4:  DECFSZ 00,F
23E6:  BRA    23E4
23E8:  DECFSZ FEF,F
23EA:  BRA    23D2
23EC:  RETURN 0
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
*
00CA:  BCF    FC6.7
00CC:  BCF    F9E.3
00CE:  MOVFF  AB,FC9
00D2:  MOVLW  02
00D4:  BTFSC  FC6.7
00D6:  BRA    00E2
00D8:  BTFSS  F9E.3
00DA:  BRA    00D8
00DC:  MOVLW  00
00DE:  BTFSC  FC5.6
00E0:  MOVLW  01
00E2:  MOVWF  01
00E4:  RETURN 0
00E6:  BCF    FC6.6
00E8:  BSF    FC5.3
00EA:  BTFSC  FC5.3
00EC:  BRA    00EA
00EE:  BTFSC  00.0
00F0:  BCF    FC5.5
00F2:  BTFSS  00.0
00F4:  BSF    FC5.5
00F6:  BSF    FC5.4
00F8:  BTFSC  FC5.4
00FA:  BRA    00F8
00FC:  MOVFF  FC9,01
0100:  RETURN 0
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
....................  
.................... #include "mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
.................... #include "mpu9250_config.h" 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_CONFIG_H 
.................... #define	MPU9250_CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_CONFIG_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // ±2 g 
.................... #define AFS_4G          0x08 // ±4 g 
.................... #define AFS_8G          0x10 // ±8 g 
.................... #define AFS_16G         0x18 // ±16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // ±250 dps 
.................... #define GFS_500         0x08 // ±500 dps 
.................... #define GFS_1000        0x10 // ±1000 dps 
.................... #define GFS_2000        0x18 // ±2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
.................... #include "mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... #include "mpu9250_config.h" 
.................... #include "mpu9250_private.h" 
.................... #include "mpu9250_interface.h" 
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]); 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[],float magData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]); 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[],float magData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // ±2 g 
.................... #define AFS_4G          0x08 // ±4 g 
.................... #define AFS_8G          0x10 // ±8 g 
.................... #define AFS_16G         0x18 // ±16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // ±250 dps 
.................... #define GFS_500         0x08 // ±500 dps 
.................... #define GFS_1000        0x10 // ±1000 dps 
.................... #define GFS_2000        0x18 // ±2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
....................  
....................  
.................... static void imu_update(void); 
.................... // Declare variables to store the sensor values 
.................... float gyro[3] = {0.0, 0.0, 0.0} ; 
.................... float mag[3] = {0.0, 0.0, 0.0}   ; 
.................... float accel[3] = {0.0, 0.0, 0.0}    ; 
....................  
.................... RateCalibration_t RateCalibration = {0.0, 0.0, 0.0} ; 
.................... Angle_t Angle = {0.0, 0.0, 0.0} ; 
....................  
....................  
.................... #INT_TIMER2 
.................... static void imu_update(void) 
.................... { 
....................         
....................        mpu9250_read_gyro(gyro); 
*
1FBC:  CLRF   x78
1FBE:  MOVLW  1D
1FC0:  MOVWF  x77
1FC2:  CALL   0334
....................        mpu9250_calculate_angles(&Angle,accel,(int32_t)mag); 
1FC6:  CLRF   x78
1FC8:  MOVLW  29
1FCA:  MOVWF  x77
1FCC:  MOVFF  78,7A
1FD0:  MOVWF  x79
1FD2:  CLRF   x7C
1FD4:  MOVLW  4D
1FD6:  MOVWF  x7B
1FD8:  CLRF   x7E
1FDA:  MOVLW  35
1FDC:  MOVWF  x7D
1FDE:  MOVFF  78,80
1FE2:  MOVFF  77,7F
1FE6:  GOTO   1382
....................        printf("Raw:0,0,0,0,0,0,%d,%d,%d\n",(int)mag[0]*10,(int)mag[1]*10,(int)mag[2]*10); 
1FEA:  MOVFF  2C,7C
1FEE:  MOVFF  2B,7B
1FF2:  MOVFF  2A,7A
1FF6:  MOVFF  29,79
1FFA:  RCALL  1BFA
1FFC:  MOVF   01,W
1FFE:  MULLW  0A
2000:  MOVFF  FF3,77
2004:  MOVFF  30,7C
2008:  MOVFF  2F,7B
200C:  MOVFF  2E,7A
2010:  MOVFF  2D,79
2014:  RCALL  1BFA
2016:  MOVF   01,W
2018:  MULLW  0A
201A:  MOVFF  FF3,78
201E:  MOVFF  34,7C
2022:  MOVFF  33,7B
2026:  MOVFF  32,7A
202A:  MOVFF  31,79
202E:  RCALL  1BFA
2030:  MOVF   01,W
2032:  MULLW  0A
2034:  MOVFF  FF3,79
2038:  MOVLW  00
203A:  MOVWF  FF6
203C:  MOVLW  21
203E:  MOVWF  FF7
2040:  MOVLW  10
2042:  MOVWF  x7A
2044:  RCALL  1C32
2046:  MOVFF  77,7A
204A:  MOVLW  18
204C:  MOVWF  x7B
204E:  RCALL  1C7A
2050:  MOVLW  2C
2052:  BTFSS  F9E.4
2054:  BRA    2052
2056:  MOVWF  FAD
2058:  MOVFF  78,7A
205C:  MOVLW  18
205E:  MOVWF  x7B
2060:  RCALL  1C7A
2062:  MOVLW  2C
2064:  BTFSS  F9E.4
2066:  BRA    2064
2068:  MOVWF  FAD
206A:  MOVFF  79,7A
206E:  MOVLW  18
2070:  MOVWF  x7B
2072:  RCALL  1C7A
2074:  MOVLW  0A
2076:  BTFSS  F9E.4
2078:  BRA    2076
207A:  MOVWF  FAD
....................        printf("Uni:0.00,0.00,0.00,0.00,0.00,0.00,%g,%g,%g \n",mag[0],mag[1],mag[2]); 
207C:  MOVLW  1A
207E:  MOVWF  FF6
2080:  MOVLW  21
2082:  MOVWF  FF7
2084:  MOVLW  22
2086:  MOVWF  x7A
2088:  RCALL  1C32
208A:  MOVLW  89
208C:  MOVWF  FE9
208E:  MOVFF  2C,7A
2092:  MOVFF  2B,79
2096:  MOVFF  2A,78
209A:  MOVFF  29,77
209E:  MOVLW  02
20A0:  MOVWF  x7B
20A2:  RCALL  1DF8
20A4:  MOVLW  2C
20A6:  BTFSS  F9E.4
20A8:  BRA    20A6
20AA:  MOVWF  FAD
20AC:  MOVLW  89
20AE:  MOVWF  FE9
20B0:  MOVFF  30,7A
20B4:  MOVFF  2F,79
20B8:  MOVFF  2E,78
20BC:  MOVFF  2D,77
20C0:  MOVLW  02
20C2:  MOVWF  x7B
20C4:  RCALL  1DF8
20C6:  MOVLW  2C
20C8:  BTFSS  F9E.4
20CA:  BRA    20C8
20CC:  MOVWF  FAD
20CE:  MOVLW  89
20D0:  MOVWF  FE9
20D2:  MOVFF  34,7A
20D6:  MOVFF  33,79
20DA:  MOVFF  32,78
20DE:  MOVFF  31,77
20E2:  MOVLW  02
20E4:  MOVWF  x7B
20E6:  RCALL  1DF8
20E8:  MOVLW  20
20EA:  BTFSS  F9E.4
20EC:  BRA    20EA
20EE:  MOVWF  FAD
20F0:  MOVLW  0A
20F2:  BTFSS  F9E.4
20F4:  BRA    20F2
20F6:  MOVWF  FAD
....................  
....................        clear_interrupt(INT_TIMER2); 
20F8:  BCF    F9E.1
20FA:  BCF    F9E.1
20FC:  GOTO   0054
.................... } 
....................  
....................  
.................... void i2c_reset() 
.................... { 
....................  
.................... output_high(PIN_B0); 
.................... for (int i = 0; i < 10; i++)  
....................     { //9nth cycle acts as NACK 
....................         output_high(PIN_B1); 
....................         delay_us(5); 
....................          output_low(PIN_B1); 
....................         delay_us(5); 
....................     } 
....................   output_low(PIN_B0); 
....................   delay_us(5); 
....................   output_high(PIN_B1); 
....................   delay_us(5); 
....................   output_high(PIN_B0); 
....................   delay_us(5); 
....................    
....................   output_float(PIN_B1);                           // SCL 
....................   output_float(PIN_B0);                           // SDA 
....................   i2c_init(1); 
.................... } 
....................  
....................  
.................... void main() { 
*
2B88:  CLRF   FF8
2B8A:  BCF    FD0.7
2B8C:  BSF    07.7
2B8E:  BSF    FB8.3
2B90:  MOVLW  10
2B92:  MOVWF  FAF
2B94:  MOVLW  00
2B96:  MOVWF  FB0
2B98:  MOVLW  A6
2B9A:  MOVWF  FAC
2B9C:  MOVLW  90
2B9E:  MOVWF  FAB
2BA0:  BSF    F93.1
2BA2:  BSF    F93.0
2BA4:  MOVLW  04
2BA6:  MOVWF  FC8
2BA8:  MOVLW  28
2BAA:  MOVWF  FC6
2BAC:  BCF    FC7.7
2BAE:  BCF    FC7.6
2BB0:  BSF    FC7.6
2BB2:  BRA    2BC8
2BB4:  DATA 02,00
2BB6:  DATA 17,00
2BB8:  DATA 00,01
2BBA:  DATA 0F,B4
2BBC:  DATA 07,3C
2BBE:  DATA 40,1D
2BC0:  DATA 00,02
2BC2:  DATA 00,17
2BC4:  DATA 00,00
2BC6:  DATA 00,00
2BC8:  MOVLW  00
2BCA:  MOVWF  FF8
2BCC:  MOVLW  2B
2BCE:  MOVWF  FF7
2BD0:  MOVLW  B4
2BD2:  MOVWF  FF6
2BD4:  TBLRD*+
2BD6:  MOVF   FF5,W
2BD8:  MOVWF  00
2BDA:  XORLW  00
2BDC:  BZ    2C04
2BDE:  TBLRD*+
2BE0:  MOVF   FF5,W
2BE2:  MOVWF  01
2BE4:  BTFSC  FE8.7
2BE6:  BRA    2BF2
2BE8:  ANDLW  0F
2BEA:  MOVWF  FEA
2BEC:  TBLRD*+
2BEE:  MOVFF  FF5,FE9
2BF2:  BTFSC  01.6
2BF4:  TBLRD*+
2BF6:  BTFSS  01.6
2BF8:  TBLRD*+
2BFA:  MOVFF  FF5,FEE
2BFE:  DCFSNZ 00,F
2C00:  BRA    2BD4
2C02:  BRA    2BF6
2C04:  CLRF   FF8
....................      
....................      
....................      
....................   output_float(PIN_B1);                           // SCL 
2C06:  BSF    F93.1
....................   output_float(PIN_B0);                           // SDA 
2C08:  BSF    F93.0
....................  
....................     delay_ms(500); 
2C0A:  MOVLW  02
2C0C:  MOVWF  59
2C0E:  MOVLW  FA
2C10:  MOVWF  5D
2C12:  CALL   23C8
2C16:  DECFSZ 59,F
2C18:  BRA    2C0E
....................  
....................     printf(ANSI_COLOR_YELLOW"start of init  \n\r"ANSI_COLOR_RESET ); 
2C1A:  MOVLW  48
2C1C:  MOVWF  FF6
2C1E:  MOVLW  21
2C20:  MOVWF  FF7
2C22:  CALL   23EE
....................      
....................     mpu9250_init();                                 // Init the MPU9250 
2C26:  BRA    245E
....................  
....................     mpu9250_print_initRegisters() ;                  // Print the registers of the MPU9250 
2C28:  BRA    259A
....................     printf("Calibration of Gyro is started don't move the sensor\n\r"); 
2C2A:  MOVLW  64
2C2C:  MOVWF  FF6
2C2E:  MOVLW  21
2C30:  MOVWF  FF7
2C32:  CALL   23EE
....................     delay_ms(1000); 
2C36:  MOVLW  04
2C38:  MOVWF  59
2C3A:  MOVLW  FA
2C3C:  MOVWF  5D
2C3E:  CALL   23C8
2C42:  DECFSZ 59,F
2C44:  BRA    2C3A
....................     mpu9250_gyro_calibration(&RateCalibration);     // Calibrate the gyro 
2C46:  CLRF   5A
2C48:  MOVLW  41
2C4A:  MOVWF  59
2C4C:  BRA    2796
....................     printf("Calibration of Gyro is finished\n\r"); 
2C4E:  MOVLW  9C
2C50:  MOVWF  FF6
2C52:  MOVLW  21
2C54:  MOVWF  FF7
2C56:  CALL   23EE
....................     printf("RateCalibrationPitch = %.5f , RateCalibrationRoll = %.5f , RateCalibrationYaw = %.5f \n\r",RateCalibration.pitch,RateCalibration.roll,RateCalibration.yaw); 
2C5A:  MOVLW  BE
2C5C:  MOVWF  FF6
2C5E:  MOVLW  21
2C60:  MOVWF  FF7
2C62:  CLRF   16
2C64:  BTFSC  FF2.7
2C66:  BSF    16.7
2C68:  BCF    FF2.7
2C6A:  MOVLW  17
2C6C:  MOVWF  x7A
2C6E:  CALL   1C32
2C72:  BTFSC  16.7
2C74:  BSF    FF2.7
2C76:  MOVLW  89
2C78:  MOVWF  FE9
2C7A:  MOVFF  44,5C
2C7E:  MOVFF  43,5B
2C82:  MOVFF  42,5A
2C86:  MOVFF  41,59
2C8A:  MOVLW  05
2C8C:  MOVWF  5D
2C8E:  RCALL  29D0
2C90:  MOVLW  D9
2C92:  MOVWF  FF6
2C94:  MOVLW  21
2C96:  MOVWF  FF7
2C98:  CLRF   16
2C9A:  BTFSC  FF2.7
2C9C:  BSF    16.7
2C9E:  BCF    FF2.7
2CA0:  MOVLW  19
2CA2:  MOVWF  x7A
2CA4:  CALL   1C32
2CA8:  BTFSC  16.7
2CAA:  BSF    FF2.7
2CAC:  MOVLW  89
2CAE:  MOVWF  FE9
2CB0:  MOVFF  48,5C
2CB4:  MOVFF  47,5B
2CB8:  MOVFF  46,5A
2CBC:  MOVFF  45,59
2CC0:  MOVLW  05
2CC2:  MOVWF  5D
2CC4:  RCALL  29D0
2CC6:  MOVLW  F6
2CC8:  MOVWF  FF6
2CCA:  MOVLW  21
2CCC:  MOVWF  FF7
2CCE:  CLRF   16
2CD0:  BTFSC  FF2.7
2CD2:  BSF    16.7
2CD4:  BCF    FF2.7
2CD6:  MOVLW  18
2CD8:  MOVWF  x7A
2CDA:  CALL   1C32
2CDE:  BTFSC  16.7
2CE0:  BSF    FF2.7
2CE2:  MOVLW  89
2CE4:  MOVWF  FE9
2CE6:  MOVFF  4C,5C
2CEA:  MOVFF  4B,5B
2CEE:  MOVFF  4A,5A
2CF2:  MOVFF  49,59
2CF6:  MOVLW  05
2CF8:  MOVWF  5D
2CFA:  RCALL  29D0
2CFC:  MOVLW  12
2CFE:  MOVWF  FF6
2D00:  MOVLW  22
2D02:  MOVWF  FF7
2D04:  CLRF   16
2D06:  BTFSC  FF2.7
2D08:  BSF    16.7
2D0A:  BCF    FF2.7
2D0C:  MOVLW  03
2D0E:  MOVWF  x7A
2D10:  CALL   1C32
2D14:  BTFSC  16.7
2D16:  BSF    FF2.7
....................  
....................  
....................    // Declare a variable to store the loop counter 
....................  
....................     enable_interrupts(GLOBAL); 
2D18:  MOVLW  C0
2D1A:  IORWF  FF2,F
....................     setup_timer_2(T2_DIV_BY_16, 255, 1); 
2D1C:  MOVLW  00
2D1E:  IORLW  06
2D20:  MOVWF  FCA
2D22:  MOVLW  FF
2D24:  MOVWF  FCB
....................     clear_interrupt(INT_TIMER2); 
2D26:  BCF    F9E.1
....................     enable_interrupts(INT_TIMER2); 
2D28:  BSF    F9D.1
....................     // Loop forever 
....................      while (1) 
....................      { 
....................          if(kbhit()){ 
2D2A:  BTFSS  F9E.5
2D2C:  BRA    2D34
....................             getc(); 
2D2E:  BTFSS  F9E.5
2D30:  BRA    2D2E
2D32:  MOVF   FAE,W
....................          } 
2D34:  BRA    2D2A
....................      } 
.................... } 
....................  
2D36:  SLEEP 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #import(file="build/default/production/mpu9250_program.o") 
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
0096:  CLRF   FF7
0098:  ADDLW  A6
009A:  MOVWF  FF6
009C:  MOVLW  00
009E:  ADDWFC FF7,F
00A0:  TBLRD*+
00A2:  MOVF   FF5,W
00A4:  RETURN 0
00A6:  DATA 7F,00
00A8:  DATA 00,00
00AA:  DATA 00,00
00AC:  DATA 00,00
00AE:  DATA 00,00
00B0:  DATA 00,00
00B2:  DATA 00,00
00B4:  DATA 00,00
00B6:  DATA 7F,00
00B8:  DATA 00,00
00BA:  DATA 00,00
00BC:  DATA 00,00
00BE:  DATA 00,00
00C0:  DATA 00,00
00C2:  DATA 00,00
00C4:  DATA 00,00
00C6:  DATA 7F,00
00C8:  DATA 00,00
*
0192:  MOVLW  8E
0194:  MOVWF  00
0196:  MOVFF  A3,01
019A:  MOVFF  A2,02
019E:  CLRF   03
01A0:  BTFSS  xA3.7
01A2:  BRA    01AE
01A4:  COMF   01,F
01A6:  COMF   02,F
01A8:  INCF   02,F
01AA:  BNZ   01AE
01AC:  INCF   01,F
01AE:  MOVF   01,F
01B0:  BNZ   01C4
01B2:  MOVFF  02,01
01B6:  CLRF   02
01B8:  MOVLW  08
01BA:  SUBWF  00,F
01BC:  MOVF   01,F
01BE:  BNZ   01C4
01C0:  CLRF   00
01C2:  BRA    01D8
01C4:  BCF    FD8.0
01C6:  BTFSC  01.7
01C8:  BRA    01D2
01CA:  RLCF   02,F
01CC:  RLCF   01,F
01CE:  DECF   00,F
01D0:  BRA    01C4
01D2:  BTFSC  xA3.7
01D4:  BRA    01D8
01D6:  BCF    01.7
01D8:  RETURN 0
*
0D18:  MOVFF  AC,B3
0D1C:  MOVF   xB0,W
0D1E:  XORWF  xB3,F
0D20:  BTFSS  xB3.7
0D22:  BRA    0D2E
0D24:  BCF    FD8.2
0D26:  BCF    FD8.0
0D28:  BTFSC  xAC.7
0D2A:  BSF    FD8.0
0D2C:  BRA    0D8C
0D2E:  MOVFF  AC,B3
0D32:  MOVFF  AF,B4
0D36:  MOVF   xAB,W
0D38:  SUBWF  xB4,F
0D3A:  BZ    0D48
0D3C:  BTFSS  xB3.7
0D3E:  BRA    0D8C
0D40:  MOVF   FD8,W
0D42:  XORLW  01
0D44:  MOVWF  FD8
0D46:  BRA    0D8C
0D48:  MOVFF  B0,B4
0D4C:  MOVF   xAC,W
0D4E:  SUBWF  xB4,F
0D50:  BZ    0D5E
0D52:  BTFSS  xB3.7
0D54:  BRA    0D8C
0D56:  MOVF   FD8,W
0D58:  XORLW  01
0D5A:  MOVWF  FD8
0D5C:  BRA    0D8C
0D5E:  MOVFF  B1,B4
0D62:  MOVF   xAD,W
0D64:  SUBWF  xB4,F
0D66:  BZ    0D74
0D68:  BTFSS  xB3.7
0D6A:  BRA    0D8C
0D6C:  MOVF   FD8,W
0D6E:  XORLW  01
0D70:  MOVWF  FD8
0D72:  BRA    0D8C
0D74:  MOVFF  B2,B4
0D78:  MOVF   xAE,W
0D7A:  SUBWF  xB4,F
0D7C:  BZ    0D8A
0D7E:  BTFSS  xB3.7
0D80:  BRA    0D8C
0D82:  MOVF   FD8,W
0D84:  XORLW  01
0D86:  MOVWF  FD8
0D88:  BRA    0D8C
0D8A:  BCF    FD8.0
0D8C:  RETURN 0
*
2216:  DATA 4D,50
2218:  DATA 55,39
221A:  DATA 32,35
221C:  DATA 30,20
221E:  DATA 69,73
2220:  DATA 20,6F
2222:  DATA 6E,6C
2224:  DATA 69,6E
2226:  DATA 65,2E
2228:  DATA 2E,2E
222A:  DATA 0A,0D
222C:  DATA 00,00
222E:  DATA 4D,50
2230:  DATA 55,39
2232:  DATA 32,35
2234:  DATA 30,20
2236:  DATA 69,73
2238:  DATA 20,6E
223A:  DATA 6F,74
223C:  DATA 20,6F
223E:  DATA 6E,6C
2240:  DATA 69,6E
2242:  DATA 65,2E
2244:  DATA 2E,2E
2246:  DATA 0A,0D
2248:  DATA 00,00
224A:  DATA 41,4B
224C:  DATA 38,39
224E:  DATA 36,33
2250:  DATA 20,69
2252:  DATA 73,20
2254:  DATA 6F,6E
2256:  DATA 6C,69
2258:  DATA 6E,65
225A:  DATA 2E,2E
225C:  DATA 2E,0A
225E:  DATA 0D,00
2260:  DATA 41,4B
2262:  DATA 38,39
2264:  DATA 36,33
2266:  DATA 20,69
2268:  DATA 73,20
226A:  DATA 6E,6F
226C:  DATA 74,20
226E:  DATA 6F,6E
2270:  DATA 6C,69
2272:  DATA 6E,65
2274:  DATA 2E,2E
2276:  DATA 2E,0A
2278:  DATA 0D,00
227A:  DATA 30,78
227C:  DATA 30,33
227E:  DATA 2D,3E
2280:  DATA 3E,20
2282:  DATA 43,4F
2284:  DATA 4E,46
2286:  DATA 49,47
2288:  DATA 3A,20
228A:  DATA 25,78
228C:  DATA 0A,0D
228E:  DATA 00,00
2290:  DATA 30,78
2292:  DATA 30,31
2294:  DATA 2D,3E
2296:  DATA 3E,20
2298:  DATA 50,57
229A:  DATA 52,5F
229C:  DATA 4D,47
229E:  DATA 4D,54
22A0:  DATA 5F,31
22A2:  DATA 3A,20
22A4:  DATA 25,78
22A6:  DATA 0A,0D
22A8:  DATA 00,00
22AA:  DATA 30,78
22AC:  DATA 30,30
22AE:  DATA 2D,3E
22B0:  DATA 3E,20
22B2:  DATA 50,57
22B4:  DATA 52,5F
22B6:  DATA 4D,47
22B8:  DATA 4D,54
22BA:  DATA 5F,32
22BC:  DATA 3A,20
22BE:  DATA 25,78
22C0:  DATA 0A,0D
22C2:  DATA 00,00
22C4:  DATA 30,78
22C6:  DATA 30,32
22C8:  DATA 2D,3E
22CA:  DATA 3E,20
22CC:  DATA 49,4E
22CE:  DATA 54,5F
22D0:  DATA 50,49
22D2:  DATA 4E,5F
22D4:  DATA 43,46
22D6:  DATA 47,3A
22D8:  DATA 20,25
22DA:  DATA 78,0A
22DC:  DATA 0D,00
22DE:  DATA 30,78
22E0:  DATA 30,37
22E2:  DATA 31,2D
22E4:  DATA 3E,3E
22E6:  DATA 20,57
22E8:  DATA 48,4F
22EA:  DATA 5F,41
22EC:  DATA 4D,5F
22EE:  DATA 49,5F
22F0:  DATA 4D,50
22F2:  DATA 55,39
22F4:  DATA 32,35
22F6:  DATA 30,3A
22F8:  DATA 20,25
22FA:  DATA 78,0A
22FC:  DATA 0D,00
22FE:  DATA 30,34
2300:  DATA 38,2D
2302:  DATA 3E,3E
2304:  DATA 20,20
2306:  DATA 57,48
2308:  DATA 4F,5F
230A:  DATA 41,4D
230C:  DATA 5F,49
230E:  DATA 5F,41
2310:  DATA 4B,38
2312:  DATA 39,36
2314:  DATA 33,3A
2316:  DATA 20,25
2318:  DATA 78,0A
231A:  DATA 0D,00
231C:  DATA 1B,5B
231E:  DATA 33,33
2320:  DATA 6D,47
2322:  DATA 79,72
2324:  DATA 6F,20
2326:  DATA 3A,20
2328:  DATA 58,20
232A:  DATA 3D,20
232C:  DATA 25,2E
232E:  DATA 35,66
2330:  DATA 2C,20
2332:  DATA 59,20
2334:  DATA 3D,20
2336:  DATA 25,2E
2338:  DATA 35,66
233A:  DATA 2C,20
233C:  DATA 5A,20
233E:  DATA 3D,20
2340:  DATA 25,2E
2342:  DATA 35,66
2344:  DATA 20,28
2346:  DATA 64,65
2348:  DATA 67,2F
234A:  DATA 73,29
234C:  DATA 20,20
234E:  DATA 20,09
2350:  DATA 1B,5B
2352:  DATA 30,6D
2354:  DATA 00,00
2356:  DATA 1B,5B
2358:  DATA 33,33
235A:  DATA 6D,4D
235C:  DATA 61,67
235E:  DATA 20,20
2360:  DATA 3A,20
2362:  DATA 58,20
2364:  DATA 3D,20
2366:  DATA 25,2E
2368:  DATA 35,66
236A:  DATA 2C,20
236C:  DATA 59,20
236E:  DATA 3D,20
2370:  DATA 25,2E
2372:  DATA 35,66
2374:  DATA 2C,20
2376:  DATA 5A,20
2378:  DATA 3D,20
237A:  DATA 25,2E
237C:  DATA 35,66
237E:  DATA 20,28
2380:  DATA 75,54
2382:  DATA 29,20
2384:  DATA 20,20
2386:  DATA 20,20
2388:  DATA 20,09
238A:  DATA 1B,5B
238C:  DATA 30,6D
238E:  DATA 00,00
2390:  DATA 1B,5B
2392:  DATA 33,33
2394:  DATA 6D,41
2396:  DATA 63,63
2398:  DATA 65,6C
239A:  DATA 3A,20
239C:  DATA 58,20
239E:  DATA 3D,20
23A0:  DATA 25,2E
23A2:  DATA 35,66
23A4:  DATA 2C,20
23A6:  DATA 59,20
23A8:  DATA 3D,20
23AA:  DATA 25,2E
23AC:  DATA 35,66
23AE:  DATA 2C,20
23B0:  DATA 5A,20
23B2:  DATA 3D,20
23B4:  DATA 25,2E
23B6:  DATA 35,66
23B8:  DATA 20,28
23BA:  DATA 67,29
23BC:  DATA 20,20
23BE:  DATA 20,20
23C0:  DATA 20,0A
23C2:  DATA 0D,1B
23C4:  DATA 5B,30
23C6:  DATA 6D,00
*
2558:  BTFSC  5B.7
255A:  BRA    257C
255C:  MOVLW  0F
255E:  MOVWF  00
2560:  SWAPF  5A,W
2562:  ANDWF  00,F
2564:  MOVLW  0A
2566:  SUBWF  00,W
2568:  BC    2570
256A:  MOVLW  30
256C:  ADDWF  00,F
256E:  BRA    2574
2570:  MOVF   5B,W
2572:  ADDWF  00,F
2574:  MOVF   00,W
2576:  BTFSS  F9E.4
2578:  BRA    2576
257A:  MOVWF  FAD
257C:  MOVLW  0F
257E:  ANDWF  5A,F
2580:  MOVLW  0A
2582:  SUBWF  5A,W
2584:  BC    258A
2586:  MOVLW  30
2588:  BRA    258E
258A:  BCF    5B.7
258C:  MOVF   5B,W
258E:  ADDWF  5A,F
2590:  MOVF   5A,W
2592:  BTFSS  F9E.4
2594:  BRA    2592
2596:  MOVWF  FAD
2598:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
.................... #include "mpu9250_config.h" 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_CONFIG_H 
.................... #define	MPU9250_CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include "configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_CONFIG_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // ±2 g 
.................... #define AFS_4G          0x08 // ±4 g 
.................... #define AFS_8G          0x10 // ±8 g 
.................... #define AFS_16G         0x18 // ±16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // ±250 dps 
.................... #define GFS_500         0x08 // ±500 dps 
.................... #define GFS_1000        0x10 // ±1000 dps 
.................... #define GFS_2000        0x18 // ±2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
.................... #include "mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef CONFIGURE_H 
.................... #define	CONFIGURE_H 
....................  
....................  
.................... #include <18F4550.h> 
....................  
.................... #include <stdint.h> 
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
....................  
....................  
....................  
....................  
.................... #fuses HS CPUDIV1 NOPBADEN//INTRC_IO 
.................... #use delay(clock = 8000000) 
.................... /* 
....................  * Important notice: See clock diagram page 26 of the data sheet, and set PLLx & CPUDIVx 
....................  * accodingly. Such that F_CPU = F_USB = . 
....................  */ 
....................  
....................  
.................... #use rs232(uart1, baud = 115200)                // Initialize UART module 
.................... #use i2c(MASTER, SDA=PIN_B0, SCL=PIN_B1,SMBUS,FAST = 400000,FORCE_HW)   // Setup I2C communication 
....................  
....................  
.................... typedef void (*CallbackPtr_t)(void*); 
....................  
.................... // ANSI escape codes for colors 
.................... #define ANSI_COLOR_RED     "\x1b[31m" 
.................... #define ANSI_COLOR_GREEN   "\x1b[32m" 
.................... #define ANSI_COLOR_YELLOW  "\x1b[33m" 
.................... #define ANSI_COLOR_BLUE    "\x1b[34m" 
.................... #define ANSI_COLOR_MAGENTA "\x1b[35m" 
.................... #define ANSI_COLOR_CYAN    "\x1b[36m" 
.................... #define ANSI_COLOR_RESET   "\x1b[0m" 
....................  
.................... #endif	/* CONFIGURE_H */ 
....................  
.................... #include "mpu9250_config.h" 
.................... /*  
....................  * File:   mpu9250_config.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:19 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_CONFIG_H 
.................... #define	MPU9250_CONFIG_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include "configure.h" 
....................  
....................  
....................  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_CONFIG_H */ 
....................  
....................  
.................... #include "mpu9250_private.h" 
.................... /*  
....................  * File:   mpu9250_private.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:18 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_PRIVATE_H 
.................... #define	MPU9250_PRIVATE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
.................... //Sensitivity= Full Scale Range/Digital Range 
.................... #define WHO_AM_I_MPU9250    0x75 
.................... #define WHO_AM_I_AK8963     0x00 
.................... #define MPU9250_ADDRESS_ID 0x71 
.................... #define AK8963_ADDRESS_ID  0x48 
....................  
.................... // Sensitivity for GYROSCOPE 
.................... #define GYRO_SCALE_250      131.0 
.................... #define GYRO_SCALE_500      65.5 
.................... #define GYRO_SCALE_1000     32.8 
.................... #define GYRO_SCALE_2000     16.4 
.................... #define GYRO_SCALE          GYRO_SCALE_500 
....................  
.................... // Sensitivity for ACCELEROMETER 
.................... #define ACCEL_SCALE_2G      16384.0 
.................... #define ACCEL_SCALE_4G      8192.0 
.................... #define ACCEL_SCALE_8G      4096.0 
.................... #define ACCEL_SCALE_16G     2048.0 
.................... #define ACCEL_SCALE         ACCEL_SCALE_8G 
....................  
....................  
....................     // Resolution for MAGNETOMETER 
.................... #define AK8963_CNTL1_RESOLUTION_14BIT   0x00 
.................... #define AK8963_CNTL1_RESOLUTION_16BIT   0x10 
.................... #define AK8963_CNTL1_RESOLUTION         AK8963_CNTL1_RESOLUTION_16BIT 
.................... // MPU9250 I2C address pin is connected to GND 
.................... #define MPU9250_ADDRESS 0x68 
....................  
....................  
.................... // Define the registers for configuration and power management 
.................... #define CONFIG          0x1A 
.................... #define PWR_MGMT_1      0x6B 
.................... #define PWR_MGMT_2      0x6C 
....................  
.................... // Define the values for configuration and power management 
.................... #define CONFIG_VALUE     0x03 // set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
.................... #define PWR_MGMT_1_VALUE 0x01 // set the clock source to PLL with X axis gyroscope reference 
.................... #define PWR_MGMT_2_VALUE 0x00 // enable all sensors 
....................  
.................... // The register address of the interrupt pin configuration 
.................... #define INT_PIN_CFG         0x37 
.................... // The value to enable the bypass mode of the MPU9250 
.................... #define INT_PIN_CFG_VALUE2    0x30 // enable the I2C bypass mode of the MPU-9250 
.................... #define INT_PIN_CFG_VALUE1    0x02 // enable the interrupt active high 
....................  
.................... #define AK8963_ADDRESS      0x0C    // The address of the AK8963 device on the I2C bus 
.................... #define AK8963_ST1_REG      0x02    // Define the registers for magnetometer data 
.................... #define AK8963_ST2_REG      0x09    // Define the registers for magnetometer data 
....................  
.................... #define AK8963_CNTL1_Reg    0x0A    // Control 1 register of AK8963 
.................... #define AK8963_CNTL2_Reg    0x0B    // Control 2 register of AK8963 
....................  
....................  
.................... // Define the MPU9250 address and the register addresses 
.................... #define ACCEL_CONFIG 0x1C  // Accelerometer configuration   used to set the accelerometer range 
.................... #define GYRO_CONFIG  0x1B // Gyroscope configuration        used to set the gyro range 
....................  
....................  
....................  
....................     // Define the Resolution of the magnetometer 
.................... #define MFS_14BITS   0 // 0.6 mG per LSB 
.................... #define MFS_16BITS   1 // 0.15 mG per LSB 
....................  
....................  
....................  
.................... // Define the values for the accelerometer and gyro configuration 
.................... #define AFS_2G          0x00 // ±2 g 
.................... #define AFS_4G          0x08 // ±4 g 
.................... #define AFS_8G          0x10 // ±8 g 
.................... #define AFS_16G         0x18 // ±16 g 
....................  
.................... // Define the values for the gyro configuration 
.................... #define GFS_250         0x00 // ±250 dps 
.................... #define GFS_500         0x08 // ±500 dps 
.................... #define GFS_1000        0x10 // ±1000 dps 
.................... #define GFS_2000        0x18 // ±2000 dps 
....................  
.................... // Define the registers for gyroscope data 
.................... #define GYRO_XOUT_H     0x43 
.................... #define GYRO_XOUT_L     0x44 
.................... #define GYRO_YOUT_H     0x45 
.................... #define GYRO_YOUT_L     0x46 
.................... #define GYRO_ZOUT_H     0x47 
.................... #define GYRO_ZOUT_L     0x48 
....................  
.................... // Define the registers for magnometer data 
.................... #define MAG_XOUT_L      0x03 
.................... #define MAG_XOUT_H      0x04 
.................... #define MAG_YOUT_L      0x05 
.................... #define MAG_YOUT_H      0x06 
.................... #define MAG_ZOUT_L      0x07 
.................... #define MAG_ZOUT_H      0x08 
....................  
.................... // Define the registers for accelerometer data 
.................... #define ACCEL_XOUT_H    0x3B 
.................... #define ACCEL_XOUT_L    0x3C 
.................... #define ACCEL_YOUT_H    0x3D 
.................... #define ACCEL_YOUT_L    0x3E 
.................... #define ACCEL_ZOUT_H    0x3F 
.................... #define ACCEL_ZOUT_L    0x40 
....................  
.................... #define MPU9250_SMPLRT_DIV 0x19 
....................  
....................  
.................... #define MPU9250_USER_CTRL       0x6A 
.................... #define MPU9250_I2C_MST_CTRL    0x24 
.................... #define MPU9250_I2C_SLV0_CTRL   0x27 
....................  
.................... #define USER_CTRL_I2C_MST_EN    0x20  // Bit 5 to enable the I2C master mode 
.................... #define I2C_MST_CLK_400kHz      0x0D  // which enables the I2C master mode and sets the I2C speed to 400 kHz. TThis allows the sensor to control the magnetometer as a slave device 
.................... #define I2C_MST_DELAY_CTRL      0x67  // This register allows the user to delay the data ready interrupt signal, which is useful when using the magnetometer data as a clock reference for the gyroscope and accelerometer data 
.................... #define AK8963_MAG_MODE_FUSEROM 0x0F // Bits 3:0 for 400kHz I2C master clock speed 
....................  
.................... // Define the registers for magnetometer sensitivity adjustment 
.................... #define AK8963_ASAX             0x10 // X-axis sensitivity adjustment value 
.................... #define AK8963_ASAY             0x11 // Y-axis sensitivity adjustment value 
.................... #define AK8963_ASAZ             0x12 // Z-axis sensitivity adjustment value 
....................  
.................... #define  AK8963_MAG_OUTPUT_16BIT            0x16 
.................... #define  AK8963_MAG_OUTPUT_14BIT            0x12 
.................... #define AK8963_MAG_MODE_CONTINUOUS_100HZ    0x06 
....................  
....................     // Define the sensitivity adjustment values for the magnetometer 
.................... #define  AK8963_MAG_SCALE_14BIT             4912.0f/8190.0f  // 4912 uT for 14-bit resolution 
.................... #define  AK8963_MAG_SCALE_16BIT             4912.0f/32760.0f // 4912 uT for 16-bit resolution 
.................... #define  MAG_SCALE                          AK8963_MAG_SCALE_16BIT 
....................  
.................... // Accelerometer offsets values for calibration 
.................... #define ACCEL_X_OFFSET 0.005 
.................... #define ACCEL_Y_OFFSET 0.0144 
.................... #define ACCEL_Z_OFFSET 0.06006 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_PRIVATE_H */ 
....................  
....................  
.................... #include "mpu9250_interface.h" 
.................... /*  
....................  * File:   mpu9250_interface.h 
....................  * Author: Mahmoud 
....................  * 
....................  * Created on November 22, 2023, 3:17 PM 
....................  */ 
....................  
.................... #ifndef MPU9250_INTERFACE_H 
.................... #define	MPU9250_INTERFACE_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
.................... #include"configure.h" 
.................... #include "mpu9250_config.h" 
.................... #include "mpu9250_private.h" 
.................... #include "mpu9250_interface.h" 
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]); 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[],float magData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
....................  
....................     //define array of 3 elements to store the gyro values 
....................     extern float gyro[3]; 
....................     //define array of 3 elements to store the mag values 
....................     extern  float mag[3]; 
....................     //define array of 3 elements to store the accel values 
....................     extern float accel[3]; 
....................  
....................     struct PitchRollYaw_t { 
....................         float pitch; 
....................         float roll; 
....................         float yaw; 
....................     } ; 
.................... typedef struct PitchRollYaw_t RateCalibration_t ; 
.................... typedef struct PitchRollYaw_t Angle_t ; 
....................  
....................  
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) ; 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) ; 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) ; 
.................... void read_gyro_word (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_accel_word(uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void read_mag_word  (uint8_t registerHigh,uint8_t registerLow, int16_t *data) ; 
.................... void mpu9250_mag_init() ; 
.................... void mpu9250_init() ; 
.................... void mpu9250_print_initRegisters(void) ; 
.................... void mpu9250_read_gyro(float gyroData[]) ; 
.................... void mpu9250_read_magnometer(float magData[]); 
.................... void mpu9250_read_accelerometer(float accelData[]) ; 
....................  
.................... void mpu9250_gyro_calibration(  RateCalibration_t *RateCalibration ) ; 
....................  
.................... void mpu9250_print_module_values(void) ; 
....................  
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[],float magData[]); 
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]); 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MPU9250_INTERFACE_H */ 
....................  
....................  
.................... //#include "../MyMath.h" 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
0D8E:  MOVFF  9D,AE
0D92:  MOVFF  9C,AD
0D96:  MOVFF  9B,AC
0D9A:  MOVFF  9A,AB
0D9E:  CLRF   xB2
0DA0:  CLRF   xB1
0DA2:  CLRF   xB0
0DA4:  CLRF   xAF
0DA6:  RCALL  0D18
0DA8:  BC    0DAC
0DAA:  BNZ   0DB6
....................       return(0.0); 
0DAC:  CLRF   00
0DAE:  CLRF   01
0DB0:  CLRF   02
0DB2:  CLRF   03
0DB4:  BRA    0E9A
....................  
....................    y=x; 
0DB6:  MOVFF  9D,A1
0DBA:  MOVFF  9C,A0
0DBE:  MOVFF  9B,9F
0DC2:  MOVFF  9A,9E
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
0DC6:  CLRF   xA7
0DC8:  MOVLW  9E
0DCA:  MOVWF  xA6
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
0DCC:  MOVFF  A6,FE9
0DD0:  MOVFF  A7,FEA
0DD4:  MOVF   FEF,W
0DD6:  CLRF   xAB
0DD8:  MOVWF  xAA
0DDA:  MOVLW  7F
0DDC:  ADDWF  xAA,F
0DDE:  MOVLW  00
0DE0:  ADDWFC xAB,F
0DE2:  BCF    FD8.0
0DE4:  RRCF   xAB,W
0DE6:  RRCF   xAA,W
0DE8:  MOVFF  A7,FEA
0DEC:  MOVFF  A6,FE9
0DF0:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
0DF2:  MOVFF  A1,A5
0DF6:  MOVFF  A0,A4
0DFA:  MOVFF  9F,A3
0DFE:  MOVFF  9E,A2
....................       y+=(x/y); 
0E02:  MOVFF  9D,B2
0E06:  MOVFF  9C,B1
0E0A:  MOVFF  9B,B0
0E0E:  MOVFF  9A,AF
0E12:  MOVFF  A1,B6
0E16:  MOVFF  A0,B5
0E1A:  MOVFF  9F,B4
0E1E:  MOVFF  9E,B3
0E22:  CALL   01DA
0E26:  BCF    FD8.1
0E28:  MOVFF  A1,B2
0E2C:  MOVFF  A0,B1
0E30:  MOVFF  9F,B0
0E34:  MOVFF  9E,AF
0E38:  MOVFF  03,B6
0E3C:  MOVFF  02,B5
0E40:  MOVFF  01,B4
0E44:  MOVFF  00,B3
0E48:  CALL   044A
0E4C:  MOVFF  03,A1
0E50:  MOVFF  02,A0
0E54:  MOVFF  01,9F
0E58:  MOVFF  00,9E
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
0E5C:  MOVFF  A6,FE9
0E60:  MOVFF  A7,FEA
0E64:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
0E66:  MOVFF  A5,AE
0E6A:  MOVFF  A4,AD
0E6E:  MOVFF  A3,AC
0E72:  MOVFF  A2,AB
0E76:  MOVFF  A1,B2
0E7A:  MOVFF  A0,B1
0E7E:  MOVFF  9F,B0
0E82:  MOVFF  9E,AF
0E86:  RCALL  0D18
0E88:  BNZ   0DF2
....................  
....................    return(res); 
0E8A:  MOVFF  A2,00
0E8E:  MOVFF  A3,01
0E92:  MOVFF  A4,02
0E96:  MOVFF  A5,03
0E9A:  RETURN 0
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
0E9C:  BCF    xAA.0
....................    flag = 0; 
0E9E:  BCF    xAA.1
....................    y = x; 
0EA0:  MOVFF  9D,A1
0EA4:  MOVFF  9C,A0
0EA8:  MOVFF  9B,9F
0EAC:  MOVFF  9A,9E
....................  
....................    if (x < 0) 
0EB0:  MOVFF  9D,AE
0EB4:  MOVFF  9C,AD
0EB8:  MOVFF  9B,AC
0EBC:  MOVFF  9A,AB
0EC0:  CLRF   xB2
0EC2:  CLRF   xB1
0EC4:  CLRF   xB0
0EC6:  CLRF   xAF
0EC8:  RCALL  0D18
0ECA:  BNC   0ED4
....................    { 
....................       s = 1; 
0ECC:  BSF    xAA.0
....................       y = -y; 
0ECE:  MOVF   x9F,W
0ED0:  XORLW  80
0ED2:  MOVWF  x9F
....................    } 
....................  
....................    if (y > 1.0) 
0ED4:  CLRF   xAE
0ED6:  CLRF   xAD
0ED8:  CLRF   xAC
0EDA:  MOVLW  7F
0EDC:  MOVWF  xAB
0EDE:  MOVFF  A1,B2
0EE2:  MOVFF  A0,B1
0EE6:  MOVFF  9F,B0
0EEA:  MOVFF  9E,AF
0EEE:  RCALL  0D18
0EF0:  BNC   0F22
....................    { 
....................       y = 1.0/y; 
0EF2:  CLRF   xB2
0EF4:  CLRF   xB1
0EF6:  CLRF   xB0
0EF8:  MOVLW  7F
0EFA:  MOVWF  xAF
0EFC:  MOVFF  A1,B6
0F00:  MOVFF  A0,B5
0F04:  MOVFF  9F,B4
0F08:  MOVFF  9E,B3
0F0C:  CALL   01DA
0F10:  MOVFF  03,A1
0F14:  MOVFF  02,A0
0F18:  MOVFF  01,9F
0F1C:  MOVFF  00,9E
....................       flag = 1; 
0F20:  BSF    xAA.1
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
0F22:  MOVLW  0A
0F24:  MOVWF  xB2
0F26:  MOVLW  89
0F28:  MOVWF  xB1
0F2A:  MOVLW  34
0F2C:  MOVWF  xB0
0F2E:  MOVLW  7C
0F30:  MOVWF  xAF
0F32:  MOVFF  A1,B6
0F36:  MOVFF  A0,B5
0F3A:  MOVFF  9F,B4
0F3E:  MOVFF  9E,B3
0F42:  RCALL  08C8
0F44:  MOVFF  03,AE
0F48:  MOVFF  02,AD
0F4C:  MOVFF  01,AC
0F50:  MOVFF  00,AB
0F54:  MOVFF  03,B2
0F58:  MOVFF  02,B1
0F5C:  MOVFF  01,B0
0F60:  MOVFF  00,AF
0F64:  MOVFF  A1,B6
0F68:  MOVFF  A0,B5
0F6C:  MOVFF  9F,B4
0F70:  MOVFF  9E,B3
0F74:  RCALL  08C8
0F76:  MOVFF  03,AE
0F7A:  MOVFF  02,AD
0F7E:  MOVFF  01,AC
0F82:  MOVFF  00,AB
0F86:  BCF    FD8.1
0F88:  MOVFF  03,B2
0F8C:  MOVFF  02,B1
0F90:  MOVFF  01,B0
0F94:  MOVFF  00,AF
0F98:  MOVLW  7C
0F9A:  MOVWF  xB6
0F9C:  MOVLW  79
0F9E:  MOVWF  xB5
0FA0:  MOVLW  35
0FA2:  MOVWF  xB4
0FA4:  MOVLW  81
0FA6:  MOVWF  xB3
0FA8:  CALL   044A
0FAC:  MOVFF  03,A5
0FB0:  MOVFF  02,A4
0FB4:  MOVFF  01,A3
0FB8:  MOVFF  00,A2
....................    res = res*y*y + pat[2]; 
0FBC:  MOVFF  A5,B2
0FC0:  MOVFF  A4,B1
0FC4:  MOVFF  A3,B0
0FC8:  MOVFF  A2,AF
0FCC:  MOVFF  A1,B6
0FD0:  MOVFF  A0,B5
0FD4:  MOVFF  9F,B4
0FD8:  MOVFF  9E,B3
0FDC:  RCALL  08C8
0FDE:  MOVFF  03,AE
0FE2:  MOVFF  02,AD
0FE6:  MOVFF  01,AC
0FEA:  MOVFF  00,AB
0FEE:  MOVFF  03,B2
0FF2:  MOVFF  02,B1
0FF6:  MOVFF  01,B0
0FFA:  MOVFF  00,AF
0FFE:  MOVFF  A1,B6
1002:  MOVFF  A0,B5
1006:  MOVFF  9F,B4
100A:  MOVFF  9E,B3
100E:  RCALL  08C8
1010:  MOVFF  03,AE
1014:  MOVFF  02,AD
1018:  MOVFF  01,AC
101C:  MOVFF  00,AB
1020:  BCF    FD8.1
1022:  MOVFF  03,B2
1026:  MOVFF  02,B1
102A:  MOVFF  01,B0
102E:  MOVFF  00,AF
1032:  MOVLW  3F
1034:  MOVWF  xB6
1036:  MOVLW  02
1038:  MOVWF  xB5
103A:  MOVLW  33
103C:  MOVWF  xB4
103E:  MOVLW  83
1040:  MOVWF  xB3
1042:  CALL   044A
1046:  MOVFF  03,A5
104A:  MOVFF  02,A4
104E:  MOVFF  01,A3
1052:  MOVFF  00,A2
....................    res = res*y*y + pat[3]; 
1056:  MOVFF  A5,B2
105A:  MOVFF  A4,B1
105E:  MOVFF  A3,B0
1062:  MOVFF  A2,AF
1066:  MOVFF  A1,B6
106A:  MOVFF  A0,B5
106E:  MOVFF  9F,B4
1072:  MOVFF  9E,B3
1076:  RCALL  08C8
1078:  MOVFF  03,AE
107C:  MOVFF  02,AD
1080:  MOVFF  01,AC
1084:  MOVFF  00,AB
1088:  MOVFF  03,B2
108C:  MOVFF  02,B1
1090:  MOVFF  01,B0
1094:  MOVFF  00,AF
1098:  MOVFF  A1,B6
109C:  MOVFF  A0,B5
10A0:  MOVFF  9F,B4
10A4:  MOVFF  9E,B3
10A8:  RCALL  08C8
10AA:  MOVFF  03,AE
10AE:  MOVFF  02,AD
10B2:  MOVFF  01,AC
10B6:  MOVFF  00,AB
10BA:  BCF    FD8.1
10BC:  MOVFF  03,B2
10C0:  MOVFF  02,B1
10C4:  MOVFF  01,B0
10C8:  MOVFF  00,AF
10CC:  MOVLW  33
10CE:  MOVWF  xB6
10D0:  MOVLW  8C
10D2:  MOVWF  xB5
10D4:  MOVLW  1E
10D6:  MOVWF  xB4
10D8:  MOVLW  83
10DA:  MOVWF  xB3
10DC:  CALL   044A
10E0:  MOVFF  03,A5
10E4:  MOVFF  02,A4
10E8:  MOVFF  01,A3
10EC:  MOVFF  00,A2
....................  
....................    r = qat[0]*y*y + qat[1]; 
10F0:  CLRF   xB2
10F2:  CLRF   xB1
10F4:  CLRF   xB0
10F6:  MOVLW  7F
10F8:  MOVWF  xAF
10FA:  MOVFF  A1,B6
10FE:  MOVFF  A0,B5
1102:  MOVFF  9F,B4
1106:  MOVFF  9E,B3
110A:  CALL   08C8
110E:  MOVFF  03,AE
1112:  MOVFF  02,AD
1116:  MOVFF  01,AC
111A:  MOVFF  00,AB
111E:  MOVFF  03,B2
1122:  MOVFF  02,B1
1126:  MOVFF  01,B0
112A:  MOVFF  00,AF
112E:  MOVFF  A1,B6
1132:  MOVFF  A0,B5
1136:  MOVFF  9F,B4
113A:  MOVFF  9E,B3
113E:  CALL   08C8
1142:  MOVFF  03,AE
1146:  MOVFF  02,AD
114A:  MOVFF  01,AC
114E:  MOVFF  00,AB
1152:  BCF    FD8.1
1154:  MOVFF  03,B2
1158:  MOVFF  02,B1
115C:  MOVFF  01,B0
1160:  MOVFF  00,AF
1164:  MOVLW  1B
1166:  MOVWF  xB6
1168:  MOVLW  E4
116A:  MOVWF  xB5
116C:  MOVLW  35
116E:  MOVWF  xB4
1170:  MOVLW  82
1172:  MOVWF  xB3
1174:  CALL   044A
1178:  MOVFF  03,A9
117C:  MOVFF  02,A8
1180:  MOVFF  01,A7
1184:  MOVFF  00,A6
....................    r = r*y*y + qat[2]; 
1188:  MOVFF  A9,B2
118C:  MOVFF  A8,B1
1190:  MOVFF  A7,B0
1194:  MOVFF  A6,AF
1198:  MOVFF  A1,B6
119C:  MOVFF  A0,B5
11A0:  MOVFF  9F,B4
11A4:  MOVFF  9E,B3
11A8:  CALL   08C8
11AC:  MOVFF  03,AE
11B0:  MOVFF  02,AD
11B4:  MOVFF  01,AC
11B8:  MOVFF  00,AB
11BC:  MOVFF  03,B2
11C0:  MOVFF  02,B1
11C4:  MOVFF  01,B0
11C8:  MOVFF  00,AF
11CC:  MOVFF  A1,B6
11D0:  MOVFF  A0,B5
11D4:  MOVFF  9F,B4
11D8:  MOVFF  9E,B3
11DC:  CALL   08C8
11E0:  MOVFF  03,AE
11E4:  MOVFF  02,AD
11E8:  MOVFF  01,AC
11EC:  MOVFF  00,AB
11F0:  BCF    FD8.1
11F2:  MOVFF  03,B2
11F6:  MOVFF  02,B1
11FA:  MOVFF  01,B0
11FE:  MOVFF  00,AF
1202:  MOVLW  A4
1204:  MOVWF  xB6
1206:  MOVLW  DB
1208:  MOVWF  xB5
120A:  MOVLW  67
120C:  MOVWF  xB4
120E:  MOVLW  83
1210:  MOVWF  xB3
1212:  CALL   044A
1216:  MOVFF  03,A9
121A:  MOVFF  02,A8
121E:  MOVFF  01,A7
1222:  MOVFF  00,A6
....................    r = r*y*y + qat[3]; 
1226:  MOVFF  A9,B2
122A:  MOVFF  A8,B1
122E:  MOVFF  A7,B0
1232:  MOVFF  A6,AF
1236:  MOVFF  A1,B6
123A:  MOVFF  A0,B5
123E:  MOVFF  9F,B4
1242:  MOVFF  9E,B3
1246:  CALL   08C8
124A:  MOVFF  03,AE
124E:  MOVFF  02,AD
1252:  MOVFF  01,AC
1256:  MOVFF  00,AB
125A:  MOVFF  03,B2
125E:  MOVFF  02,B1
1262:  MOVFF  01,B0
1266:  MOVFF  00,AF
126A:  MOVFF  A1,B6
126E:  MOVFF  A0,B5
1272:  MOVFF  9F,B4
1276:  MOVFF  9E,B3
127A:  CALL   08C8
127E:  MOVFF  03,AE
1282:  MOVFF  02,AD
1286:  MOVFF  01,AC
128A:  MOVFF  00,AB
128E:  BCF    FD8.1
1290:  MOVFF  03,B2
1294:  MOVFF  02,B1
1298:  MOVFF  01,B0
129C:  MOVFF  00,AF
12A0:  MOVLW  33
12A2:  MOVWF  xB6
12A4:  MOVLW  8C
12A6:  MOVWF  xB5
12A8:  MOVLW  1E
12AA:  MOVWF  xB4
12AC:  MOVLW  83
12AE:  MOVWF  xB3
12B0:  CALL   044A
12B4:  MOVFF  03,A9
12B8:  MOVFF  02,A8
12BC:  MOVFF  01,A7
12C0:  MOVFF  00,A6
....................  
....................    res = y*res/r; 
12C4:  MOVFF  A1,B2
12C8:  MOVFF  A0,B1
12CC:  MOVFF  9F,B0
12D0:  MOVFF  9E,AF
12D4:  MOVFF  A5,B6
12D8:  MOVFF  A4,B5
12DC:  MOVFF  A3,B4
12E0:  MOVFF  A2,B3
12E4:  CALL   08C8
12E8:  MOVFF  03,AE
12EC:  MOVFF  02,AD
12F0:  MOVFF  01,AC
12F4:  MOVFF  00,AB
12F8:  MOVFF  03,B2
12FC:  MOVFF  02,B1
1300:  MOVFF  01,B0
1304:  MOVFF  00,AF
1308:  MOVFF  A9,B6
130C:  MOVFF  A8,B5
1310:  MOVFF  A7,B4
1314:  MOVFF  A6,B3
1318:  CALL   01DA
131C:  MOVFF  03,A5
1320:  MOVFF  02,A4
1324:  MOVFF  01,A3
1328:  MOVFF  00,A2
....................  
....................  
....................    if (flag)                              // for |x| > 1 
132C:  BTFSS  xAA.1
132E:  BRA    1366
....................       res = PI_DIV_BY_TWO - res; 
1330:  BSF    FD8.1
1332:  MOVLW  DB
1334:  MOVWF  xB2
1336:  MOVLW  0F
1338:  MOVWF  xB1
133A:  MOVLW  49
133C:  MOVWF  xB0
133E:  MOVLW  7F
1340:  MOVWF  xAF
1342:  MOVFF  A5,B6
1346:  MOVFF  A4,B5
134A:  MOVFF  A3,B4
134E:  MOVFF  A2,B3
1352:  CALL   044A
1356:  MOVFF  03,A5
135A:  MOVFF  02,A4
135E:  MOVFF  01,A3
1362:  MOVFF  00,A2
....................    if (s) 
1366:  BTFSS  xAA.0
1368:  BRA    1370
....................       res = -res; 
136A:  MOVF   xA3,W
136C:  XORLW  80
136E:  MOVWF  xA3
....................  
....................    return(res); 
1370:  MOVFF  A2,00
1374:  MOVFF  A3,01
1378:  MOVFF  A4,02
137C:  MOVFF  A5,03
1380:  RETURN 0
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... const float hard_iron[3] = {292.70500000000004,371.765,-263.95000000000005}; 
.................... const float soft_iron[3][3] =  
.................... {{1,0,0}, 
....................  {0,1,0}, 
....................  {0,0,1}}; 
....................  
.................... // Function to write a byte to a specific register of a device 
.................... void mpu9250_writeByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t data) { 
....................     i2c_start(); 
*
2410:  BSF    FC5.0
2412:  BTFSC  FC5.0
2414:  BRA    2412
....................     i2c_write(deviceAddress << 1); 
2416:  BCF    FD8.0
2418:  RLCF   5A,W
241A:  MOVWF  5E
241C:  CLRF   16
241E:  BTFSC  FF2.7
2420:  BSF    16.7
2422:  BCF    FF2.7
2424:  MOVWF  xAB
2426:  CALL   00CA
242A:  BTFSC  16.7
242C:  BSF    FF2.7
242E:  CLRF   16
2430:  BTFSC  FF2.7
2432:  BSF    16.7
2434:  BCF    FF2.7
....................     i2c_write(registerAddress); 
2436:  MOVFF  5B,AB
243A:  CALL   00CA
243E:  BTFSC  16.7
2440:  BSF    FF2.7
2442:  CLRF   16
2444:  BTFSC  FF2.7
2446:  BSF    16.7
2448:  BCF    FF2.7
....................     i2c_write(data); 
244A:  MOVFF  5C,AB
244E:  CALL   00CA
2452:  BTFSC  16.7
2454:  BSF    FF2.7
....................     i2c_stop(); 
2456:  BSF    FC5.2
2458:  BTFSC  FC5.2
245A:  BRA    2458
245C:  RETURN 0
.................... } 
....................  
.................... // Function to read a byte from a specific register of a device 
.................... void mpu9250_readByte(uint8_t deviceAddress, uint8_t registerAddress, uint8_t *data) { 
....................     i2c_start(); 
*
0102:  BSF    FC5.0
0104:  BTFSC  FC5.0
0106:  BRA    0104
....................     i2c_write(deviceAddress << 1); 
0108:  BCF    FD8.0
010A:  RLCF   xA5,W
010C:  MOVWF  xAA
010E:  MOVWF  xAB
0110:  RCALL  00CA
....................     i2c_write(registerAddress); 
0112:  MOVFF  A6,AB
0116:  RCALL  00CA
....................     i2c_start(); 
0118:  BSF    FC5.1
011A:  BTFSC  FC5.1
011C:  BRA    011A
....................     i2c_write(deviceAddress << 1 | 0x01); 
011E:  BCF    FD8.0
0120:  RLCF   xA5,W
0122:  IORLW  01
0124:  MOVWF  xAA
0126:  MOVWF  xAB
0128:  RCALL  00CA
....................     *data = i2c_read(0); 
012A:  MOVFF  A8,03
012E:  MOVFF  A7,FE9
0132:  MOVFF  A8,FEA
0136:  CLRF   00
0138:  RCALL  00E6
013A:  MOVFF  01,FEF
....................     i2c_stop(); 
013E:  BSF    FC5.2
0140:  BTFSC  FC5.2
0142:  BRA    0140
0144:  RETURN 0
.................... } 
....................  
.................... // Function to read a 16-bit value from two consecutive registers of a device 
.................... void read_word(uint8_t deviceAddress, uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
....................     uint8_t highByte, lowByte; 
....................     mpu9250_readByte(deviceAddress, registerLow, &lowByte); 
0146:  MOVFF  9E,A5
014A:  MOVFF  A0,A6
014E:  CLRF   xA8
0150:  MOVLW  A4
0152:  MOVWF  xA7
0154:  RCALL  0102
....................     mpu9250_readByte(deviceAddress, registerHigh, &highByte); 
0156:  MOVFF  9E,A5
015A:  MOVFF  9F,A6
015E:  CLRF   xA8
0160:  MOVLW  A3
0162:  MOVWF  xA7
0164:  RCALL  0102
....................  
....................         *data = make16(highByte,lowByte); 
0166:  MOVFF  A1,FE9
016A:  MOVFF  A2,FEA
016E:  MOVFF  A3,FEC
0172:  MOVF   FED,F
0174:  MOVFF  A4,FEF
0178:  RETURN 0
....................  
.................... } 
....................  
.................... // Function to read a 16-bit value from two consecutive gyro registers 
.................... void read_gyro_word(uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
....................     read_word(MPU9250_ADDRESS, registerHigh, registerLow, data); 
017A:  MOVLW  68
017C:  MOVWF  x9E
017E:  MOVFF  7F,9F
0182:  MOVFF  80,A0
0186:  MOVFF  82,A2
018A:  MOVFF  81,A1
018E:  RCALL  0146
0190:  RETURN 0
.................... } 
.................... // Function to read a 16-bit value from two consecutive accelerometer registers 
.................... void read_accel_word(uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
....................     read_word(MPU9250_ADDRESS, registerHigh, registerLow, data); 
*
0432:  MOVLW  68
0434:  MOVWF  x9E
0436:  MOVFF  96,9F
043A:  MOVFF  97,A0
043E:  MOVFF  99,A2
0442:  MOVFF  98,A1
0446:  RCALL  0146
0448:  RETURN 0
.................... } 
.................... // Function to read a 16-bit value from two consecutive magnetometer registers 
.................... void read_mag_word(uint8_t registerHigh, uint8_t registerLow, int16_t *data) { 
....................     read_word(AK8963_ADDRESS, registerHigh, registerLow, data); 
*
087A:  MOVLW  0C
087C:  MOVWF  x9E
087E:  MOVFF  9A,9F
0882:  MOVFF  9B,A0
0886:  MOVFF  9D,A2
088A:  MOVFF  9C,A1
088E:  RCALL  0146
0890:  RETURN 0
.................... } 
....................  
.................... // Function to initialize MPU9250 
.................... void mpu9250_init() { 
....................  
....................     mpu9250_writeByte(MPU9250_ADDRESS, CONFIG, CONFIG_VALUE);                    // Set the digital low pass filter to 41 Hz for gyro and 44 Hz for accel 
*
245E:  MOVLW  68
2460:  MOVWF  5A
2462:  MOVLW  1A
2464:  MOVWF  5B
2466:  MOVLW  03
2468:  MOVWF  5C
246A:  RCALL  2410
....................     mpu9250_writeByte(MPU9250_ADDRESS, PWR_MGMT_1, PWR_MGMT_1_VALUE);            // Set the clock source to PLL with X axis gyroscope reference and disable sleep mode 
246C:  MOVLW  68
246E:  MOVWF  5A
2470:  MOVLW  6B
2472:  MOVWF  5B
2474:  MOVLW  01
2476:  MOVWF  5C
2478:  RCALL  2410
....................     mpu9250_writeByte(MPU9250_ADDRESS, PWR_MGMT_2, PWR_MGMT_2_VALUE);            // Enable all sensors and disable standby mode for accel and gyro only 
247A:  MOVLW  68
247C:  MOVWF  5A
247E:  MOVLW  6C
2480:  MOVWF  5B
2482:  CLRF   5C
2484:  RCALL  2410
....................     mpu9250_writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, AFS_8G);                    // Set the accelerometer range to ±8 g 
2486:  MOVLW  68
2488:  MOVWF  5A
248A:  MOVLW  1C
248C:  MOVWF  5B
248E:  MOVLW  10
2490:  MOVWF  5C
2492:  RCALL  2410
....................     mpu9250_writeByte(MPU9250_ADDRESS, GYRO_CONFIG, GFS_500);                    // Set the gyro range to ±500 dps 
2494:  MOVLW  68
2496:  MOVWF  5A
2498:  MOVLW  1B
249A:  MOVWF  5B
249C:  MOVLW  08
249E:  MOVWF  5C
24A0:  RCALL  2410
....................  
....................  
....................     mpu9250_writeByte(MPU9250_ADDRESS, INT_PIN_CFG, INT_PIN_CFG_VALUE1);         // Enable the I2C bypass mode of the MPU-9250 
24A2:  MOVLW  68
24A4:  MOVWF  5A
24A6:  MOVLW  37
24A8:  MOVWF  5B
24AA:  MOVLW  02
24AC:  MOVWF  5C
24AE:  RCALL  2410
....................     mpu9250_writeByte(MPU9250_ADDRESS,MPU9250_I2C_MST_CTRL, I2C_MST_CLK_400kHz); // Set bits 3:0 to 1101 for 400kHz I2C master clock speed 
24B0:  MOVLW  68
24B2:  MOVWF  5A
24B4:  MOVLW  24
24B6:  MOVWF  5B
24B8:  MOVLW  0D
24BA:  MOVWF  5C
24BC:  RCALL  2410
....................  
....................     mpu9250_writeByte(AK8963_ADDRESS, AK8963_CNTL2_Reg , 0x01);                  // Reset the AK8963 magnetometer 
24BE:  MOVLW  0C
24C0:  MOVWF  5A
24C2:  MOVLW  0B
24C4:  MOVWF  5B
24C6:  MOVLW  01
24C8:  MOVWF  5C
24CA:  RCALL  2410
....................     mpu9250_writeByte(AK8963_ADDRESS, AK8963_CNTL1_Reg, 0x12);                   // Set the magnetometer to 16 bit resolution, 100 Hz update rate 
24CC:  MOVLW  0C
24CE:  MOVWF  5A
24D0:  MOVLW  0A
24D2:  MOVWF  5B
24D4:  MOVLW  12
24D6:  MOVWF  5C
24D8:  RCALL  2410
....................  
....................     delay_ms(100); 
24DA:  MOVLW  64
24DC:  MOVWF  5D
24DE:  RCALL  23C8
....................  
....................     uint8_t status = 0; 
24E0:  CLRF   59
24E2:  CLRF   16
24E4:  BTFSC  FF2.7
24E6:  BSF    16.7
24E8:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, WHO_AM_I_MPU9250, &status); 
24EA:  MOVLW  68
24EC:  MOVWF  xA5
24EE:  MOVLW  75
24F0:  MOVWF  xA6
24F2:  CLRF   xA8
24F4:  MOVLW  59
24F6:  MOVWF  xA7
24F8:  CALL   0102
24FC:  BTFSC  16.7
24FE:  BSF    FF2.7
....................     if (status == MPU9250_ADDRESS_ID) { 
2500:  MOVF   59,W
2502:  SUBLW  71
2504:  BNZ   2512
....................         printf( "MPU9250 is online...\n\r" ); 
2506:  MOVLW  16
2508:  MOVWF  FF6
250A:  MOVLW  22
250C:  MOVWF  FF7
250E:  RCALL  23EE
....................     } else { 
2510:  BRA    251C
....................         printf( "MPU9250 is not online...\n\r" ); 
2512:  MOVLW  2E
2514:  MOVWF  FF6
2516:  MOVLW  22
2518:  MOVWF  FF7
251A:  RCALL  23EE
251C:  CLRF   16
251E:  BTFSC  FF2.7
2520:  BSF    16.7
2522:  BCF    FF2.7
....................     } 
....................     mpu9250_readByte(AK8963_ADDRESS, WHO_AM_I_AK8963, &status); 
2524:  MOVLW  0C
2526:  MOVWF  xA5
2528:  CLRF   xA6
252A:  CLRF   xA8
252C:  MOVLW  59
252E:  MOVWF  xA7
2530:  CALL   0102
2534:  BTFSC  16.7
2536:  BSF    FF2.7
....................     if (status == AK8963_ADDRESS_ID) { 
2538:  MOVF   59,W
253A:  SUBLW  48
253C:  BNZ   254A
....................         printf( "AK8963 is online...\n\r" ); 
253E:  MOVLW  4A
2540:  MOVWF  FF6
2542:  MOVLW  22
2544:  MOVWF  FF7
2546:  RCALL  23EE
....................     } else { 
2548:  BRA    2554
....................         printf( "AK8963 is not online...\n\r" ); 
254A:  MOVLW  60
254C:  MOVWF  FF6
254E:  MOVLW  22
2550:  MOVWF  FF7
2552:  RCALL  23EE
....................     } 
2554:  GOTO   2C28 (RETURN)
....................  
.................... } 
....................  
.................... // Function to read and print the initial register values of the MPU9250 
.................... void mpu9250_print_initRegisters(void) { 
*
259A:  CLRF   59
259C:  CLRF   16
259E:  BTFSC  FF2.7
25A0:  BSF    16.7
25A2:  BCF    FF2.7
....................     uint8_t data = 0; 
....................     mpu9250_readByte(MPU9250_ADDRESS, CONFIG, &data); 
25A4:  MOVLW  68
25A6:  MOVWF  xA5
25A8:  MOVLW  1A
25AA:  MOVWF  xA6
25AC:  CLRF   xA8
25AE:  MOVLW  59
25B0:  MOVWF  xA7
25B2:  CALL   0102
25B6:  BTFSC  16.7
25B8:  BSF    FF2.7
....................     printf("0x03->> CONFIG: %x\n\r", data); 
25BA:  MOVLW  7A
25BC:  MOVWF  FF6
25BE:  MOVLW  22
25C0:  MOVWF  FF7
25C2:  CLRF   16
25C4:  BTFSC  FF2.7
25C6:  BSF    16.7
25C8:  BCF    FF2.7
25CA:  MOVLW  10
25CC:  MOVWF  x7A
25CE:  CALL   1C32
25D2:  BTFSC  16.7
25D4:  BSF    FF2.7
25D6:  MOVFF  59,5A
25DA:  MOVLW  57
25DC:  MOVWF  5B
25DE:  RCALL  2558
25E0:  MOVLW  0A
25E2:  BTFSS  F9E.4
25E4:  BRA    25E2
25E6:  MOVWF  FAD
25E8:  MOVLW  0D
25EA:  BTFSS  F9E.4
25EC:  BRA    25EA
25EE:  MOVWF  FAD
25F0:  CLRF   16
25F2:  BTFSC  FF2.7
25F4:  BSF    16.7
25F6:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, PWR_MGMT_1, &data); 
25F8:  MOVLW  68
25FA:  MOVWF  xA5
25FC:  MOVLW  6B
25FE:  MOVWF  xA6
2600:  CLRF   xA8
2602:  MOVLW  59
2604:  MOVWF  xA7
2606:  CALL   0102
260A:  BTFSC  16.7
260C:  BSF    FF2.7
....................     printf("0x01->> PWR_MGMT_1: %x\n\r", data); 
260E:  MOVLW  90
2610:  MOVWF  FF6
2612:  MOVLW  22
2614:  MOVWF  FF7
2616:  CLRF   16
2618:  BTFSC  FF2.7
261A:  BSF    16.7
261C:  BCF    FF2.7
261E:  MOVLW  14
2620:  MOVWF  x7A
2622:  CALL   1C32
2626:  BTFSC  16.7
2628:  BSF    FF2.7
262A:  MOVFF  59,5A
262E:  MOVLW  57
2630:  MOVWF  5B
2632:  RCALL  2558
2634:  MOVLW  0A
2636:  BTFSS  F9E.4
2638:  BRA    2636
263A:  MOVWF  FAD
263C:  MOVLW  0D
263E:  BTFSS  F9E.4
2640:  BRA    263E
2642:  MOVWF  FAD
2644:  CLRF   16
2646:  BTFSC  FF2.7
2648:  BSF    16.7
264A:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, PWR_MGMT_2, &data); 
264C:  MOVLW  68
264E:  MOVWF  xA5
2650:  MOVLW  6C
2652:  MOVWF  xA6
2654:  CLRF   xA8
2656:  MOVLW  59
2658:  MOVWF  xA7
265A:  CALL   0102
265E:  BTFSC  16.7
2660:  BSF    FF2.7
....................     printf("0x00->> PWR_MGMT_2: %x\n\r", data); 
2662:  MOVLW  AA
2664:  MOVWF  FF6
2666:  MOVLW  22
2668:  MOVWF  FF7
266A:  CLRF   16
266C:  BTFSC  FF2.7
266E:  BSF    16.7
2670:  BCF    FF2.7
2672:  MOVLW  14
2674:  MOVWF  x7A
2676:  CALL   1C32
267A:  BTFSC  16.7
267C:  BSF    FF2.7
267E:  MOVFF  59,5A
2682:  MOVLW  57
2684:  MOVWF  5B
2686:  RCALL  2558
2688:  MOVLW  0A
268A:  BTFSS  F9E.4
268C:  BRA    268A
268E:  MOVWF  FAD
2690:  MOVLW  0D
2692:  BTFSS  F9E.4
2694:  BRA    2692
2696:  MOVWF  FAD
2698:  CLRF   16
269A:  BTFSC  FF2.7
269C:  BSF    16.7
269E:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, INT_PIN_CFG, &data); 
26A0:  MOVLW  68
26A2:  MOVWF  xA5
26A4:  MOVLW  37
26A6:  MOVWF  xA6
26A8:  CLRF   xA8
26AA:  MOVLW  59
26AC:  MOVWF  xA7
26AE:  CALL   0102
26B2:  BTFSC  16.7
26B4:  BSF    FF2.7
....................     printf("0x02->> INT_PIN_CFG: %x\n\r", data); 
26B6:  MOVLW  C4
26B8:  MOVWF  FF6
26BA:  MOVLW  22
26BC:  MOVWF  FF7
26BE:  CLRF   16
26C0:  BTFSC  FF2.7
26C2:  BSF    16.7
26C4:  BCF    FF2.7
26C6:  MOVLW  15
26C8:  MOVWF  x7A
26CA:  CALL   1C32
26CE:  BTFSC  16.7
26D0:  BSF    FF2.7
26D2:  MOVFF  59,5A
26D6:  MOVLW  57
26D8:  MOVWF  5B
26DA:  RCALL  2558
26DC:  MOVLW  0A
26DE:  BTFSS  F9E.4
26E0:  BRA    26DE
26E2:  MOVWF  FAD
26E4:  MOVLW  0D
26E6:  BTFSS  F9E.4
26E8:  BRA    26E6
26EA:  MOVWF  FAD
26EC:  CLRF   16
26EE:  BTFSC  FF2.7
26F0:  BSF    16.7
26F2:  BCF    FF2.7
....................     mpu9250_readByte(MPU9250_ADDRESS, WHO_AM_I_MPU9250, &data); 
26F4:  MOVLW  68
26F6:  MOVWF  xA5
26F8:  MOVLW  75
26FA:  MOVWF  xA6
26FC:  CLRF   xA8
26FE:  MOVLW  59
2700:  MOVWF  xA7
2702:  CALL   0102
2706:  BTFSC  16.7
2708:  BSF    FF2.7
....................     printf("0x071->> WHO_AM_I_MPU9250: %x\n\r", data); 
270A:  MOVLW  DE
270C:  MOVWF  FF6
270E:  MOVLW  22
2710:  MOVWF  FF7
2712:  CLRF   16
2714:  BTFSC  FF2.7
2716:  BSF    16.7
2718:  BCF    FF2.7
271A:  MOVLW  1B
271C:  MOVWF  x7A
271E:  CALL   1C32
2722:  BTFSC  16.7
2724:  BSF    FF2.7
2726:  MOVFF  59,5A
272A:  MOVLW  57
272C:  MOVWF  5B
272E:  RCALL  2558
2730:  MOVLW  0A
2732:  BTFSS  F9E.4
2734:  BRA    2732
2736:  MOVWF  FAD
2738:  MOVLW  0D
273A:  BTFSS  F9E.4
273C:  BRA    273A
273E:  MOVWF  FAD
2740:  CLRF   16
2742:  BTFSC  FF2.7
2744:  BSF    16.7
2746:  BCF    FF2.7
....................     mpu9250_readByte(AK8963_ADDRESS, WHO_AM_I_AK8963, &data); 
2748:  MOVLW  0C
274A:  MOVWF  xA5
274C:  CLRF   xA6
274E:  CLRF   xA8
2750:  MOVLW  59
2752:  MOVWF  xA7
2754:  CALL   0102
2758:  BTFSC  16.7
275A:  BSF    FF2.7
....................     printf("048->>  WHO_AM_I_AK8963: %x\n\r", data); 
275C:  MOVLW  FE
275E:  MOVWF  FF6
2760:  MOVLW  22
2762:  MOVWF  FF7
2764:  CLRF   16
2766:  BTFSC  FF2.7
2768:  BSF    16.7
276A:  BCF    FF2.7
276C:  MOVLW  19
276E:  MOVWF  x7A
2770:  CALL   1C32
2774:  BTFSC  16.7
2776:  BSF    FF2.7
2778:  MOVFF  59,5A
277C:  MOVLW  57
277E:  MOVWF  5B
2780:  RCALL  2558
2782:  MOVLW  0A
2784:  BTFSS  F9E.4
2786:  BRA    2784
2788:  MOVWF  FAD
278A:  MOVLW  0D
278C:  BTFSS  F9E.4
278E:  BRA    278C
2790:  MOVWF  FAD
2792:  GOTO   2C2A (RETURN)
.................... } 
....................  
.................... // Function to read gyro data and convert it to degrees per second 
.................... void mpu9250_read_gyro(float gyroData[]) { 
*
0334:  CLRF   x7E
0336:  CLRF   x7D
....................     int16_t gyroX, gyroY, gyroZ = 0; 
....................     read_gyro_word(GYRO_XOUT_H, GYRO_XOUT_L, &gyroX); 
0338:  MOVLW  43
033A:  MOVWF  x7F
033C:  MOVLW  44
033E:  MOVWF  x80
0340:  CLRF   x82
0342:  MOVLW  79
0344:  MOVWF  x81
0346:  RCALL  017A
....................     read_gyro_word(GYRO_YOUT_H, GYRO_YOUT_L, &gyroY); 
0348:  MOVLW  45
034A:  MOVWF  x7F
034C:  MOVLW  46
034E:  MOVWF  x80
0350:  CLRF   x82
0352:  MOVLW  7B
0354:  MOVWF  x81
0356:  RCALL  017A
....................     read_gyro_word(GYRO_ZOUT_H, GYRO_ZOUT_L, &gyroZ); 
0358:  MOVLW  47
035A:  MOVWF  x7F
035C:  MOVLW  48
035E:  MOVWF  x80
0360:  CLRF   x82
0362:  MOVLW  7D
0364:  MOVWF  x81
0366:  RCALL  017A
....................     gyroData[0] = gyroX / GYRO_SCALE; 
0368:  MOVFF  77,FE9
036C:  MOVFF  78,FEA
0370:  MOVFF  7A,A3
0374:  MOVFF  79,A2
0378:  RCALL  0192
037A:  MOVFF  03,B2
037E:  MOVFF  02,B1
0382:  MOVFF  01,B0
0386:  MOVFF  00,AF
038A:  CLRF   xB6
038C:  CLRF   xB5
038E:  MOVLW  03
0390:  MOVWF  xB4
0392:  MOVLW  85
0394:  MOVWF  xB3
0396:  RCALL  01DA
0398:  MOVFF  00,FEF
039C:  MOVFF  01,FEC
03A0:  MOVFF  02,FEC
03A4:  MOVFF  03,FEC
....................     gyroData[1] = gyroY / GYRO_SCALE; 
03A8:  MOVLW  04
03AA:  ADDWF  x77,W
03AC:  MOVWF  FE9
03AE:  MOVLW  00
03B0:  ADDWFC x78,W
03B2:  MOVWF  FEA
03B4:  MOVFF  7C,A3
03B8:  MOVFF  7B,A2
03BC:  RCALL  0192
03BE:  MOVFF  03,B2
03C2:  MOVFF  02,B1
03C6:  MOVFF  01,B0
03CA:  MOVFF  00,AF
03CE:  CLRF   xB6
03D0:  CLRF   xB5
03D2:  MOVLW  03
03D4:  MOVWF  xB4
03D6:  MOVLW  85
03D8:  MOVWF  xB3
03DA:  RCALL  01DA
03DC:  MOVFF  00,FEF
03E0:  MOVFF  01,FEC
03E4:  MOVFF  02,FEC
03E8:  MOVFF  03,FEC
....................     gyroData[2] = gyroZ / GYRO_SCALE; 
03EC:  MOVLW  08
03EE:  ADDWF  x77,W
03F0:  MOVWF  FE9
03F2:  MOVLW  00
03F4:  ADDWFC x78,W
03F6:  MOVWF  FEA
03F8:  MOVFF  7E,A3
03FC:  MOVFF  7D,A2
0400:  RCALL  0192
0402:  MOVFF  03,B2
0406:  MOVFF  02,B1
040A:  MOVFF  01,B0
040E:  MOVFF  00,AF
0412:  CLRF   xB6
0414:  CLRF   xB5
0416:  MOVLW  03
0418:  MOVWF  xB4
041A:  MOVLW  85
041C:  MOVWF  xB3
041E:  RCALL  01DA
0420:  MOVFF  00,FEF
0424:  MOVFF  01,FEC
0428:  MOVFF  02,FEC
042C:  MOVFF  03,FEC
0430:  RETURN 0
.................... } 
....................  
.................... // Function to read accelerometer data and convert it to g 
.................... void mpu9250_read_accelerometer(float accelData[] ) { 
*
06B4:  CLRF   x95
06B6:  CLRF   x94
....................     int16_t accelX, accelY, accelZ = 0; 
....................     read_accel_word(ACCEL_XOUT_H, ACCEL_XOUT_L, &accelX); 
06B8:  MOVLW  3B
06BA:  MOVWF  x96
06BC:  MOVLW  3C
06BE:  MOVWF  x97
06C0:  CLRF   x99
06C2:  MOVLW  90
06C4:  MOVWF  x98
06C6:  RCALL  0432
....................     read_accel_word(ACCEL_YOUT_H, ACCEL_YOUT_L, &accelY); 
06C8:  MOVLW  3D
06CA:  MOVWF  x96
06CC:  MOVLW  3E
06CE:  MOVWF  x97
06D0:  CLRF   x99
06D2:  MOVLW  92
06D4:  MOVWF  x98
06D6:  RCALL  0432
....................     read_accel_word(ACCEL_ZOUT_H, ACCEL_ZOUT_L, &accelZ); 
06D8:  MOVLW  3F
06DA:  MOVWF  x96
06DC:  MOVLW  40
06DE:  MOVWF  x97
06E0:  CLRF   x99
06E2:  MOVLW  94
06E4:  MOVWF  x98
06E6:  RCALL  0432
....................     accelData[0] = (accelX / ACCEL_SCALE) +ACCEL_X_OFFSET; 
06E8:  MOVFF  8E,FE9
06EC:  MOVFF  8F,FEA
06F0:  MOVFF  91,A3
06F4:  MOVFF  90,A2
06F8:  RCALL  0192
06FA:  MOVFF  03,B2
06FE:  MOVFF  02,B1
0702:  MOVFF  01,B0
0706:  MOVFF  00,AF
070A:  CLRF   xB6
070C:  CLRF   xB5
070E:  CLRF   xB4
0710:  MOVLW  8B
0712:  MOVWF  xB3
0714:  RCALL  01DA
0716:  MOVFF  03,9B
071A:  MOVFF  02,9A
071E:  MOVFF  01,99
0722:  MOVFF  00,98
0726:  MOVFF  FEA,9D
072A:  MOVFF  FE9,9C
072E:  BCF    FD8.1
0730:  MOVFF  03,B2
0734:  MOVFF  02,B1
0738:  MOVFF  01,B0
073C:  MOVFF  00,AF
0740:  MOVLW  0A
0742:  MOVWF  xB6
0744:  MOVLW  D7
0746:  MOVWF  xB5
0748:  MOVLW  23
074A:  MOVWF  xB4
074C:  MOVLW  77
074E:  MOVWF  xB3
0750:  RCALL  044A
0752:  MOVFF  9D,FEA
0756:  MOVFF  9C,FE9
075A:  MOVFF  00,FEF
075E:  MOVFF  01,FEC
0762:  MOVFF  02,FEC
0766:  MOVFF  03,FEC
....................     accelData[1] = (accelY / ACCEL_SCALE) -ACCEL_Y_OFFSET; 
076A:  MOVLW  04
076C:  ADDWF  x8E,W
076E:  MOVWF  FE9
0770:  MOVLW  00
0772:  ADDWFC x8F,W
0774:  MOVWF  FEA
0776:  MOVFF  93,A3
077A:  MOVFF  92,A2
077E:  RCALL  0192
0780:  MOVFF  03,B2
0784:  MOVFF  02,B1
0788:  MOVFF  01,B0
078C:  MOVFF  00,AF
0790:  CLRF   xB6
0792:  CLRF   xB5
0794:  CLRF   xB4
0796:  MOVLW  8B
0798:  MOVWF  xB3
079A:  RCALL  01DA
079C:  MOVFF  03,9B
07A0:  MOVFF  02,9A
07A4:  MOVFF  01,99
07A8:  MOVFF  00,98
07AC:  MOVFF  FEA,9D
07B0:  MOVFF  FE9,9C
07B4:  BSF    FD8.1
07B6:  MOVFF  03,B2
07BA:  MOVFF  02,B1
07BE:  MOVFF  01,B0
07C2:  MOVFF  00,AF
07C6:  MOVLW  FA
07C8:  MOVWF  xB6
07CA:  MOVLW  ED
07CC:  MOVWF  xB5
07CE:  MOVLW  6B
07D0:  MOVWF  xB4
07D2:  MOVLW  78
07D4:  MOVWF  xB3
07D6:  RCALL  044A
07D8:  MOVFF  9D,FEA
07DC:  MOVFF  9C,FE9
07E0:  MOVFF  00,FEF
07E4:  MOVFF  01,FEC
07E8:  MOVFF  02,FEC
07EC:  MOVFF  03,FEC
....................     accelData[2] = (accelZ / ACCEL_SCALE) +ACCEL_Z_OFFSET; 
07F0:  MOVLW  08
07F2:  ADDWF  x8E,W
07F4:  MOVWF  FE9
07F6:  MOVLW  00
07F8:  ADDWFC x8F,W
07FA:  MOVWF  FEA
07FC:  MOVFF  95,A3
0800:  MOVFF  94,A2
0804:  RCALL  0192
0806:  MOVFF  03,B2
080A:  MOVFF  02,B1
080E:  MOVFF  01,B0
0812:  MOVFF  00,AF
0816:  CLRF   xB6
0818:  CLRF   xB5
081A:  CLRF   xB4
081C:  MOVLW  8B
081E:  MOVWF  xB3
0820:  RCALL  01DA
0822:  MOVFF  03,9B
0826:  MOVFF  02,9A
082A:  MOVFF  01,99
082E:  MOVFF  00,98
0832:  MOVFF  FEA,9D
0836:  MOVFF  FE9,9C
083A:  BCF    FD8.1
083C:  MOVFF  03,B2
0840:  MOVFF  02,B1
0844:  MOVFF  01,B0
0848:  MOVFF  00,AF
084C:  MOVLW  79
084E:  MOVWF  xB6
0850:  MOVLW  01
0852:  MOVWF  xB5
0854:  MOVLW  76
0856:  MOVWF  xB4
0858:  MOVLW  7A
085A:  MOVWF  xB3
085C:  RCALL  044A
085E:  MOVFF  9D,FEA
0862:  MOVFF  9C,FE9
0866:  MOVFF  00,FEF
086A:  MOVFF  01,FEC
086E:  MOVFF  02,FEC
0872:  MOVFF  03,FEC
0876:  GOTO   138E (RETURN)
.................... } 
....................  
.................... //Function to read magnetometer data and convert it to uT 
.................... void mpu9250_read_magnometer(float magData[]) { 
*
09BA:  CLRF   x95
09BC:  CLRF   x94
09BE:  MOVLW  F0
09C0:  MOVWF  x99
....................  
....................     int16_t magX, magY, magZ = 0; 
....................     uint8_t x_axis , y_axis , z_axis ; 
....................     uint8_t status = 0xF0; 
....................  
....................     mpu9250_readByte( MPU9250_ADDRESS,AK8963_ASAX , &x_axis ); 
09C2:  MOVLW  68
09C4:  MOVWF  xA5
09C6:  MOVLW  10
09C8:  MOVWF  xA6
09CA:  CLRF   xA8
09CC:  MOVLW  96
09CE:  MOVWF  xA7
09D0:  CALL   0102
....................     mpu9250_readByte( MPU9250_ADDRESS,AK8963_ASAY , &y_axis ); 
09D4:  MOVLW  68
09D6:  MOVWF  xA5
09D8:  MOVLW  11
09DA:  MOVWF  xA6
09DC:  CLRF   xA8
09DE:  MOVLW  97
09E0:  MOVWF  xA7
09E2:  CALL   0102
....................     mpu9250_readByte( MPU9250_ADDRESS,AK8963_ASAZ , &z_axis ); 
09E6:  MOVLW  68
09E8:  MOVWF  xA5
09EA:  MOVLW  12
09EC:  MOVWF  xA6
09EE:  CLRF   xA8
09F0:  MOVLW  98
09F2:  MOVWF  xA7
09F4:  CALL   0102
....................  
....................      
....................      
....................     // Check if the data is ready polling ST1 
....................     while(status & 0x01  == 0x01) 
09F8:  BTFSS  x99.0
09FA:  BRA    0A10
....................     { 
....................         mpu9250_readByte(AK8963_ADDRESS, AK8963_ST1_REG, &status); 
09FC:  MOVLW  0C
09FE:  MOVWF  xA5
0A00:  MOVLW  02
0A02:  MOVWF  xA6
0A04:  CLRF   xA8
0A06:  MOVLW  99
0A08:  MOVWF  xA7
0A0A:  CALL   0102
0A0E:  BRA    09F8
....................      
....................     } 
....................      
....................     read_mag_word(MAG_XOUT_H, MAG_XOUT_L, &magX); 
0A10:  MOVLW  04
0A12:  MOVWF  x9A
0A14:  MOVLW  03
0A16:  MOVWF  x9B
0A18:  CLRF   x9D
0A1A:  MOVLW  90
0A1C:  MOVWF  x9C
0A1E:  RCALL  087A
....................         read_mag_word(MAG_YOUT_H, MAG_YOUT_L, &magY); 
0A20:  MOVLW  06
0A22:  MOVWF  x9A
0A24:  MOVLW  05
0A26:  MOVWF  x9B
0A28:  CLRF   x9D
0A2A:  MOVLW  92
0A2C:  MOVWF  x9C
0A2E:  RCALL  087A
....................         read_mag_word(MAG_ZOUT_H, MAG_ZOUT_L, &magZ); 
0A30:  MOVLW  08
0A32:  MOVWF  x9A
0A34:  MOVLW  07
0A36:  MOVWF  x9B
0A38:  CLRF   x9D
0A3A:  MOVLW  94
0A3C:  MOVWF  x9C
0A3E:  RCALL  087A
....................         // Convert the magnetometer data to uT 
....................         magData[0] = magX *((x_axis-128)*0.5 /128 +1); 
0A40:  MOVFF  8E,FE9
0A44:  MOVFF  8F,FEA
0A48:  MOVLW  80
0A4A:  SUBWF  x96,W
0A4C:  CLRF   x9E
0A4E:  MOVWF  x9D
0A50:  RCALL  0892
0A52:  MOVFF  03,B2
0A56:  MOVFF  02,B1
0A5A:  MOVFF  01,B0
0A5E:  MOVFF  00,AF
0A62:  CLRF   xB6
0A64:  CLRF   xB5
0A66:  CLRF   xB4
0A68:  MOVLW  7E
0A6A:  MOVWF  xB3
0A6C:  RCALL  08C8
0A6E:  MOVFF  03,9F
0A72:  MOVFF  02,9E
0A76:  MOVFF  01,9D
0A7A:  MOVFF  00,9C
0A7E:  MOVFF  03,B2
0A82:  MOVFF  02,B1
0A86:  MOVFF  01,B0
0A8A:  MOVFF  00,AF
0A8E:  CLRF   xB6
0A90:  CLRF   xB5
0A92:  CLRF   xB4
0A94:  MOVLW  86
0A96:  MOVWF  xB3
0A98:  CALL   01DA
0A9C:  MOVFF  03,9F
0AA0:  MOVFF  02,9E
0AA4:  MOVFF  01,9D
0AA8:  MOVFF  00,9C
0AAC:  MOVFF  FEA,A1
0AB0:  MOVFF  FE9,A0
0AB4:  BCF    FD8.1
0AB6:  MOVFF  03,B2
0ABA:  MOVFF  02,B1
0ABE:  MOVFF  01,B0
0AC2:  MOVFF  00,AF
0AC6:  CLRF   xB6
0AC8:  CLRF   xB5
0ACA:  CLRF   xB4
0ACC:  MOVLW  7F
0ACE:  MOVWF  xB3
0AD0:  RCALL  044A
0AD2:  MOVFF  A1,FEA
0AD6:  MOVFF  A0,FE9
0ADA:  MOVFF  03,9F
0ADE:  MOVFF  02,9E
0AE2:  MOVFF  01,9D
0AE6:  MOVFF  00,9C
0AEA:  MOVFF  91,A3
0AEE:  MOVFF  90,A2
0AF2:  CALL   0192
0AF6:  MOVFF  03,B2
0AFA:  MOVFF  02,B1
0AFE:  MOVFF  01,B0
0B02:  MOVFF  00,AF
0B06:  MOVFF  9F,B6
0B0A:  MOVFF  9E,B5
0B0E:  MOVFF  9D,B4
0B12:  MOVFF  9C,B3
0B16:  RCALL  08C8
0B18:  MOVFF  00,FEF
0B1C:  MOVFF  01,FEC
0B20:  MOVFF  02,FEC
0B24:  MOVFF  03,FEC
....................         magData[1] = magY *((y_axis-128)*0.5 /128 +1) ; 
0B28:  MOVLW  04
0B2A:  ADDWF  x8E,W
0B2C:  MOVWF  FE9
0B2E:  MOVLW  00
0B30:  ADDWFC x8F,W
0B32:  MOVWF  FEA
0B34:  MOVLW  80
0B36:  SUBWF  x97,W
0B38:  CLRF   x9E
0B3A:  MOVWF  x9D
0B3C:  RCALL  0892
0B3E:  MOVFF  03,B2
0B42:  MOVFF  02,B1
0B46:  MOVFF  01,B0
0B4A:  MOVFF  00,AF
0B4E:  CLRF   xB6
0B50:  CLRF   xB5
0B52:  CLRF   xB4
0B54:  MOVLW  7E
0B56:  MOVWF  xB3
0B58:  RCALL  08C8
0B5A:  MOVFF  03,9F
0B5E:  MOVFF  02,9E
0B62:  MOVFF  01,9D
0B66:  MOVFF  00,9C
0B6A:  MOVFF  03,B2
0B6E:  MOVFF  02,B1
0B72:  MOVFF  01,B0
0B76:  MOVFF  00,AF
0B7A:  CLRF   xB6
0B7C:  CLRF   xB5
0B7E:  CLRF   xB4
0B80:  MOVLW  86
0B82:  MOVWF  xB3
0B84:  CALL   01DA
0B88:  MOVFF  03,9F
0B8C:  MOVFF  02,9E
0B90:  MOVFF  01,9D
0B94:  MOVFF  00,9C
0B98:  MOVFF  FEA,A1
0B9C:  MOVFF  FE9,A0
0BA0:  BCF    FD8.1
0BA2:  MOVFF  03,B2
0BA6:  MOVFF  02,B1
0BAA:  MOVFF  01,B0
0BAE:  MOVFF  00,AF
0BB2:  CLRF   xB6
0BB4:  CLRF   xB5
0BB6:  CLRF   xB4
0BB8:  MOVLW  7F
0BBA:  MOVWF  xB3
0BBC:  RCALL  044A
0BBE:  MOVFF  A1,FEA
0BC2:  MOVFF  A0,FE9
0BC6:  MOVFF  03,9F
0BCA:  MOVFF  02,9E
0BCE:  MOVFF  01,9D
0BD2:  MOVFF  00,9C
0BD6:  MOVFF  93,A3
0BDA:  MOVFF  92,A2
0BDE:  CALL   0192
0BE2:  MOVFF  03,B2
0BE6:  MOVFF  02,B1
0BEA:  MOVFF  01,B0
0BEE:  MOVFF  00,AF
0BF2:  MOVFF  9F,B6
0BF6:  MOVFF  9E,B5
0BFA:  MOVFF  9D,B4
0BFE:  MOVFF  9C,B3
0C02:  RCALL  08C8
0C04:  MOVFF  00,FEF
0C08:  MOVFF  01,FEC
0C0C:  MOVFF  02,FEC
0C10:  MOVFF  03,FEC
....................         magData[2] =  magZ *((z_axis-128)*0.5 /128 +1) ; 
0C14:  MOVLW  08
0C16:  ADDWF  x8E,W
0C18:  MOVWF  FE9
0C1A:  MOVLW  00
0C1C:  ADDWFC x8F,W
0C1E:  MOVWF  FEA
0C20:  MOVLW  80
0C22:  SUBWF  x98,W
0C24:  CLRF   x9E
0C26:  MOVWF  x9D
0C28:  RCALL  0892
0C2A:  MOVFF  03,B2
0C2E:  MOVFF  02,B1
0C32:  MOVFF  01,B0
0C36:  MOVFF  00,AF
0C3A:  CLRF   xB6
0C3C:  CLRF   xB5
0C3E:  CLRF   xB4
0C40:  MOVLW  7E
0C42:  MOVWF  xB3
0C44:  RCALL  08C8
0C46:  MOVFF  03,9F
0C4A:  MOVFF  02,9E
0C4E:  MOVFF  01,9D
0C52:  MOVFF  00,9C
0C56:  MOVFF  03,B2
0C5A:  MOVFF  02,B1
0C5E:  MOVFF  01,B0
0C62:  MOVFF  00,AF
0C66:  CLRF   xB6
0C68:  CLRF   xB5
0C6A:  CLRF   xB4
0C6C:  MOVLW  86
0C6E:  MOVWF  xB3
0C70:  CALL   01DA
0C74:  MOVFF  03,9F
0C78:  MOVFF  02,9E
0C7C:  MOVFF  01,9D
0C80:  MOVFF  00,9C
0C84:  MOVFF  FEA,A1
0C88:  MOVFF  FE9,A0
0C8C:  BCF    FD8.1
0C8E:  MOVFF  03,B2
0C92:  MOVFF  02,B1
0C96:  MOVFF  01,B0
0C9A:  MOVFF  00,AF
0C9E:  CLRF   xB6
0CA0:  CLRF   xB5
0CA2:  CLRF   xB4
0CA4:  MOVLW  7F
0CA6:  MOVWF  xB3
0CA8:  CALL   044A
0CAC:  MOVFF  A1,FEA
0CB0:  MOVFF  A0,FE9
0CB4:  MOVFF  03,9F
0CB8:  MOVFF  02,9E
0CBC:  MOVFF  01,9D
0CC0:  MOVFF  00,9C
0CC4:  MOVFF  95,A3
0CC8:  MOVFF  94,A2
0CCC:  CALL   0192
0CD0:  MOVFF  03,B2
0CD4:  MOVFF  02,B1
0CD8:  MOVFF  01,B0
0CDC:  MOVFF  00,AF
0CE0:  MOVFF  9F,B6
0CE4:  MOVFF  9E,B5
0CE8:  MOVFF  9D,B4
0CEC:  MOVFF  9C,B3
0CF0:  RCALL  08C8
0CF2:  MOVFF  00,FEF
0CF6:  MOVFF  01,FEC
0CFA:  MOVFF  02,FEC
0CFE:  MOVFF  03,FEC
....................     mpu9250_readByte(AK8963_ADDRESS, AK8963_ST2_REG, &status); 
0D02:  MOVLW  0C
0D04:  MOVWF  xA5
0D06:  MOVLW  09
0D08:  MOVWF  xA6
0D0A:  CLRF   xA8
0D0C:  MOVLW  99
0D0E:  MOVWF  xA7
0D10:  CALL   0102
0D14:  GOTO   139A (RETURN)
....................      
....................  
.................... } 
....................  
.................... void mpu9250_print_module_values() { 
....................  
....................     // Read the gyro values 
....................     mpu9250_read_gyro(gyro); 
....................     mpu9250_read_magnometer(mag); 
....................     mpu9250_read_accelerometer(accel); 
....................  
....................     // Read the mag values 
....................     printf(ANSI_COLOR_YELLOW"Gyro : X = %.5f, Y = %.5f, Z = %.5f (deg/s)   \t"ANSI_COLOR_RESET, gyro[0], gyro[1], gyro[2]); 
....................     printf(ANSI_COLOR_YELLOW"Mag  : X = %.5f, Y = %.5f, Z = %.5f (uT)      \t"ANSI_COLOR_RESET,  mag[0],  mag[1],  mag[2]); 
....................     printf(ANSI_COLOR_YELLOW"Accel: X = %.5f, Y = %.5f, Z = %.5f (g)     \n\r"ANSI_COLOR_RESET,accel[0],accel[1],accel[2]); 
....................      
.................... } 
....................  
....................  
....................  
.................... // Function to calibrate the accelerometer 
.................... void mpu9250_gyro_calibration( RateCalibration_t *RateCalibration ) 
.................... { 
....................  
....................     for (uint16_t RateCalibrationNumber=0; RateCalibrationNumber<2000; RateCalibrationNumber ++) { 
*
2796:  CLRF   5C
2798:  CLRF   5B
279A:  MOVF   5C,W
279C:  SUBLW  07
279E:  BTFSS  FD8.0
27A0:  BRA    28E6
27A2:  BNZ   27AC
27A4:  MOVF   5B,W
27A6:  SUBLW  CF
27A8:  BTFSS  FD8.0
27AA:  BRA    28E6
27AC:  CLRF   16
27AE:  BTFSC  FF2.7
27B0:  BSF    16.7
27B2:  BCF    FF2.7
....................         mpu9250_read_gyro(gyro); 
27B4:  CLRF   x78
27B6:  MOVLW  1D
27B8:  MOVWF  x77
27BA:  CALL   0334
27BE:  BTFSC  16.7
27C0:  BSF    FF2.7
....................         RateCalibration->roll += gyro[0];     //calculate average value of gyro in x axis 
27C2:  MOVLW  04
27C4:  ADDWF  59,W
27C6:  MOVWF  FE9
27C8:  MOVLW  00
27CA:  ADDWFC 5A,W
27CC:  MOVWF  FEA
27CE:  MOVFF  FEA,64
27D2:  MOVFF  FE9,63
27D6:  BCF    FD8.1
27D8:  CLRF   16
27DA:  BTFSC  FF2.7
27DC:  BSF    16.7
27DE:  BCF    FF2.7
27E0:  MOVFF  FEF,AF
27E4:  MOVFF  FEC,B0
27E8:  MOVFF  FEC,B1
27EC:  MOVFF  FEC,B2
27F0:  MOVFF  20,B6
27F4:  MOVFF  1F,B5
27F8:  MOVFF  1E,B4
27FC:  MOVFF  1D,B3
2800:  CALL   044A
2804:  BTFSC  16.7
2806:  BSF    FF2.7
2808:  MOVFF  64,FEA
280C:  MOVFF  63,FE9
2810:  MOVFF  00,FEF
2814:  MOVFF  01,FEC
2818:  MOVFF  02,FEC
281C:  MOVFF  03,FEC
....................         RateCalibration->pitch  += gyro[1];     //calculate average value of gyro in y axis 
2820:  MOVFF  59,FE9
2824:  MOVFF  5A,FEA
2828:  MOVFF  FEA,64
282C:  MOVFF  FE9,63
2830:  BCF    FD8.1
2832:  CLRF   16
2834:  BTFSC  FF2.7
2836:  BSF    16.7
2838:  BCF    FF2.7
283A:  MOVFF  FEF,AF
283E:  MOVFF  FEC,B0
2842:  MOVFF  FEC,B1
2846:  MOVFF  FEC,B2
284A:  MOVFF  24,B6
284E:  MOVFF  23,B5
2852:  MOVFF  22,B4
2856:  MOVFF  21,B3
285A:  CALL   044A
285E:  BTFSC  16.7
2860:  BSF    FF2.7
2862:  MOVFF  64,FEA
2866:  MOVFF  63,FE9
286A:  MOVFF  00,FEF
286E:  MOVFF  01,FEC
2872:  MOVFF  02,FEC
2876:  MOVFF  03,FEC
....................         RateCalibration->yaw   += gyro[2];     //calculate average value of gyro in z axis 
287A:  MOVLW  08
287C:  ADDWF  59,W
287E:  MOVWF  FE9
2880:  MOVLW  00
2882:  ADDWFC 5A,W
2884:  MOVWF  FEA
2886:  MOVFF  FEA,64
288A:  MOVFF  FE9,63
288E:  BCF    FD8.1
2890:  CLRF   16
2892:  BTFSC  FF2.7
2894:  BSF    16.7
2896:  BCF    FF2.7
2898:  MOVFF  FEF,AF
289C:  MOVFF  FEC,B0
28A0:  MOVFF  FEC,B1
28A4:  MOVFF  FEC,B2
28A8:  MOVFF  28,B6
28AC:  MOVFF  27,B5
28B0:  MOVFF  26,B4
28B4:  MOVFF  25,B3
28B8:  CALL   044A
28BC:  BTFSC  16.7
28BE:  BSF    FF2.7
28C0:  MOVFF  64,FEA
28C4:  MOVFF  63,FE9
28C8:  MOVFF  00,FEF
28CC:  MOVFF  01,FEC
28D0:  MOVFF  02,FEC
28D4:  MOVFF  03,FEC
....................  
....................         delay_ms(1) ; 
28D8:  MOVLW  01
28DA:  MOVWF  5D
28DC:  RCALL  23C8
28DE:  INCF   5B,F
28E0:  BTFSC  FD8.2
28E2:  INCF   5C,F
28E4:  BRA    279A
....................     } 
....................     RateCalibration->roll /= 2000;     //calculate average value of gyro in x axis 
28E6:  MOVLW  04
28E8:  ADDWF  59,W
28EA:  MOVWF  FE9
28EC:  MOVLW  00
28EE:  ADDWFC 5A,W
28F0:  MOVWF  FEA
28F2:  CLRF   16
28F4:  BTFSC  FF2.7
28F6:  BSF    16.7
28F8:  BCF    FF2.7
28FA:  MOVFF  FEF,AF
28FE:  MOVFF  FEC,B0
2902:  MOVFF  FEC,B1
2906:  MOVFF  FEC,B2
290A:  MOVF   FED,F
290C:  MOVF   FED,F
290E:  MOVF   FED,F
2910:  CLRF   xB6
2912:  CLRF   xB5
2914:  MOVLW  7A
2916:  MOVWF  xB4
2918:  MOVLW  89
291A:  MOVWF  xB3
291C:  CALL   01DA
2920:  BTFSC  16.7
2922:  BSF    FF2.7
2924:  MOVFF  00,FEF
2928:  MOVFF  01,FEC
292C:  MOVFF  02,FEC
2930:  MOVFF  03,FEC
....................     RateCalibration->pitch  /= 2000;     //calculate average value of gyro in y axis 
2934:  MOVFF  59,FE9
2938:  MOVFF  5A,FEA
293C:  CLRF   16
293E:  BTFSC  FF2.7
2940:  BSF    16.7
2942:  BCF    FF2.7
2944:  MOVFF  FEF,AF
2948:  MOVFF  FEC,B0
294C:  MOVFF  FEC,B1
2950:  MOVFF  FEC,B2
2954:  MOVF   FED,F
2956:  MOVF   FED,F
2958:  MOVF   FED,F
295A:  CLRF   xB6
295C:  CLRF   xB5
295E:  MOVLW  7A
2960:  MOVWF  xB4
2962:  MOVLW  89
2964:  MOVWF  xB3
2966:  CALL   01DA
296A:  BTFSC  16.7
296C:  BSF    FF2.7
296E:  MOVFF  00,FEF
2972:  MOVFF  01,FEC
2976:  MOVFF  02,FEC
297A:  MOVFF  03,FEC
....................     RateCalibration->yaw   /= 2000;     //calculate average value of gyro in z axis 
297E:  MOVLW  08
2980:  ADDWF  59,W
2982:  MOVWF  FE9
2984:  MOVLW  00
2986:  ADDWFC 5A,W
2988:  MOVWF  FEA
298A:  CLRF   16
298C:  BTFSC  FF2.7
298E:  BSF    16.7
2990:  BCF    FF2.7
2992:  MOVFF  FEF,AF
2996:  MOVFF  FEC,B0
299A:  MOVFF  FEC,B1
299E:  MOVFF  FEC,B2
29A2:  MOVF   FED,F
29A4:  MOVF   FED,F
29A6:  MOVF   FED,F
29A8:  CLRF   xB6
29AA:  CLRF   xB5
29AC:  MOVLW  7A
29AE:  MOVWF  xB4
29B0:  MOVLW  89
29B2:  MOVWF  xB3
29B4:  CALL   01DA
29B8:  BTFSC  16.7
29BA:  BSF    FF2.7
29BC:  MOVFF  00,FEF
29C0:  MOVFF  01,FEC
29C4:  MOVFF  02,FEC
29C8:  MOVFF  03,FEC
29CC:  GOTO   2C4E (RETURN)
....................  
....................  
.................... } 
....................  
....................  
.................... // Function to calculate the yaw, pitch and roll angles 
.................... void mpu9250_calculate_angles(Angle_t *Angle ,float accelData[],float magData[]) 
.................... { 
....................  
....................         // Read the accelerometer and magnetometer values 
....................         mpu9250_read_accelerometer(accelData); 
*
1382:  MOVFF  7E,8F
1386:  MOVFF  7D,8E
138A:  GOTO   06B4
....................         mpu9250_read_magnometer(magData); 
138E:  MOVFF  80,8F
1392:  MOVFF  7F,8E
1396:  GOTO   09BA
....................         float hi_cal [3]; 
....................          
....................         hi_cal[0] =  magData[0] - hard_iron[0];        
139A:  MOVFF  7F,FE9
139E:  MOVFF  80,FEA
13A2:  MOVFF  FEF,8E
13A6:  MOVFF  FEC,8F
13AA:  MOVFF  FEC,90
13AE:  MOVFF  FEC,91
13B2:  MOVFF  FEA,93
13B6:  MOVFF  FE9,92
13BA:  BSF    FD8.1
13BC:  MOVFF  91,B2
13C0:  MOVFF  90,B1
13C4:  MOVFF  8F,B0
13C8:  MOVFF  8E,AF
13CC:  MOVLW  3D
13CE:  MOVWF  xB6
13D0:  MOVLW  5A
13D2:  MOVWF  xB5
13D4:  MOVLW  12
13D6:  MOVWF  xB4
13D8:  MOVLW  87
13DA:  MOVWF  xB3
13DC:  CALL   044A
13E0:  MOVFF  93,FEA
13E4:  MOVFF  92,FE9
13E8:  MOVFF  03,84
13EC:  MOVFF  02,83
13F0:  MOVFF  01,82
13F4:  MOVFF  00,81
....................         hi_cal[1] =  magData[1] - hard_iron[1];        
13F8:  MOVLW  04
13FA:  ADDWF  x7F,W
13FC:  MOVWF  FE9
13FE:  MOVLW  00
1400:  ADDWFC x80,W
1402:  MOVWF  FEA
1404:  MOVFF  FEF,8E
1408:  MOVFF  FEC,8F
140C:  MOVFF  FEC,90
1410:  MOVFF  FEC,91
1414:  MOVFF  FEA,93
1418:  MOVFF  FE9,92
141C:  BSF    FD8.1
141E:  MOVFF  91,B2
1422:  MOVFF  90,B1
1426:  MOVFF  8F,B0
142A:  MOVFF  8E,AF
142E:  MOVLW  EC
1430:  MOVWF  xB6
1432:  MOVLW  E1
1434:  MOVWF  xB5
1436:  MOVLW  39
1438:  MOVWF  xB4
143A:  MOVLW  87
143C:  MOVWF  xB3
143E:  CALL   044A
1442:  MOVFF  93,FEA
1446:  MOVFF  92,FE9
144A:  MOVFF  03,88
144E:  MOVFF  02,87
1452:  MOVFF  01,86
1456:  MOVFF  00,85
....................         hi_cal[2] =  magData[2] - hard_iron[2];        
145A:  MOVLW  08
145C:  ADDWF  x7F,W
145E:  MOVWF  FE9
1460:  MOVLW  00
1462:  ADDWFC x80,W
1464:  MOVWF  FEA
1466:  MOVFF  FEF,8E
146A:  MOVFF  FEC,8F
146E:  MOVFF  FEC,90
1472:  MOVFF  FEC,91
1476:  MOVFF  FEA,93
147A:  MOVFF  FE9,92
147E:  BSF    FD8.1
1480:  MOVFF  91,B2
1484:  MOVFF  90,B1
1488:  MOVFF  8F,B0
148C:  MOVFF  8E,AF
1490:  MOVLW  9A
1492:  MOVWF  xB6
1494:  MOVLW  F9
1496:  MOVWF  xB5
1498:  MOVLW  83
149A:  MOVWF  xB4
149C:  MOVLW  87
149E:  MOVWF  xB3
14A0:  CALL   044A
14A4:  MOVFF  93,FEA
14A8:  MOVFF  92,FE9
14AC:  MOVFF  03,8C
14B0:  MOVFF  02,8B
14B4:  MOVFF  01,8A
14B8:  MOVFF  00,89
....................          
....................         for(uint8_t i = 0 ;i<3;i++) 
14BC:  CLRF   x8D
14BE:  MOVF   x8D,W
14C0:  SUBLW  02
14C2:  BTFSS  FD8.0
14C4:  BRA    16AE
....................         { 
....................             magData[i] = (soft_iron[i][0] * hi_cal[0])+ 
....................                          (soft_iron[i][1] * hi_cal[1])+ 
....................                          (soft_iron[i][2] * hi_cal[2]); 
14C6:  MOVF   x8D,W
14C8:  MULLW  04
14CA:  MOVF   FF3,W
14CC:  CLRF   03
14CE:  ADDWF  x7F,W
14D0:  MOVWF  FE9
14D2:  MOVF   x80,W
14D4:  ADDWFC 03,W
14D6:  MOVWF  FEA
14D8:  MOVF   x8D,W
14DA:  MULLW  0C
14DC:  MOVF   FF3,W
14DE:  CLRF   x91
14E0:  MOVWF  x90
14E2:  MOVFF  91,03
14E6:  MOVF   x90,W
14E8:  MOVFF  FF2,92
14EC:  BCF    FF2.7
14EE:  CALL   0096
14F2:  MOVWF  00
14F4:  TBLRD*+
14F6:  MOVFF  FF5,01
14FA:  TBLRD*+
14FC:  MOVFF  FF5,02
1500:  TBLRD*+
1502:  MOVFF  FF5,03
1506:  BTFSC  x92.7
1508:  BSF    FF2.7
150A:  MOVFF  03,95
150E:  MOVFF  02,94
1512:  MOVFF  01,93
1516:  MOVWF  x92
1518:  MOVFF  03,B2
151C:  MOVFF  02,B1
1520:  MOVFF  01,B0
1524:  MOVWF  xAF
1526:  MOVFF  84,B6
152A:  MOVFF  83,B5
152E:  MOVFF  82,B4
1532:  MOVFF  81,B3
1536:  CALL   08C8
153A:  MOVFF  03,95
153E:  MOVFF  02,94
1542:  MOVFF  01,93
1546:  MOVFF  00,92
154A:  MOVF   x8D,W
154C:  MULLW  0C
154E:  MOVF   FF3,W
1550:  CLRF   x97
1552:  MOVWF  x96
1554:  MOVLW  04
1556:  ADDWF  x96,W
1558:  MOVWF  01
155A:  MOVLW  00
155C:  ADDWFC x97,W
155E:  MOVWF  03
1560:  MOVF   01,W
1562:  MOVFF  FF2,96
1566:  BCF    FF2.7
1568:  CALL   0096
156C:  MOVWF  00
156E:  TBLRD*+
1570:  MOVFF  FF5,01
1574:  TBLRD*+
1576:  MOVFF  FF5,02
157A:  TBLRD*+
157C:  MOVFF  FF5,03
1580:  BTFSC  x96.7
1582:  BSF    FF2.7
1584:  MOVFF  03,99
1588:  MOVFF  02,98
158C:  MOVFF  01,97
1590:  MOVWF  x96
1592:  MOVFF  03,B2
1596:  MOVFF  02,B1
159A:  MOVFF  01,B0
159E:  MOVWF  xAF
15A0:  MOVFF  88,B6
15A4:  MOVFF  87,B5
15A8:  MOVFF  86,B4
15AC:  MOVFF  85,B3
15B0:  CALL   08C8
15B4:  MOVFF  FEA,97
15B8:  MOVFF  FE9,96
15BC:  BCF    FD8.1
15BE:  MOVFF  95,B2
15C2:  MOVFF  94,B1
15C6:  MOVFF  93,B0
15CA:  MOVFF  92,AF
15CE:  MOVFF  03,B6
15D2:  MOVFF  02,B5
15D6:  MOVFF  01,B4
15DA:  MOVFF  00,B3
15DE:  CALL   044A
15E2:  MOVFF  97,FEA
15E6:  MOVFF  96,FE9
15EA:  MOVFF  03,95
15EE:  MOVFF  02,94
15F2:  MOVFF  01,93
15F6:  MOVFF  00,92
15FA:  MOVF   x8D,W
15FC:  MULLW  0C
15FE:  MOVF   FF3,W
1600:  CLRF   x99
1602:  MOVWF  x98
1604:  MOVLW  08
1606:  ADDWF  x98,W
1608:  MOVWF  01
160A:  MOVLW  00
160C:  ADDWFC x99,W
160E:  MOVWF  03
1610:  MOVF   01,W
1612:  MOVFF  FF2,98
1616:  BCF    FF2.7
1618:  CALL   0096
161C:  MOVWF  00
161E:  TBLRD*+
1620:  MOVFF  FF5,01
1624:  TBLRD*+
1626:  MOVFF  FF5,02
162A:  TBLRD*+
162C:  MOVFF  FF5,03
1630:  BTFSC  x98.7
1632:  BSF    FF2.7
1634:  MOVFF  03,9B
1638:  MOVFF  02,9A
163C:  MOVFF  01,99
1640:  MOVWF  x98
1642:  MOVFF  03,B2
1646:  MOVFF  02,B1
164A:  MOVFF  01,B0
164E:  MOVWF  xAF
1650:  MOVFF  8C,B6
1654:  MOVFF  8B,B5
1658:  MOVFF  8A,B4
165C:  MOVFF  89,B3
1660:  CALL   08C8
1664:  MOVFF  FEA,99
1668:  MOVFF  FE9,98
166C:  BCF    FD8.1
166E:  MOVFF  95,B2
1672:  MOVFF  94,B1
1676:  MOVFF  93,B0
167A:  MOVFF  92,AF
167E:  MOVFF  03,B6
1682:  MOVFF  02,B5
1686:  MOVFF  01,B4
168A:  MOVFF  00,B3
168E:  CALL   044A
1692:  MOVFF  99,FEA
1696:  MOVFF  98,FE9
169A:  MOVFF  00,FEF
169E:  MOVFF  01,FEC
16A2:  MOVFF  02,FEC
16A6:  MOVFF  03,FEC
16AA:  INCF   x8D,F
16AC:  BRA    14BE
....................         } 
....................          
....................         // Calculate the roll angle 
....................         Angle->roll = atan( accelData[1] / sqrt(  (float)(accelData[0] * accelData[0] + accelData[2] * accelData[2]) )) * 180.0 / PI; 
16AE:  MOVLW  04
16B0:  ADDWF  x7B,W
16B2:  MOVWF  01
16B4:  MOVLW  00
16B6:  ADDWFC x7C,W
16B8:  MOVWF  03
16BA:  MOVFF  01,8E
16BE:  MOVWF  x8F
16C0:  MOVLW  04
16C2:  ADDWF  x7D,W
16C4:  MOVWF  FE9
16C6:  MOVLW  00
16C8:  ADDWFC x7E,W
16CA:  MOVWF  FEA
16CC:  MOVFF  FEF,90
16D0:  MOVFF  FEC,91
16D4:  MOVFF  FEC,92
16D8:  MOVFF  FEC,93
16DC:  MOVFF  7D,FE9
16E0:  MOVFF  7E,FEA
16E4:  MOVFF  FEF,94
16E8:  MOVFF  FEC,95
16EC:  MOVFF  FEC,96
16F0:  MOVFF  FEC,97
16F4:  MOVFF  7D,FE9
16F8:  MOVFF  7E,FEA
16FC:  MOVFF  FEF,00
1700:  MOVFF  FEC,01
1704:  MOVFF  FEC,02
1708:  MOVFF  FEC,03
170C:  MOVFF  97,B2
1710:  MOVFF  96,B1
1714:  MOVFF  95,B0
1718:  MOVFF  94,AF
171C:  MOVFF  03,B6
1720:  MOVFF  02,B5
1724:  MOVFF  01,B4
1728:  MOVFF  00,B3
172C:  CALL   08C8
1730:  MOVFF  03,97
1734:  MOVFF  02,96
1738:  MOVFF  01,95
173C:  MOVFF  00,94
1740:  MOVLW  08
1742:  ADDWF  x7D,W
1744:  MOVWF  FE9
1746:  MOVLW  00
1748:  ADDWFC x7E,W
174A:  MOVWF  FEA
174C:  MOVFF  FEF,98
1750:  MOVFF  FEC,99
1754:  MOVFF  FEC,9A
1758:  MOVFF  FEC,9B
175C:  MOVLW  08
175E:  ADDWF  x7D,W
1760:  MOVWF  FE9
1762:  MOVLW  00
1764:  ADDWFC x7E,W
1766:  MOVWF  FEA
1768:  MOVFF  FEF,00
176C:  MOVFF  FEC,01
1770:  MOVFF  FEC,02
1774:  MOVFF  FEC,03
1778:  MOVFF  9B,B2
177C:  MOVFF  9A,B1
1780:  MOVFF  99,B0
1784:  MOVFF  98,AF
1788:  MOVFF  03,B6
178C:  MOVFF  02,B5
1790:  MOVFF  01,B4
1794:  MOVFF  00,B3
1798:  CALL   08C8
179C:  MOVFF  FEA,99
17A0:  MOVFF  FE9,98
17A4:  BCF    FD8.1
17A6:  MOVFF  97,B2
17AA:  MOVFF  96,B1
17AE:  MOVFF  95,B0
17B2:  MOVFF  94,AF
17B6:  MOVFF  03,B6
17BA:  MOVFF  02,B5
17BE:  MOVFF  01,B4
17C2:  MOVFF  00,B3
17C6:  CALL   044A
17CA:  MOVFF  99,FEA
17CE:  MOVFF  98,FE9
17D2:  MOVFF  03,97
17D6:  MOVFF  02,96
17DA:  MOVFF  01,95
17DE:  MOVFF  00,94
17E2:  MOVFF  03,9D
17E6:  MOVFF  02,9C
17EA:  MOVFF  01,9B
17EE:  MOVFF  00,9A
17F2:  CALL   0D8E
17F6:  MOVFF  93,B2
17FA:  MOVFF  92,B1
17FE:  MOVFF  91,B0
1802:  MOVFF  90,AF
1806:  MOVFF  03,B6
180A:  MOVFF  02,B5
180E:  MOVFF  01,B4
1812:  MOVFF  00,B3
1816:  CALL   01DA
181A:  MOVFF  03,93
181E:  MOVFF  02,92
1822:  MOVFF  01,91
1826:  MOVFF  00,90
182A:  MOVFF  03,9D
182E:  MOVFF  02,9C
1832:  MOVFF  01,9B
1836:  MOVFF  00,9A
183A:  CALL   0E9C
183E:  MOVFF  03,93
1842:  MOVFF  02,92
1846:  MOVFF  01,91
184A:  MOVFF  00,90
184E:  MOVFF  03,B2
1852:  MOVFF  02,B1
1856:  MOVFF  01,B0
185A:  MOVFF  00,AF
185E:  CLRF   xB6
1860:  CLRF   xB5
1862:  MOVLW  34
1864:  MOVWF  xB4
1866:  MOVLW  86
1868:  MOVWF  xB3
186A:  CALL   08C8
186E:  MOVFF  03,93
1872:  MOVFF  02,92
1876:  MOVFF  01,91
187A:  MOVFF  00,90
187E:  MOVFF  03,B2
1882:  MOVFF  02,B1
1886:  MOVFF  01,B0
188A:  MOVFF  00,AF
188E:  MOVLW  DB
1890:  MOVWF  xB6
1892:  MOVLW  0F
1894:  MOVWF  xB5
1896:  MOVLW  49
1898:  MOVWF  xB4
189A:  MOVLW  80
189C:  MOVWF  xB3
189E:  CALL   01DA
18A2:  MOVFF  8F,FEA
18A6:  MOVFF  8E,FE9
18AA:  MOVFF  00,FEF
18AE:  MOVFF  01,FEC
18B2:  MOVFF  02,FEC
18B6:  MOVFF  03,FEC
....................         // Calculate the pitch angle 
....................         Angle->pitch = atan( accelData[0] / sqrt( (float) (accelData[1] * accelData[1] + accelData[2] * accelData[2]) )) * (-180.0) / PI; 
18BA:  MOVFF  7B,8E
18BE:  MOVFF  7C,8F
18C2:  MOVFF  7D,FE9
18C6:  MOVFF  7E,FEA
18CA:  MOVFF  FEF,90
18CE:  MOVFF  FEC,91
18D2:  MOVFF  FEC,92
18D6:  MOVFF  FEC,93
18DA:  MOVLW  04
18DC:  ADDWF  x7D,W
18DE:  MOVWF  FE9
18E0:  MOVLW  00
18E2:  ADDWFC x7E,W
18E4:  MOVWF  FEA
18E6:  MOVFF  FEF,94
18EA:  MOVFF  FEC,95
18EE:  MOVFF  FEC,96
18F2:  MOVFF  FEC,97
18F6:  MOVLW  04
18F8:  ADDWF  x7D,W
18FA:  MOVWF  FE9
18FC:  MOVLW  00
18FE:  ADDWFC x7E,W
1900:  MOVWF  FEA
1902:  MOVFF  FEF,00
1906:  MOVFF  FEC,01
190A:  MOVFF  FEC,02
190E:  MOVFF  FEC,03
1912:  MOVFF  97,B2
1916:  MOVFF  96,B1
191A:  MOVFF  95,B0
191E:  MOVFF  94,AF
1922:  MOVFF  03,B6
1926:  MOVFF  02,B5
192A:  MOVFF  01,B4
192E:  MOVFF  00,B3
1932:  CALL   08C8
1936:  MOVFF  03,97
193A:  MOVFF  02,96
193E:  MOVFF  01,95
1942:  MOVFF  00,94
1946:  MOVLW  08
1948:  ADDWF  x7D,W
194A:  MOVWF  FE9
194C:  MOVLW  00
194E:  ADDWFC x7E,W
1950:  MOVWF  FEA
1952:  MOVFF  FEF,98
1956:  MOVFF  FEC,99
195A:  MOVFF  FEC,9A
195E:  MOVFF  FEC,9B
1962:  MOVLW  08
1964:  ADDWF  x7D,W
1966:  MOVWF  FE9
1968:  MOVLW  00
196A:  ADDWFC x7E,W
196C:  MOVWF  FEA
196E:  MOVFF  FEF,00
1972:  MOVFF  FEC,01
1976:  MOVFF  FEC,02
197A:  MOVFF  FEC,03
197E:  MOVFF  9B,B2
1982:  MOVFF  9A,B1
1986:  MOVFF  99,B0
198A:  MOVFF  98,AF
198E:  MOVFF  03,B6
1992:  MOVFF  02,B5
1996:  MOVFF  01,B4
199A:  MOVFF  00,B3
199E:  CALL   08C8
19A2:  MOVFF  FEA,99
19A6:  MOVFF  FE9,98
19AA:  BCF    FD8.1
19AC:  MOVFF  97,B2
19B0:  MOVFF  96,B1
19B4:  MOVFF  95,B0
19B8:  MOVFF  94,AF
19BC:  MOVFF  03,B6
19C0:  MOVFF  02,B5
19C4:  MOVFF  01,B4
19C8:  MOVFF  00,B3
19CC:  CALL   044A
19D0:  MOVFF  99,FEA
19D4:  MOVFF  98,FE9
19D8:  MOVFF  03,97
19DC:  MOVFF  02,96
19E0:  MOVFF  01,95
19E4:  MOVFF  00,94
19E8:  MOVFF  03,9D
19EC:  MOVFF  02,9C
19F0:  MOVFF  01,9B
19F4:  MOVFF  00,9A
19F8:  CALL   0D8E
19FC:  MOVFF  93,B2
1A00:  MOVFF  92,B1
1A04:  MOVFF  91,B0
1A08:  MOVFF  90,AF
1A0C:  MOVFF  03,B6
1A10:  MOVFF  02,B5
1A14:  MOVFF  01,B4
1A18:  MOVFF  00,B3
1A1C:  CALL   01DA
1A20:  MOVFF  03,93
1A24:  MOVFF  02,92
1A28:  MOVFF  01,91
1A2C:  MOVFF  00,90
1A30:  MOVFF  03,9D
1A34:  MOVFF  02,9C
1A38:  MOVFF  01,9B
1A3C:  MOVFF  00,9A
1A40:  CALL   0E9C
1A44:  MOVFF  03,93
1A48:  MOVFF  02,92
1A4C:  MOVFF  01,91
1A50:  MOVFF  00,90
1A54:  MOVFF  03,B2
1A58:  MOVFF  02,B1
1A5C:  MOVFF  01,B0
1A60:  MOVFF  00,AF
1A64:  CLRF   xB6
1A66:  CLRF   xB5
1A68:  MOVLW  B4
1A6A:  MOVWF  xB4
1A6C:  MOVLW  86
1A6E:  MOVWF  xB3
1A70:  CALL   08C8
1A74:  MOVFF  03,93
1A78:  MOVFF  02,92
1A7C:  MOVFF  01,91
1A80:  MOVFF  00,90
1A84:  MOVFF  03,B2
1A88:  MOVFF  02,B1
1A8C:  MOVFF  01,B0
1A90:  MOVFF  00,AF
1A94:  MOVLW  DB
1A96:  MOVWF  xB6
1A98:  MOVLW  0F
1A9A:  MOVWF  xB5
1A9C:  MOVLW  49
1A9E:  MOVWF  xB4
1AA0:  MOVLW  80
1AA2:  MOVWF  xB3
1AA4:  CALL   01DA
1AA8:  MOVFF  8F,FEA
1AAC:  MOVFF  8E,FE9
1AB0:  MOVFF  00,FEF
1AB4:  MOVFF  01,FEC
1AB8:  MOVFF  02,FEC
1ABC:  MOVFF  03,FEC
....................         Angle->yaw = 1* atan((float)magData[0] / (float)magData[1]) * 180 / PI; 
1AC0:  MOVLW  08
1AC2:  ADDWF  x7B,W
1AC4:  MOVWF  01
1AC6:  MOVLW  00
1AC8:  ADDWFC x7C,W
1ACA:  MOVFF  01,8E
1ACE:  MOVWF  x8F
1AD0:  MOVFF  7F,FE9
1AD4:  MOVFF  80,FEA
1AD8:  MOVFF  FEF,00
1ADC:  MOVFF  FEC,01
1AE0:  MOVFF  FEC,02
1AE4:  MOVFF  FEC,03
1AE8:  MOVFF  03,93
1AEC:  MOVFF  02,92
1AF0:  MOVFF  01,91
1AF4:  MOVFF  00,90
1AF8:  MOVLW  04
1AFA:  ADDWF  x7F,W
1AFC:  MOVWF  FE9
1AFE:  MOVLW  00
1B00:  ADDWFC x80,W
1B02:  MOVWF  FEA
1B04:  MOVFF  FEF,00
1B08:  MOVFF  FEC,01
1B0C:  MOVFF  FEC,02
1B10:  MOVFF  FEC,03
1B14:  MOVFF  93,B2
1B18:  MOVFF  92,B1
1B1C:  MOVFF  91,B0
1B20:  MOVFF  90,AF
1B24:  MOVFF  03,B6
1B28:  MOVFF  02,B5
1B2C:  MOVFF  01,B4
1B30:  MOVFF  00,B3
1B34:  CALL   01DA
1B38:  MOVFF  03,93
1B3C:  MOVFF  02,92
1B40:  MOVFF  01,91
1B44:  MOVFF  00,90
1B48:  MOVFF  03,9D
1B4C:  MOVFF  02,9C
1B50:  MOVFF  01,9B
1B54:  MOVFF  00,9A
1B58:  CALL   0E9C
1B5C:  CLRF   xB2
1B5E:  CLRF   xB1
1B60:  CLRF   xB0
1B62:  MOVLW  7F
1B64:  MOVWF  xAF
1B66:  MOVFF  03,B6
1B6A:  MOVFF  02,B5
1B6E:  MOVFF  01,B4
1B72:  MOVFF  00,B3
1B76:  CALL   08C8
1B7A:  MOVFF  03,93
1B7E:  MOVFF  02,92
1B82:  MOVFF  01,91
1B86:  MOVFF  00,90
1B8A:  MOVFF  03,B2
1B8E:  MOVFF  02,B1
1B92:  MOVFF  01,B0
1B96:  MOVFF  00,AF
1B9A:  CLRF   xB6
1B9C:  CLRF   xB5
1B9E:  MOVLW  34
1BA0:  MOVWF  xB4
1BA2:  MOVLW  86
1BA4:  MOVWF  xB3
1BA6:  CALL   08C8
1BAA:  MOVFF  03,93
1BAE:  MOVFF  02,92
1BB2:  MOVFF  01,91
1BB6:  MOVFF  00,90
1BBA:  MOVFF  03,B2
1BBE:  MOVFF  02,B1
1BC2:  MOVFF  01,B0
1BC6:  MOVFF  00,AF
1BCA:  MOVLW  DB
1BCC:  MOVWF  xB6
1BCE:  MOVLW  0F
1BD0:  MOVWF  xB5
1BD2:  MOVLW  49
1BD4:  MOVWF  xB4
1BD6:  MOVLW  80
1BD8:  MOVWF  xB3
1BDA:  CALL   01DA
1BDE:  MOVFF  8F,FEA
1BE2:  MOVFF  8E,FE9
1BE6:  MOVFF  00,FEF
1BEA:  MOVFF  01,FEC
1BEE:  MOVFF  02,FEC
1BF2:  MOVFF  03,FEC
1BF6:  GOTO   1FEA (RETURN)
....................          
....................          
....................         //Angle->roll = atan(0.1);Angle->pitch= 1; 
....................  
.................... } 
....................  
....................  
.................... void kalman_1d(float KalmanState,float KalmanUncertainty, float KalmanInput,float KalmanMeasurement,float Kalman1DOutput[]) 
.................... { 
....................   KalmanState=KalmanState+0.0192*KalmanInput; 
....................   KalmanUncertainty=KalmanUncertainty + 0.0192 * 0.0192 * 4 * 4; 
....................   float KalmanGain=KalmanUncertainty * 1/(1*KalmanUncertainty + 3 * 3); 
....................   KalmanState=KalmanState+KalmanGain * (KalmanMeasurement-KalmanState); 
....................   KalmanUncertainty=(1-KalmanGain) * KalmanUncertainty; 
....................     Kalman1DOutput[0]=KalmanState; 
....................     Kalman1DOutput[1]=KalmanUncertainty; 
.................... } 
....................  
.................... // Calculate the roll angle 
....................  
....................  
.................... // Calculate the pitch angle 
....................  
....................  

Configuration Fuses:
   Word  1: CC27   PLL12 CPUDIV1 USBDIV HS FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8500   CCP2C1 NOPBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
